# Lambdaè¡¨è¾¾å¼
## ä»‹ç»
lambdaè¡¨è¾¾å¼å®é™…ä¸Šæ˜¯ä¸€ä¸ªåŒ¿åå‡½æ•°ï¼Œåœ¨ç¼–è¯‘æ—¶ä¼šå°†è¡¨è¾¾å¼è½¬æ¢ä¸ºåŒ¿åå‡½æ•°ã€‚

è¯­æ³•

```C++
[capture-list] (parameters) mutable -> return-type {statement};
[æ•è·åˆ—è¡¨](å‚æ•°)->è¿”å›å€¼{ å‡½æ•°ä½“ };
```
â‘  `[capture-list]`: æ•æ‰åˆ—è¡¨ï¼Œè¯¥åˆ—è¡¨æ€»æ˜¯å‡ºç°åœ¨lambdaå‡½æ•°çš„å¼€å§‹ä½ç½®ï¼Œç¼–è¯‘å™¨æ ¹æ®[]æ¥åˆ¤æ–­æ¥ä¸‹æ¥çš„ä»£ç æ˜¯å¦ä¸ºlambdaå‡½æ•°ï¼Œæ•æ‰åˆ—è¡¨èƒ½å¤Ÿæ•æ‰ä¸Šä¸‹æ–‡ä¸­çš„å˜é‡ä¾›lambdaå‡½æ•°ä½¿ç”¨ã€‚ï¼ˆä¸èƒ½çœç•¥ï¼‰

â‘¡ `(parameters)`: å‚æ•°åˆ—è¡¨ã€‚ä¸æ™®é€šå‡½æ•°çš„å‚æ•°åˆ—è¡¨ä¸€è‡´ï¼Œå¦‚æœä¸éœ€è¦å‚æ•°ä¼ é€’ï¼Œåˆ™å¯ä»¥è¿åŒ()ä¸€èµ·çœç•¥ï¼ˆæ²¡æœ‰å‚æ•°å¯ä»¥çœç•¥ï¼‰

â‘¢ `mutable`ï¼šé»˜è®¤æƒ…å†µä¸‹ï¼Œlambdaå‡½æ•°æ€»æ˜¯ä¸€ä¸ªconstå‡½æ•°ï¼Œmutableå¯ä»¥å–æ¶ˆå…¶å¸¸é‡æ€§ã€‚ä½¿ç”¨è¯¥ä¿®é¥°ç¬¦æ—¶ï¼Œå‚æ•°åˆ—è¡¨ä¸å¯çœç•¥(å³ä½¿å‚æ•°ä¸ºç©º)ã€‚mutableæ”¾åœ¨å‚æ•°åˆ—è¡¨å’Œè¿”å›å€¼ä¹‹é—´<sup>[1]</sup>

â‘£ `->returntype`ï¼šè¿”å›å€¼ç±»å‹ã€‚ç”¨è¿½è¸ªè¿”å›ç±»å‹å½¢å¼å£°æ˜å‡½æ•°çš„è¿”å›å€¼ç±»å‹ï¼Œæ²¡æœ‰è¿”å›å€¼æ—¶æ­¤éƒ¨åˆ†å¯çœç•¥ã€‚è¿”å›å€¼ç±»å‹æ˜ç¡®æƒ…å†µä¸‹ï¼Œä¹Ÿå¯çœç•¥ï¼Œç”±ç¼–è¯‘å™¨å¯¹è¿”å›ç±»å‹è¿›è¡Œæ¨å¯¼ã€‚ï¼ˆåˆæ²¡æœ‰è¿”å›å€¼éƒ½å¯ä»¥çœç•¥ï¼‰

â‘¤ `{statement}`ï¼šå‡½æ•°ä½“ã€‚åœ¨è¯¥å‡½æ•°ä½“å†…ï¼Œé™¤äº†å¯ä»¥ä½¿ç”¨å…¶å‚æ•°å¤–ï¼Œè¿˜å¯ä»¥ä½¿ç”¨æ‰€æœ‰æ•è·åˆ°çš„å˜é‡ã€‚ï¼ˆä¸èƒ½çœç•¥ï¼‰

### æ•è·åˆ—è¡¨è¯´æ˜
æ•æ‰åˆ—è¡¨æè¿°äº†ä¸Šä¸‹æ–‡ä¸­é‚£äº›æ•°æ®å¯ä»¥è¢«lambdaä½¿ç”¨ï¼Œä»¥åŠä½¿ç”¨çš„æ–¹å¼ä¼ å€¼è¿˜æ˜¯ä¼ å¼•ç”¨.

â‘  `[a,&b]` å…¶ä¸­ a ä»¥å¤åˆ¶æ•è·è€Œ b ä»¥å¼•ç”¨æ•è·ã€‚

â‘¡ `[this]` ä»¥å¼•ç”¨æ•è·å½“å‰å¯¹è±¡ï¼ˆ \*this ï¼‰ï¼Œé€šå¸¸ç”¨äºåœ¨æˆå‘˜å‡½æ•°ä¸­ä½¿ç”¨Lambdaè¡¨è¾¾å¼ã€‚*(åªèƒ½ç”¨åœ¨éé™æ€æˆå‘˜å‡½æ•°å†…éƒ¨)*

â‘¢ `[&]` ä»¥å¼•ç”¨æ•è·æ‰€æœ‰ç”¨äº lambda ä½“å†…çš„è‡ªåŠ¨å˜é‡ï¼Œå¹¶ä»¥å¼•ç”¨æ•è·å½“å‰å¯¹è±¡ï¼Œ(è‹¥å­˜åœ¨), è¿™æ ·, åœ¨Lambdaè¡¨è¾¾å¼å†…éƒ¨å°±å¯ä»¥è®¿é—®å¹¶ä¿®æ”¹å¤–éƒ¨ä½œç”¨åŸŸä¸­çš„å˜é‡ã€‚

â‘£ `[=]` ä»¥å¤åˆ¶æ•è·æ‰€æœ‰ç”¨äº lambda ä½“å†…çš„è‡ªåŠ¨å˜é‡ï¼Œå¹¶ä»¥å¼•ç”¨æ•è·å½“å‰å¯¹è±¡ï¼Œ(è‹¥å­˜åœ¨), è¿™æ ·, åœ¨Lambdaè¡¨è¾¾å¼å†…éƒ¨å°±å¯ä»¥è®¿é—®å¤–éƒ¨ä½œç”¨åŸŸä¸­çš„å˜é‡çš„å‰¯æœ¬ã€‚

â‘¤ `[]` ä¸æ•è·(å¤§éƒ¨åˆ†æƒ…å†µä¸‹ä¸æ•è·å°±å¯ä»¥) è¡¨ç¤ºä¸æ•è·ä»»ä½•å¤–éƒ¨å˜é‡ã€‚è¿™ç§æƒ…å†µä¸‹ï¼ŒLambdaè¡¨è¾¾å¼åªèƒ½ä½¿ç”¨è‡ªå·±çš„å†…éƒ¨å˜é‡ï¼Œæ— æ³•è®¿é—®å¤–éƒ¨ä½œç”¨åŸŸä¸­çš„å˜é‡ã€‚

â‘¥ `[*this]`: [[C++17] Lambdaè¡¨è¾¾å¼æ•è· *this](../019-Lambdaè¡¨è¾¾å¼æ•è·ç±»æˆå‘˜å˜é‡çš„å‰¯æœ¬/index.md)

### æœ€ç®€å•çš„Lambdaè¡¨è¾¾å¼
åœ¨lambdaå‡½æ•°å®šä¹‰ä¸­ï¼Œ`å‚æ•°åˆ—è¡¨`å’Œ`è¿”å›å€¼ç±»å‹`éƒ½æ˜¯`å¯é€‰`éƒ¨åˆ†ï¼Œè€Œ`æ•æ‰åˆ—è¡¨`å’Œ`å‡½æ•°ä½“`å¯ä»¥ä¸º**ç©º**ã€‚

C++11ä¸­æœ€ç®€å•çš„lambdaå‡½æ•°ä¸º

```C++
[]{};
```

å½“ç„¶ä½ ä¹Ÿå¯ä»¥å†™ç‚¹åºŸè¯(ä¸Šä¸‹æ˜¯ç­‰ä»·çš„).

```C++
[](void) -> void {return; };
```

### ä»£ç ç¤ºä¾‹

```C++
#include<iostream>
using namespace std;

void (*FP)(); // å‡½æ•°æŒ‡é’ˆ

int main()
{
    // æœ€ç®€å•çš„lambdaè¡¨è¾¾å¼, è¯¥lambdaè¡¨è¾¾å¼æ²¡æœ‰ä»»ä½•æ„ä¹‰
    [] {};

    // çœç•¥å‚æ•°åˆ—è¡¨å’Œè¿”å›å€¼ç±»å‹ï¼Œè¿”å›å€¼ç±»å‹ç”±ç¼–è¯‘å™¨æ¨å¯¼ä¸ºint
    int num1 = 3, num2 = 4;
    // çœç•¥äº†è¿”å›å€¼ç±»å‹ï¼Œæ— è¿”å›å€¼ç±»å‹
    auto fun1 = [&num1, &num2](int num3) {num2 = num1 + num3; };
    fun1(100);
    cout << num1 << " " << num2 << endl;

    // æ•æ‰åˆ—è¡¨å¯ä»¥æ˜¯lambdaè¡¨è¾¾å¼
    auto fun = [fun1] {cout << "great" << endl; };
    fun();

    // å„éƒ¨åˆ†éƒ½å¾ˆå®Œå–„çš„lambdaå‡½æ•°
    auto fun2 = [&, &num2](int num3) -> int {return num2 += num1 + num3; };
    cout << fun2(10) << endl;
  
	// å¤åˆ¶æ•æ‰x
    int x = 10;
    auto add_x = [x](int a) mutable { x *= 2; return a + x; };
    cout << add_x(10) << endl;

    // ç¼–è¯‘å¤±è´¥--->æç¤ºæ‰¾ä¸åˆ°operator=() (æ²¡æœ‰ä¸ä¹‹åŒ¹é…çš„è¿ç®—ç¬¦)
    //auto fun3 = [&num1,&num2](int num3) {num2 = num1 + num3;};
    //fun1 = fun3;

    // å…è®¸ä½¿ç”¨ä¸€ä¸ªlambdaè¡¨è¾¾å¼æ‹·è´æ„é€ ä¸€ä¸ªæ–°çš„å‰¯æœ¬
    auto fun3(fun);
    fun();

    // å¯ä»¥å°†lambdaè¡¨è¾¾å¼èµ‹å€¼ç»™ç›¸åŒç±»å‹çš„å‡½æ•°æŒ‡é’ˆ
    auto f2 = [] {};
    FP = f2;
    FP();

    return 0;
}

```

## å‡½æ•°å¯¹è±¡ä¸lambdaè¡¨è¾¾å¼
å‡½æ•°å¯¹è±¡ï¼Œåˆç§°ä¸ºä»¿å‡½æ•°ï¼Œå³å¯ä»¥æƒ³å‡½æ•°ä¸€æ ·ä½¿ç”¨çš„å¯¹è±¡ï¼Œå°±æ˜¯åœ¨ç±»ä¸­é‡è½½äº†operator()è¿ç®—ç¬¦çš„ç±»å¯¹è±¡

ä»ä½¿ç”¨æ–¹å¼ä¸Šæ¥çœ‹ï¼Œå‡½æ•°å¯¹è±¡ä¸lambdaè¡¨è¾¾å¼å®Œå…¨ä¸€æ ·:

```C++
#include <iostream>
using namespace std;

class Rate {
public:
    Rate(double rate) : _rate(rate) {}
    double operator()(double money, int year) {
        return money * _rate * year;
    }
private:
    double _rate;
};

int main() {
    // å‡½æ•°å¯¹è±¡
    double rate = 0.6;
    Rate r1(rate);
    double rd = r1(20000, 2);
    cout << rd << endl;

    // lambda
    auto r2 = [=](double monty, int year) -> double { return monty * rate * year; };
    double rd2 = r2(20000, 2);
    cout << rd2 << endl;

    return 0;
}
```

åœ¨`C++98`ä¸­ï¼Œå¯¹ä¸€ä¸ªæ•°æ®é›†åˆä¸­çš„å…ƒç´ è¿›è¡Œæ’åºï¼Œå¯ä»¥ä½¿ç”¨sortæ–¹æ³•:


```C++
#include <iostream>
#include <algorithm>
#include <functional>
using namespace std;

int main()
{
    int array[] = { 3,6,9,5,4,7,0,8,2,1 };
    // é»˜è®¤æŒ‰ç…§å°äºæ¯”è¾ƒï¼Œæ’å‡ºæ¥ç»“æœæ˜¯å‡åº
    sort(array, array + sizeof(array) / sizeof(array[0]));
    // å¦‚æœéœ€è¦é™åºï¼Œéœ€è¦æ”¹å˜å…ƒç´ çš„æ¯”è¾ƒè§„åˆ™
    sort(array, array + sizeof(array) / sizeof(array[0]), greater<int>());
    return 0;
}
```

å¦‚æœå¾…æ’åºå…ƒç´ ä¸ºè‡ªå®šä¹‰ç±»å‹ï¼Œéœ€è¦ç”¨æˆ·å®šä¹‰æ’åºæ—¶çš„æ¯”è¾ƒè§„åˆ™:

```C++
#include <iostream>
#include <algorithm>
#include <functional>
using namespace std;

struct Goods {
    string name;
    double price;
};

struct Compare {
    bool operator()(const Goods& gl, const Goods& gr) {
        return gl.price <= gr.price;
    }
};

int main() {
    Goods gds[] = { 
        { "è‹¹æœ", 5.1 }, 
        { "æ©™å­", 9.2 }, 
        { "é¦™è•‰", 3.6 }, 
        { "è è", 9.6 } 
    };
    
    sort(gds, gds + sizeof(gds) / sizeof(gds[0]), Compare());
    
    for (int i = 0; i < 4; i++) {
        cout << gds[i].name << " " << gds[i].price << endl;
    }
    
    return 0;
}
```

æœ‰äº† Lambdaè¡¨è¾¾å¼ï¼Œä»£ç å°±å¯ä»¥å†™æˆå¦‚ä¸‹:

```C++
#include <iostream>
#include <algorithm>
#include <functional>
using namespace std;

struct Goods {
    string name;
    double price;
};

int main() {
    Goods gds[] = { 
        { "è‹¹æœ", 5.1 }, 
        { "æ©™å­", 9.2 }, 
        { "é¦™è•‰", 3.6 }, 
        { "è è", 9.6 } 
    };
    
    sort(gds, gds + sizeof(gds) / sizeof(gds[0]), [](const Goods& l, const Goods& r) -> bool {
        return l.price < r.price;
    });
    
    for (int i = 0; i < 4; i++) {
        cout << gds[i].name << " " << gds[i].price << endl;
    }
    
    return 0;
}
```

## Lambdaè¡¨è¾¾å¼çš„æœ¬è´¨
> æœ¬å†…å®¹æ˜¯æ‹“å±•, æ­£å·§æƒ³åˆ°äº†, ä½†æ˜¯ç½‘ç»œä¸Šå¥½åƒæ²¡æœ‰ä»€ä¹ˆå›ç­”. æ‰€ä»¥`è‡ªå·±å®éªŒ + GPT-3.5`äº†, ä¸èƒ½ä¿è¯å®Œå…¨æ­£ç¡®å’Œæœ‰å¯ç§»æ¤æ€§(ç¼–è¯‘å™¨VS2022 C++14)

### Lambda æ˜¯åŒ¿åå‡½æ•° è¿˜æ˜¯ä¸€ä¸ªä»¿å‡½æ•°?

![PRINTSCREEN_20231228_171018.png ##w800##](./PRINTSCREEN_20231228_171018.png)

> æœ¬æ¥è¿˜è§‰å¾—å®ƒæ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆ, ç„¶åæŒ‡å‘äº†ä¸€ä¸ªåŒ¿åçš„å‡½æ•°åœ°å€
>
> ä¸è¿‡ä¹Ÿæ˜¾ç„¶, è¿™æ ·æ˜¯ä¸è¡Œçš„...


> ##purple##
> ğŸŸ£ <span style="color:yellow">åˆ°å¤´æ¥, å°±æ˜¯ä¸€ä¸ªç¼–è¯‘å™¨å¸®æˆ‘ä»¬å®ç°çš„ä¸€ä¸ª`ä»¿å‡½æ•°`å•Š, ç›¸å½“äºå¤§å¤§æ»´è¯­æ³•ç³–...</span>
>
> <p align="center" style="color:red"><b>é‚£ä¹ˆæ—¢ç„¶æ˜¯ç±», å°±åŠ¡å¿…ä¼šæ‰§è¡Œæ„é€ å‡½æ•°ä¸ææ„å‡½æ•°!</b></p>


### Lambda å¦‚ä½•æ•è·å˜é‡?
ç­”: é€šè¿‡`æ„é€ å‡½æ•°`ä¼šæŠŠéœ€è¦çš„å˜é‡, å˜ä¸º`åŒ¿åç±»`çš„`æˆå‘˜å˜é‡`

$æ•è·åˆ—è¡¨ä¸º[=], æ„é€ å‡½æ•°ä¼ å‚æ˜¯é‡‡ç”¨ æ‹·è´èµ‹å€¼çš„å½¢å¼$

æ‰€ä»¥ä¼šäº§ç”Ÿä»¥ä¸‹é—®é¢˜: (å½“Lambdaè¡¨è¾¾å¼å£°æ˜å, å³ä¾¿åŸæœ¬å…³è”çš„å€¼å˜åŒ–äº†, æˆå‘˜å˜é‡ä¹Ÿä¸ä¼šæ”¹å˜!)

```C++
int num1 = 10;
auto lbd = [=]() {cout << num1 << endl; };
num1 = 2
lbd();		// 10
num1 = 20;
lbd();		// 10
```

åŒºåˆ«:
```C++
int num1 = 10;
auto lbd = [&]() {cout << num1 << endl; };
num1 = 2
lbd();		// 2
num1 = 20;
lbd()		// 20
```

> ##purple##
> ğŸŸ£ <span style="color:yellow">æ‰€ä»¥ä¸ç”¨æ‹…å¿ƒå¤šæ¬¡ä½¿ç”¨Lambdè¡¨è¾¾å¼ä¼šå¤šæ¬¡ä½¿ç”¨æ„é€ å‡½æ•°ä¸ææ„å‡½æ•°<sup>[2]</sup>.</span>

## æ³¨è§£
### [1]

```C++
int n = 10;
[=](){
    ++n; // æŠ¥é”™
		 // å¯ä»¥è§†ä½œ å®é™…ä¸Šä¼ å…¥äº† const int n;
}();
cout << n << endl; // 10
```

```C++
int n = 10;
[=]() mutable {
    ++n; // å¯ä»¥è¿›è¡Œ
		 // ä¸€ä»½å®Œå…¨çš„ n çš„æ‹·è´, næ˜¯åŒåçš„å˜é‡, ä½œç”¨åŸŸåœ¨è¯¥åŒ¿åå‡½æ•°å†…, ä¸ä¼šå½±å“å¤–éƒ¨
}();
cout << n << endl; // 10
```

å‚è€ƒæ–‡çŒ®: [lambdaè¡¨è¾¾å¼ä¸­çš„mutable](https://blog.csdn.net/Dasis/article/details/121370885#:~:text=C%2B%2B%E6%96%B0%E7%89%B9%E6%80%A711,%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%80%BC%EF%BC%89)

å¦‚æœä½ ç†Ÿæ‚‰`ä»¿å‡½æ•°`, é‚£ä¹ˆå°±å’Œä¸‹é¢ç±»ä¼¼(åªæ˜¯å¯¹) `mutable` è®¨è®º!

```C++
static class my_Class
{
public:
	// [=]() {}; çš„æƒ…å†µ
	void operator() (int n) const
	{
		++n; // æŠ¥é”™çš„
	}
};
```
```C++
static class my_Class
{
public:
	// [=]() mutable {}; çš„æƒ…å†µ
	void operator() (int n)
	{
		++n;
	}
};
```

åŒºåˆ«: [C++ä¸­çš„mutableå…³é”®å­—](https://www.cnblogs.com/yongdaimi/p/9565996.html)

### [2]

> æ­¤å¤„å±•ç¤ºLambdaè¡¨è¾¾å¼å…¶è¢«åº•å±‚æ›¿æ¢åçš„ç»“æœ.

è€ƒè™‘ä»¥ä¸‹ä»£ç :
```C++
void text(void)
{
    int num1 = 10;
    auto lbd = [=]() {cout << num1 << endl; };
    num1 = 2
    lbd();		// 10
    num1 = 20;
    lbd();		// 10
}
```

æœ‰:<sup>[3]{æ­¤å¤„å‡è®¾ç¼–è¯‘å™¨å°†å…¶è½¬åŒ–ä¸º`å±€éƒ¨ç±»`}</sup>

```C++
void text(void)
{
	class Lambda
	{
	public:
		Lambda(int num1)
		{
			this->num1 = num1;
		}

		void operator() (void) const
		{
			cout << this->num1 << endl;
		}

	private:
		int num1;
	};

	int num1 = 10;
	Lambda lambda(num1);
	auto lbd = lambda;
	num1 = 2;
	lbd();
	num1 = 20;
	lbd();
}
```

### [3]

ç”±äºä»¥ä¸‹ä»£ç æ˜¯åˆæ³•çš„, æ‰€ä»¥æˆ‘ä»¬ä¼¼ä¹æ— æ³•åˆ¤æ–­å®ƒæ˜¯å¦æ˜¯å±€éƒ¨ç±»

// åŸæœ¬æ˜¯ä¸ºäº†é˜²æ­¢ Lambda è¡¨è¾¾å¼ä½œä¸ºå‡½æ•°è¿”å›å€¼é€ƒç¦»`å±€éƒ¨ç±»çš„ä½œç”¨åŸŸ`.

// ä½†æ˜¯æ²¡æƒ³åˆ°, è¿™ä¸ªæ˜¯åˆæ³•çš„...

```C++
auto new_cpp11_004(void)
{
    class Text
    {
    public:
        Text(int a)
        {
            this->a = a;
        }
    public:
        int a;
    };
	
    return Text(123);
}

int main()
{
	auto x = new_cpp11_004();
    cout << x.a << endl;	// 123
	return 0;
}
```
