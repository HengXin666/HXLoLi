# 学习图形学从 OpenGL 学起

> [!TIP]
> 本课内容, 基本上是概念复制粘贴, 代码自己实验, += 体会, == 笔记

## ゼロ、前言介绍
### 0.1 原作者

本笔记学习自 [【公开课】现代OpenGL保姆级课程, 从零开始打造3D游戏引擎(第一集, 持续更新中)](https://www.bilibili.com/video/BV1Na4y1c7tP/), 仅为个人笔记~

```bilibili ##BV1Na4y1c7tP##
BV1Na4y1c7tP
```

含金量:

![含金量 ##w700##](HX_2025-06-04_22-32-59.png)

优点(其中一点):

![全中文 ##w700##](HX_2025-06-04_22-55-28.png)

![为人民服务 ##w700##](HX_2025-06-04_22-57-07.png)

### 0.2 课程参考资源

- Learn OpenGL 网站(非常适合初学者):  https://learnopengl.com
- 红宝书: 《OpenGL Programming Guide》或称《OpenGL编程指南》
- 蓝宝书: 《OpenGL Superbible: Comprehensive Tutorial and Reference》
- 着色器: 《OpenGL 4.0 Shading Language Cookbook》
- GPU Gems 系列: https://developer.nvidia.com/gpugems/gpugems3/foreword
- OpenGL 官方主页: http://www.opengl.org/
- Khronos(OpenGL 的维护团队)主页: http://www.khronos.org/
- GAMES104(不能尬黑, 还是很精彩的课程): https://games104.boomingtech.com/

## 一、什么是渲染
### 1.1 计算机图形学

> 计算机图形学是研究计算机在硬件和软件的帮助下创建计算机图形的科学学科, 是计算机科学的一个分支领域, 主要关注数字合成与操作视觉的图形内容。虽然这个词通常被认为是指三维图形, 事实上同时包括了二维图形以及影像处理。
>
> - 我们的课程将会从实时渲染开始入手

![计算机图形学 ##W700##](HX_2025-06-04_23-05-55.png)

### 1.2 什么是渲染

> **渲染(rendering)** 是指将计算机图形学中的场景描述, 以图像形式呈现出来的过程。在计算机图形学中, 场景是由一些基本图形元素(如点、线、面)组成的, 这些元素可以通过计算机程序进行操作和变换, 形成各种各样的场景。渲染的过程就是将这些场景元素进行处理, 生成最终的图像。渲染还可以分为实时渲染和离线渲染两种方式, **实时渲染**用于实时交互式应用程序(如游戏), **离线渲染**用于制作影视动画等非实时应用。

简单来说就是根据图形的 **三维的模型数据**, 生成 **二维的画面**。

### 1.3 一切皆三角形

#### 1.3.1 二维

渲染的任务是绘制图形, 先别提绘制, 首当其冲的问题是: 如何表示图形?

> $\text{\color{#ff33ff}{所有的复杂图形, 都可以由三角形构成。}}$

![正方形to三角形 ##w500##](HX_2025-06-04_23-10-36.png)

![圆to三角形 ##w500##](HX_2025-06-04_23-13-54.png)

> (圆也是可以逼近的 (积分思想))

计算机图形学经典名言: **看起来是对的, 那他就是对的。**

毕竟计算机图形学渲染出来的东西是给人看的, 不论用什么方法, 能够让人信服, 就是最大的胜利。即使用多边形近似.

![圆to三角形 ##w500##](HX_2025-06-04_23-15-33.png)

#### 1.3.2 三维

如果是三维空间中的实心物体呢? 因为我们屏幕实际上是二维的, 因此我们只需要表示表面就可以了!

计算机图形学: **画皮**

![三维球to三角形 ##w700##](HX_2025-06-04_23-20-49.png)

### 1.4 高模 vs 低模

当然, 为了保证高质量, 需要三角形足够密集, 让人看不出这是多边形拼凑出来的, 让人信以为真这是一条光滑的曲面。因此有了高模和低模的区分。

一般建模师都会先在低模上进行操作, 完成后再通过 **网格细分算法(subdivision)** 把低模自动转换为平滑的高模, 然后由雕刻师在高模上完成细节刻画。

![高低模 ##w600##](HX_2025-06-04_23-22-29.png)

### 1.5 渲染的本质
#### 1.5.1 如何用一系列坐标表示一个方块? 

> 顶点坐标+顶点之间的连接关系

![表示方块 ##w600##](HX_2025-06-04_23-28-08.png)

#### 1.5.2 渲染的本质

你要输入的是一张纸, 上面写着字:

> (0, 0)(0, 1)(1, 0)

这就是三维模型数据。

你把写着这 6 个神秘数字的纸条塞进了一个叫“显卡”的机器里。

“显卡”缓缓(不到 1/60 秒)打印出一张字符画: 

```text
1 0 0 0 0 0
1 1 0 0 0 0
1 1 1 0 0 0
1 1 1 1 0 0
1 1 1 1 1 0
1 1 1 1 1 1
```

这就是二维画面。

#### 1.5.3 人们对渲染的错误理解

在B站搜索“什么是渲染”会看到很多这样的封面。似乎渲染就是给灰色的模型“上色”?

![大错特错 ##w500##](HX_2025-06-04_23-35-53.png)

> 请忽略左下角

实际上, 即使是左边的图像, 也是渲染过的结果, 只不过是低配版的渲染。

渲染并不是给灰色的模型“上色”, 模型本身不存在灰色不灰色, 灰色的是显示在屏幕上的模型的二维投影, <b style="color: gold">真正的模型是内存中的一堆三维顶点坐标, 渲染是把这一堆三维坐标根据指定的视角、灯光、材质等信息, 投影成二维图像</b>, 即使你指定的材质刚好是灰色的。

![什么是渲染 ##w600##](HX_2025-06-04_23-32-51.png)

你在 Blender 建模窗口里看到的, 之所以是灰模, 不是因为没有渲染, 而是因为他为了让你能为了让你能快速预览模型的大致形状而不用风扇狂转, 采用了**最低配的渲染模式**。

![各种渲染 ##w700##](HX_2025-06-04_23-41-11.png)

### 1.6 实时渲染 vs 离线渲染

渲染又可以分为两派人, **实时渲染(real-time rendering)** 和 **离线渲染(offline rendering)**。

**实时渲染** 要求在 1/60 秒内完成整个画面的绘制, 通常游戏行业会有这样的要求。

如果不能在 1/60 秒内完成, 就会影响游戏体验, 即使画面再好, 也不会有人能忍受 PPT。

而 **离线渲染** 不注重画面渲染的实时性和速度, 但非常重视画面的质量, 通常是电影行业。

因为电影只需动画公司渲染完成品后, 在影院播放即可, 渲染过程的快慢不影响实际播放。

两个领域看似各玩各的, 其实之间也有许多相互交叉, 相互借鉴的地方。

实时渲染一般会使用`光栅化+GPU加速`。

而离线渲染会选择更慢但更准确的`路径追踪+蒙特卡罗积分`。

也有例外的情况, 例如 NVIDIA 实时光线追踪和使用 Unreal 游戏引擎做动画电影的小作坊。

本课程主要介绍的是**实时渲染技术**。

#### 1.6.1 离线渲染 - 康奈尔箱

![离线渲染 ##w700##](HX_2025-06-04_23-45-21.png)

路径追踪 - 照片级真实感, 但是代价呢?

> 相传迪士尼的《疯狂动物城》, 需要 10000 个“核时”才能渲染出一帧。什么概念呢? 就是说单核心 CPU, 需要工作 10000 小时, 才能渲染出你看到的一帧, 如果是 100 核 CPU 则只要 100 小时就能出一帧。而电影一般每秒有 24 帧, 考虑到整部电影有一小时多...

#### 1.6.2 第二条道路 - 光栅化

有没有比路径追踪更高效的渲染方案呢? 那就是 `光栅化(rasterization)`。

他使用遍历的方法, 绘制每个三角形时都检测出中心点包含在三角形内部的像素点, 并填充上颜色, 如下图所示。

![光栅化 ##w500##](HX_2025-06-04_23-52-03.png)

三角形的**光栅化**, 比路径追踪的**射线与三角形求交**要高效得多, 且通常不需要多次采样。

> [!TIP]
> **光栅化是一个可以并行的算法**, 可以在 CPU 上编写软件代码实现, 但效率较低。考虑到光栅化是绘制图形最高效的算法, 人们发明了 GPU, 把光栅化做成硬件电路, 不必软件编程, 软件只需要向 GPU 发出指令, 就可以调用 GPU 的光栅化电路, 并绘制图像。

#### 1.6.3 着色: 使物体明暗分明

如果只是光栅化, 那么我们看到的图形就都是黑白的二值图像, 根本不会有立体感。

为了让图形看起来立体, 真实, 我们需要像离线渲染的路径追踪一样, 计算物体的光照情况, 给不同的位置上不同的颜色, 这个操作称为 `着色(shade)`。

确定这个点要绘制后, 就会调用所谓的 `着色器(shader)`。着色器会根据三角形每一个像素点的位置, 结合物体材质反射率、颜色、该点三维坐标与光源、摄像机的角度位置关系等信息, 在相应的像素点填充上符合`光学规律`的颜色, 区分出亮部暗部, 让他看起来立体。

![着色...略 ##w700##](HX_2025-06-05_00-01-37.png)

### 1.7 CPU vs GPU

众所周知, CPU 适合处理一些通用任务, 而 GPU 则更适合处理需要大量计算能力的图形图像和视频任务。

#### 1.7.1 GPU 为实时渲染而生

![gpu为实时渲染而生](HX_2025-06-05_00-05-55.png)

#### 1.7.2 实时渲染 - 质量堪忧

硬件加速的光栅化虽然高效, 但由于光栅化只能计算光线的第一次反射, 实时渲染在全局光照方面令人堪忧, 为了实时性不得不牺牲了渲染结果的准确性。

![使用光栅化渲染 ##w400##](HX_2025-06-05_00-07-29.png)

#### 1.7.3 实时渲染的进步

![实时渲染的进步 ##w700##](HX_2025-06-05_00-08-37.png)

### 1.8 从 GPU 到 GPGPU

> 后来, 着色器能够并行运算的特点被发掘, 用于图形渲染以外的通用并行计算工具, 后来OpenGL 4.3 也推出了更适合通用计算任务的“计算着色器(compute shader)”, 这种着色器的语法限制更加宽松, 首次加入了对 block 和 thread 的控制能力, 用途上显然早已和“着色”没什么关联了, 只有并行的优点被保留, GPU 逐渐演变成通用的并行计算硬件。
>
> GPU 强大的并行运算能力和延迟隐藏能力, 对于需要同时处理大量数据的应用场景, 比如物理仿真、音视频处理和人工智能等, GPU 也能发挥更强大的计算能力, 大幅提高吞吐量。

这种具备通用并行计算能力的 GPU 也被称作 **GPGPU(General Purposed GPU)**。

#### 1.8.1 GPU 也开始支持光线追踪

> - 屏幕空间反射(SSR)和屏幕空间全局光照(SSGI)虽然高效, 但是只能在二维的已经渲染完毕的屏幕上去做光线追踪。
> 
> - 随着硬件的不断加速升级, 光线追踪变得有希望在 1/60 秒内完成。为了让 1080p 分辨率下的光线追踪变成实时(小于 1/60 秒), 后来部分显卡厂商支持起了硬件加速的光线追踪, 称为实时光线追踪(real-time ray-tracing, RTX), 解决了之前 CPU 软件光线追踪太慢, GPU 软件光线追踪差一点就实时的痛点。
> 
> - 就像当年光栅化差一点就能实时了, NVIDIA 发明 GPU 用硬件加速**光栅化**一样, 他们现在又发明了硬件加速的**光线追踪**, 同样集成到了 GPU 里, 于是现在的淫威大 GPU 由光线追踪+光栅化+流处理器三个模块组成, 后来还引入了伺候 DLSS 和 AI 降噪的张量计算模块。
> 
> - 要注意并不是说 RTX 等于光追, RTX 只是“硬件加速”的光追。正如硬件加速的光栅化一样。我们用 OpenGL 计算着色器, CUDA, OpenCL, 一样可以在任何没有硬件光线追踪功能的 GPU 上进行软件光线追踪, 只不过会比较慢, 难以达到实时而已。
>
> - 虽然硬件光追只加速了 2.4 倍左右, 但是由于实时渲染的特殊性, **同等画质下提升 2.4 倍速度, 就等于同等 1/60 秒的情况下提升了 2.4 倍画质**, 帧率不降提升画质, 是质的飞跃, 这也是为什么在实时领域硬件加速(不论是光栅化还是光线追踪)都显得格外重要。

#### 1.8.2 最终效果比较

![最终效果比较 ##w700##](HX_2025-06-05_00-12-21.png)

### 1.9 GPU 渲染一个物体所需的全部流程一览

![GPU 渲染一个物体所需的全部流程一览 ##w700##](HX_2025-06-05_00-13-27.png)

### 1.10 题外话: GPU 也可以渲染二维图形

> GPU(图形处理器)在渲染三维图形方面几乎是不可替代的, 但是它们也可以用于渲染二维图形(包括文字和图标), 例如我们平时看到的图形用户界面(GUI)、浏览器(Web)等, 都有 GPU 的功劳。GPU 的渲染能力非常高, 它可以同时渲染许多图形, 还可以使图像处理速度(例如拍照后加美颜滤镜)更快。GPU 可以处理的图形元素包括点、线、矩形、多边形、文本等。它还可以使用多种不同的技术和效果, 如图形加速、抗锯齿和透明度, 以提高图形界面的质量和性能。所以, GPU的用途不仅限于游戏和 3D 应用程序, 它们也可以帮助我们更快更好地渲染的图形用户界面。包括 2D 平面游戏的精灵(Sprite)绘制, 也离不开 GPU 忙碌的身影。

## 二、初识 OpenGL

> @todo