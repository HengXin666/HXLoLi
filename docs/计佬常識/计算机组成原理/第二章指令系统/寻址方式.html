<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-计佬常識/计算机组成原理/第二章指令系统/寻址方式/index" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">寻址方式 | HXLoLi</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://HengXin666.github.io/HXLoLi/img/logo.png"><meta data-rh="true" name="twitter:image" content="https://HengXin666.github.io/HXLoLi/img/logo.png"><meta data-rh="true" property="og:url" content="https://HengXin666.github.io/HXLoLi/docs/计佬常識/计算机组成原理/第二章指令系统/寻址方式"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="寻址方式 | HXLoLi"><meta data-rh="true" name="description" content="MIPS架构设计时将所有指令定为32位长(即4字节)，这简化了硬件设计，使得处理器的解码和执行阶段更加高效且统一。然而，在实际编程中，有时需要使用大于16位的常量或者访问32位地址空间中的数据，这时就需要采用特殊的编码方式来加载或存储32位的常数值以及使用完整的32位地址。"><meta data-rh="true" property="og:description" content="MIPS架构设计时将所有指令定为32位长(即4字节)，这简化了硬件设计，使得处理器的解码和执行阶段更加高效且统一。然而，在实际编程中，有时需要使用大于16位的常量或者访问32位地址空间中的数据，这时就需要采用特殊的编码方式来加载或存储32位的常数值以及使用完整的32位地址。"><link data-rh="true" rel="icon" href="/HXLoLi/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://HengXin666.github.io/HXLoLi/docs/计佬常識/计算机组成原理/第二章指令系统/寻址方式"><link data-rh="true" rel="alternate" href="https://HengXin666.github.io/HXLoLi/docs/计佬常識/计算机组成原理/第二章指令系统/寻址方式" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://HengXin666.github.io/HXLoLi/docs/计佬常識/计算机组成原理/第二章指令系统/寻址方式" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/HXLoLi/blog/rss.xml" title="HXLoLi RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/HXLoLi/blog/atom.xml" title="HXLoLi Atom Feed"><link rel="stylesheet" href="/HXLoLi/assets/css/styles.5c012ea4.css">
<script src="/HXLoLi/assets/js/runtime~main.bc367ab0.js" defer="defer"></script>
<script src="/HXLoLi/assets/js/main.b26f36f1.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/HXLoLi/img/logo.png"><link rel="preload" as="image" href="/HXLoLi/default-icons/default_folder.svg"><link rel="preload" as="image" href="/HXLoLi//default-icons/alipay.svg"><link rel="preload" as="image" href="/HXLoLi//img/alipay_qr_code.png"><link rel="preload" as="image" href="/HXLoLi//default-icons/wechat.svg"><link rel="preload" as="image" href="/HXLoLi//img/wechat_qr_code.png"><link rel="preload" as="image" href="/HXLoLi//default-icons/cc.svg"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/HXLoLi/"><div class="navbar__logo"><img src="/HXLoLi/img/logo.png" alt="HXLoLi Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/HXLoLi/img/logo.png" alt="HXLoLi Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">HXLoLi</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/HXLoLi/docs/关于">笔记</a><a class="navbar__item navbar__link" href="/HXLoLi/blog">博客</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">更多</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/HXLoLi/blog/archive">归档</a></li><li><a href="https://github.com/HengXin666/HXLoLi" target="_blank" rel="noopener noreferrer" class="dropdown__link">GitHub<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="搜索" aria-label="Search" class="navbar__search-input searchInput_YFbd" value=""><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd sidebarWithHideableNavbar_wUlq"><a tabindex="-1" class="sidebarLogo_isFc" href="/HXLoLi/"><img src="/HXLoLi/img/logo.png" alt="HXLoLi Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/HXLoLi/img/logo.png" alt="HXLoLi Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"><b>HXLoLi</b></a><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/HXLoLi/docs/关于">关于</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" style="font-size:14px" href="/HXLoLi/docs/计佬常識/数据结构与算法/【algorithm】目録"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>计佬常識</div></div></div></a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/数据结构与算法/【algorithm】目録"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>数据结构与算法</div></div><div style="flex:1"><span style="margin-right:8px;padding-left:5px;padding-right:5px;font-size:12px;border-radius:6px;color:#ffffff;background-color:#990099;box-shadow:2px 2px 4px 1px rgba(255, 255, 255, 0.5);white-space:nowrap">数据结构与算法</span></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/设计模式/相关面试题"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>设计模式</div></div><div style="flex:1"><span style="margin-right:8px;padding-left:5px;padding-right:5px;font-size:12px;border-radius:6px;color:#ffffff;background-color:#990099;box-shadow:2px 2px 4px 1px rgba(255, 255, 255, 0.5);white-space:nowrap">设计模式</span><span style="margin-right:8px;padding-left:5px;padding-right:5px;font-size:12px;border-radius:6px;color:#ffffff;background-color:#990099;box-shadow:2px 2px 4px 1px rgba(255, 255, 255, 0.5);white-space:nowrap">架构</span></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机网络/一、计算机网络基础"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>计算机网络</div></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/操作系统/とあるOSのインデックス"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>操作系统</div></div><div style="flex:1"><span style="margin-right:8px;padding-left:5px;padding-right:5px;font-size:12px;border-radius:6px;color:#ffffff;background-color:#990099;box-shadow:2px 2px 4px 1px rgba(255, 255, 255, 0.5);white-space:nowrap">OS</span></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/【计组】目录"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>计算机组成原理</div></div><div style="flex:1"><span style="margin-right:8px;padding-left:5px;padding-right:5px;font-size:12px;border-radius:6px;color:#ffffff;background-color:#990099;box-shadow:2px 2px 4px 1px rgba(255, 255, 255, 0.5);white-space:nowrap">计算机组成与设计：硬件软件接口</span><span style="margin-right:8px;padding-left:5px;padding-right:5px;font-size:12px;border-radius:6px;color:#ffffff;background-color:#990099;box-shadow:2px 2px 4px 1px rgba(255, 255, 255, 0.5);white-space:nowrap">计算机组成与系统结构</span></div></div></a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/【计组】目录">【计组】目录</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第一章计算机概要与技术/计算机的分类及其特性"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>第一章计算机概要与技术</div></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第二章指令系统/计算机硬件的操作与操作数"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>第二章指令系统</div></div></div></a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第二章指令系统/计算机硬件的操作与操作数">计算机硬件的操作与操作数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第二章指令系统/有符号数和无符号数">有符号数和无符号数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第二章指令系统/逻辑操作">逻辑操作</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第二章指令系统/字符表示">字符表示</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第二章指令系统/指令格式">指令格式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第二章指令系统/寻址方式">寻址方式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第二章指令系统/并行、指令和同步">并行、指令和同步</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第三章计算机算术运算/定点数加减法"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>第三章计算机算术运算</div></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/MIPS核心子集及实现方式"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>第四章中央处理器</div></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第五章存储器/存储器技术"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>第五章存储器</div></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第六章IO设备/外部设备及总线"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>第六章IO设备</div></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第七章并行系统/并行系统"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>第七章并行系统</div></div></div></a></div></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/程序语言/C++/【C艹】目录大纲"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>程序语言</div></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/游戏引擎/虚幻引擎/【虚幻】目录"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>游戏引擎</div></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/DevOps与版本控制/Linux/【Linux】目录"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>DevOps与版本控制</div></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/中间件/Redis/【Redis】目录"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>中间件</div></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/数据库/MySQL数据库/とある「MySQL」の禁庫目録"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>数据库</div></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/刷题日志/做题记录"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>刷题日志</div></div><div style="flex:1"><span style="margin-right:8px;padding-left:5px;padding-right:5px;font-size:12px;border-radius:6px;color:#ffffff;background-color:#990099;box-shadow:2px 2px 4px 1px rgba(255, 255, 255, 0.5);white-space:nowrap">刷题</span><span style="margin-right:8px;padding-left:5px;padding-right:5px;font-size:12px;border-radius:6px;color:#ffffff;background-color:#990099;box-shadow:2px 2px 4px 1px rgba(255, 255, 255, 0.5);white-space:nowrap">就业</span><span style="margin-right:8px;padding-left:5px;padding-right:5px;font-size:12px;border-radius:6px;color:#ffffff;background-color:#990099;box-shadow:2px 2px 4px 1px rgba(255, 255, 255, 0.5);white-space:nowrap">竞赛</span></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/嵌入式/杂项/IC通信"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>嵌入式</div></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/Game/MineCraft/服务器/脚本"><div style="display:flex;flex-direction:column"><div style="flex:1;display:flex;align-items:center;flex-direction:row"><div><img src="/HXLoLi/default-icons/default_folder.svg" style="width:24px;margin-right:5px"></div><div>Game</div></div></div></a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_z5aJ"><div class="docItemContainer_c0TR"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/HXLoLi/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">计佬常識</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">计算机组成原理</span><meta itemprop="position" content="2"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">第二章指令系统</span><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">寻址方式</span><meta itemprop="position" content="4"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>寻址方式</h1></header>
<p>MIPS架构设计时将所有指令定为32位长(即4字节)，这简化了硬件设计，使得处理器的解码和执行阶段更加高效且统一。然而，在实际编程中，有时需要使用大于16位的常量或者访问32位地址空间中的数据，这时就需要采用特殊的编码方式来加载或存储32位的常数值以及使用完整的32位地址。</p>
<ul>
<li>
<p>寻址方式: 是寻址指令或者操作数的有效地址的方式</p>
</li>
<li>
<p>指令寻址: 去寻找下一条指令的地址</p>
</li>
</ul>
<p>具体不用太区分数据寻址还是指令寻址, 因为都是共通的, 只是取的东西不同然后起了个名字.</p>
<div style="margin-top:80px">
<hr>
</div>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="32位立即数">32位立即数<a href="#32位立即数" class="hash-link" aria-label="32位立即数的直接链接" title="32位立即数的直接链接">​</a></h2>
<p>在MIPS架构中，许多包含立即数字段的指令格式只预留了16位的空间来存放立即数。那如果使用32位的立即数该怎么办呢?</p>
<p>这时就需要采用<strong>特殊的编码方式</strong>来加载或存储32位的常数值以及使用完整的32位地址，需要采用两条指令来实现:</p>
<ol>
<li>
<p><strong>lui(Load Upper Immediate)</strong>: 将最高16位的立即数载入到目标寄存器的高16位，同时低16位清零。</p>
</li>
<li>
<p><strong>ori(OR Immediate)</strong> 或 <strong>addi(Add Immediate)</strong>: 将剩余的低16位立即数与前一步得到的结果进行 <strong>逻辑或(ori)</strong> 操作，或者 加法(addi, 如果目标寄存器之前已包含有效数据且希望累加的话)，从而合成出完整的32位立即数。</p>
</li>
</ol>
<p>例如，假设我们要将32位立即数<code>0x12345678</code>加载到寄存器<code>t0</code>中，我们需要这样操作:</p>
<div class="language-MIPS language-mips codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-mips codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">lui $t0, 0x1234      # 将高16位0x1234载入$t0, 低16位清零</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">ori $t0, $t0, 0x5678 # 将低16为0x5678与$t0进行逻辑或(|)操作</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">MIPS</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>总结: <strong>将32位立即数加载到目标寄存器中，以便后续的运算或存储</strong></p>
<blockquote>
<p>问: 32位立即数就耗费和int一样的内存</p>
<p>答: 在MIPS指令集中，立即数通常用于表示常数、地址偏移量等。当指令被执行时，立即数会直接被加载到指定的寄存器中，而不需要额外的内存访问。因此，虽然使用了32位的立即数，但它并不会占用和一个整数相同的内存空间，而是被编码在指令中，仅在指令执行时临时占用一些寄存器中的存储空间。</p>
</blockquote>
<div style="margin-top:80px">
<hr>
</div>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="寻址">寻址<a href="#寻址" class="hash-link" aria-label="寻址的直接链接" title="寻址的直接链接">​</a></h2>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="跳转-中的寻址方式-伪直接寻址">跳转 中的寻址方式: 伪直接寻址<a href="#跳转-中的寻址方式-伪直接寻址" class="hash-link" aria-label="跳转 中的寻址方式: 伪直接寻址的直接链接" title="跳转 中的寻址方式: 伪直接寻址的直接链接">​</a></h3>














<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-04-28_17-18-10.png ##w600##" src="/HXLoLi/assets/images/Clip_2024-04-28_17-18-10-8614db39983337b21070175dfe61e8f6.png" width="779" height="94" style="width:600px;border-radius:10px"></td></tr><tr><td style="text-align:center">J型指令格式的跳转指令</td></tr></tbody></table>
<p><strong>J型指令</strong>是一种专门用于<strong>无条件跳转</strong>(Jump)(例如<code>goto</code>)的指令格式。在MIPS指令集中，J型指令的具体格式如下:</p>
<ul>
<li>6位操作码: 用于指示这是一个J型跳转指令。</li>
<li>26位地址字段: 用于存储相对于当前 <strong>PC(程序计数器)</strong> 的偏移量。</li>
</ul>
<p>J型指令的寻址方式主要是变通的直接寻址(<strong>伪直接寻址</strong>):</p>
<ul>
<li>跳转地址由指 26 位字段和 PC 高位相连而成</li>
</ul>
<p>由于J型指令的总长度为32位，除去6位的操作码后，剩下的26位可以表示一个相对范围广泛的地址偏移量。这个偏移量是一个有符号的整数值，因此可以向前或向后跳转到一个相对较远的位置。这种设计简化了硬件实现，同时也足够灵活以支持大部分情况下的程序流程控制需求。在执行跳转指令时，处理器会将该偏移量与当前PC值相加，从而得到目标指令的实际地址，并更新PC值来执行跳转。</p>
<blockquote>
<p>PC 是 <strong>程序计数器(Program Counter)</strong> 的缩写。在计算机中，PC是一个专门的寄存器，用于存储当前正在执行的指令的地址，也就是下一条将要执行的指令所在的内存地址。</p>
<p>在指令的执行过程中，PC会不断地被更新，以指向下一条将要执行的指令的地址。例如，在顺序执行指令时，PC会按照顺序递增以指向下一条指令的地址。而在发生分支或跳转时，PC会根据分支或跳转指令中的条件或目标地址来更新自己的值。</p>
<p>在伪直接寻址中，J型指令的跳转地址由指令中的 26 位字段和当前PC的高位相连而成，用于确定跳转的目标地址。</p>
<p>当执行J型指令时，CPU会将指令中的26位地址字段左移两位(因为MIPS指令的地址是以字节为单位，而指令是以字为单位存储的，因此需要将地址左移两位以对齐字边界)，然后与当前PC的高位进行连接，形成一个完整的跳转地址。</p>
</blockquote>
<div style="margin-top:80px">
<hr>
</div>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="分支-中的寻址方式-pc相对寻址">分支 中的寻址方式: PC相对寻址<a href="#分支-中的寻址方式-pc相对寻址" class="hash-link" aria-label="分支 中的寻址方式: PC相对寻址的直接链接" title="分支 中的寻址方式: PC相对寻址的直接链接">​</a></h3>














<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-04-28_17-33-52.png ##w600##" src="/HXLoLi/assets/images/Clip_2024-04-28_17-33-52-d921c81a4d17666a023eb7a5bb202f89.png" width="774" height="102" style="width:600px;border-radius:10px"></td></tr><tr><td style="text-align:center">I 型指令格式的条件分支指令</td></tr></tbody></table>
<p>与无条件跳转指令不同，条件分支指令在跳转到目标地址之前会先比较两个操作数的值。如果满足比较条件，则执行跳转；否则，继续顺序执行下一条指令。具体来说:</p>
<ol>
<li>
<p>两个操作数: 这些操作数通常是从寄存器中获取的值，例如 rs(源寄存器1) 和 rt (源寄存器2)，用于比较它们之间的关系。</p>
</li>
<li>
<p>条件判断: 不同的条件分支指令对应着不同的条件判断，如<code>beq</code>检查两者是否相等，<code>bne</code>检查两者是否不相等，<code>blt</code>则检查第一个操作数是否小于第二个操作数。</p>
</li>
<li>
<p>分支地址: 如果满足特定条件，则程序计数器PC会被更新为指令中指定的目标地址，从而实现有条件地转移到新的指令序列继续执行。</p>
</li>
</ol>
<p>例如:</p>
<div class="language-MIPS language-mips codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-mips codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">beq $t0, $t1, LOOP # 如果 $t0 等于 $t1, 则跳转到 LOOP 标签处</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">MIPS</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>条件分支指令的寻址方式是: PC相对寻址</p>
<p><strong>PC相对寻址(PC-Relative Addressing)</strong> 是一种指令寻址方式，它使用当前 <strong>程序计数器(Program Counter, PC)</strong> 的值加上一个相对于当前指令地址的偏移量来确定下一条要执行的指令或数据的位置。</p>
<p>具体来说，在PC相对寻址中，指令包含了一个表示偏移量的字段。当CPU执行到含有PC相对寻址的跳转指令时，它会将当前PC值与该偏移量相加，得到的目标地址就是跳转的目的地。这种方式使得程序员可以编写出与加载地址无关的代码，增强了程序的可移植性，并且简化了硬件设计，因为不需要复杂的计算逻辑去生成绝对地址。</p>
<p>即: <code>目标地址 = PC + PC相对寻址跳转指令的偏移量</code></p>
<ul>
<li>优点: 简洁性和可预测性。</li>
<li>缺点: 限制了分支目标的范围，因为偏移量的大小是有限的。不利于代码的重定位和共享。(需要保证跳转的目标地址在偏移量范围内(这个是编译器做))</li>
</ul>
<blockquote>
<p>寻址附近的指令也是加速大概率事件的另外一个例子</p>
</blockquote>
<div style="margin-top:80px">
<hr>
</div>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="寻址模式的总结">寻址模式的总结<a href="#寻址模式的总结" class="hash-link" aria-label="寻址模式的总结的直接链接" title="寻址模式的总结的直接链接">​</a></h2>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="1-立即寻址">1. 立即寻址<a href="#1-立即寻址" class="hash-link" aria-label="1. 立即寻址的直接链接" title="1. 立即寻址的直接链接">​</a></h3>
<p><strong>立即寻址</strong>: 操作数直接包含在指令中，作为指令的一部分。这种情况下，操作数的值是一个立即数，即固定值。</p>
<blockquote>
<p>立即寻址模式通常用于加载立即数到寄存器中，或者用于算术和逻辑运算。</p>
</blockquote>
<p>MIPS 指令集并没有像某些其他指令集那样直接支持<code>MOV</code>指令，但可以通过其他方式实现寄存器到寄存器的数据移动。</p>
<div class="language-MIPS language-mips codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-mips codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">addi $t0, $zero, 16 # 立即寻找示例</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">MIPS</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>优点:</p>
<ul>
<li>速度快, 不用访问内存</li>
</ul>
<p>缺点:</p>
<ul>
<li>位数有限, 立即数的大小是有限的(但是可以使用32位立即数的思路来实现)</li>
</ul>
<div style="margin-top:80px">
<hr>
</div>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="2-直接寻址">2. 直接寻址<a href="#2-直接寻址" class="hash-link" aria-label="2. 直接寻址的直接链接" title="2. 直接寻址的直接链接">​</a></h3>
<p><strong>直接寻址</strong>: 指令中包含一个实际的内存地址，这个地址直接指向内存中的一个位置，从中读取或写入操作数，CPU直接使用这个地址从内存中读取操作数。在 MIPS 指令集中，直接寻址模式通常用于访问内存中的特定地址。在直接寻址中，指令中直接包含了要访问的内存地址。</p>
<p>表示为: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>A</mi><mo>=</mo><mi>A</mi><mtext> </mtext><mo stretchy="false">(</mo><mtext>寄存器编号</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">EA = A \ (寄存器编号)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">A</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord cjk_fallback">寄存器编号</span><span class="mclose">)</span></span></span></span></p>
<div class="language-MIPS language-mips codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-mips codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain"># lw 指令将从内存地址 0x1000 处加载一个字（32位数据）到寄存器 $t0 中</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">lw $t0, 0x1000 # 直接寻址示例</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">MIPS</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>直接寻址在 MIPS 指令集中是一种简单而直接的方式来访问内存中的特定位置。然而，由于其限制和可能的性能影响 (例如，直接寻址模式限制了指令中的地址值的范围，并且可能会导致代码的可移植性下降，因为程序的内存布局可能会因为不同的环境而改变。)，它通常只在需要直接访问特定内存地址时使用 (而在一般情况下，会更倾向于使用间接寻址模式或基于寄存器的寻址方式。)。所以其实并不常用。</p>
<p>优点:</p>
<ul>
<li>直接(简单)</li>
</ul>
<p>缺点:</p>
<ul>
<li>限制了寻址范围</li>
</ul>
<p>而在 MIPS 中一般也不使用直接寻址, 而是使用伪直接寻址</p>
<div style="margin-top:80px">
<hr>
</div>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="3-寄存器寻址">3. 寄存器寻址<a href="#3-寄存器寻址" class="hash-link" aria-label="3. 寄存器寻址的直接链接" title="3. 寄存器寻址的直接链接">​</a></h3>
<p><strong>寄存器寻址</strong>: 操作数存储在某个寄存器中。<strong>指令中通常包含一个寄存器标识符，处理器从该寄存器中读取或写入操作数</strong>。</p>
<p>寄存器寻址通常比内存寻址更快，因为寄存器位于 CPU 内部，访问它们不需要像访问内存那样经过复杂的内存子系统。</p>
<div class="language-MIPS language-mips codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-mips codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">add $t1, $t2, $t3 # 寄存器寻址示例</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">MIPS</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>寄存器寻址模式具有以下优点：</p>
<ol>
<li>
<p>快速: 寄存器位于CPU内部，访问它们<strong>不需要</strong>像<strong>访问内存</strong>那样经过复杂的内存子系统，因此寄存器寻址通常比内存寻址更快。</p>
</li>
<li>
<p>灵活: MIPS指令集中的大多数指令都可以接受来自寄存器或立即数的操作数，这使得寄存器寻址非常灵活，不仅限于算术和逻辑运算，还可以用于数据移动、比较、跳转等操作。</p>
</li>
<li>
<p>简单: 不需要进行地址计算</p>
</li>
</ol>
<p>缺点:</p>
<ul>
<li>个数有限; 造价昂贵</li>
</ul>
<div style="margin-top:80px">
<hr>
</div>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="4-主存间接寻址">4. 主存间接寻址<a href="#4-主存间接寻址" class="hash-link" aria-label="4. 主存间接寻址的直接链接" title="4. 主存间接寻址的直接链接">​</a></h3>
<p><strong>间接寻址</strong>: 指令中给出的地址码是存放操作数有效地址的主存单元地址。图所示的是单级间接寻址过程,还可有多重间接寻址。</p>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-04-28_18-55-57.png ##w400##" src="/HXLoLi/assets/images/Clip_2024-04-28_18-55-57-d320d956aa8aacaf60016de5b27c0464.png" width="438" height="257" style="width:400px;border-radius:10px"></td></tr></tbody></table>
<p>类似于C的<code>指针的指针</code></p>
<p>表示为: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">EA = (A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> <code>(x)</code>表示取地址<code>x</code>里面的数据</p>
<p>优点:</p>
<ul>
<li>扩大了寻址范围</li>
</ul>
<p>缺点:</p>
<ul>
<li>速度变慢了, 这里会有 2 次(或者多次)内存io</li>
</ul>
<div style="margin-top:80px">
<hr>
</div>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="5-寄存器间接寻址">5. 寄存器间接寻址<a href="#5-寄存器间接寻址" class="hash-link" aria-label="5. 寄存器间接寻址的直接链接" title="5. 寄存器间接寻址的直接链接">​</a></h3>
<p><strong>寄存器间接寻址</strong>: 通过寄存器间接寻址实现。这意味着指令的操作数地址不是直接给出的，而是存储在一个寄存器中，处理器会访问该寄存器内容所指向的内存地址来获取实际操作数</p>
<div class="language-MIPS language-mips codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-mips codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">lw $t0, 0($s1) # Load Word 指令, 从内存中加载32位数据到$t0寄存器</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain"># 这里的内存地址是 $s1 的内容 (假设$s1包含了一个有效的内存地址)</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">MIPS</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><del>寄存器间接寻址模式的优点在于，它提供了一种灵活的方式来访问内存中的数据。通过使用寄存器间接寻址，程序可以动态地改变寄存器中存储的地址，而不需要修改指令本身。这种方式特别适用于处理一些动态生成的数据结构或者数据访问模式。<sup>[By GPT-3.5]</sup></del></p>
<p>优点:</p>
<ul>
<li>扩大了寻址范围</li>
</ul>
<p>缺点:</p>
<ul>
<li>速度变慢了, 这里会有 2 次(或多次)寄存器访问, 而且寄存器的数量太少了</li>
</ul>
<div style="margin-top:80px">
<hr>
</div>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="6-变址寻址">6. 变址寻址<a href="#6-变址寻址" class="hash-link" aria-label="6. 变址寻址的直接链接" title="6. 变址寻址的直接链接">​</a></h3>
<p><strong>变址寻址</strong>: <strong>以某个寄存器的内容为基础地址，加上指令中给出的偏移量来计算操作数的实际地址</strong>。这种<code>寻址模式在处理数组或循环时特别有用</code>，因为它允许程序在不需要修改基址寄存器的情况下，通过改变偏移量来访问内存中的不同位置。</p>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-04-28_19-03-15.png ##400##" src="/HXLoLi/assets/images/Clip_2024-04-28_19-03-15-ffe0a9a61d2653e1f40f9fc1a0ab8601.png" width="385" height="276" style="border-radius:10px"></td></tr></tbody></table>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>操作数的有效地址</mtext><mi>E</mi><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo>+</mo><mi>A</mi><mo separator="true">,</mo><mtext>   其中</mtext><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mtext>表示 变址寄存器</mtext><mi>I</mi><mtext> 中的内容</mtext></mrow><annotation encoding="application/x-tex">操作数的有效地址 EA = (I) + A, \ \ \ 其中 (I) 表示\ 变址寄存器I\ 中的内容</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord cjk_fallback">操作数的有效地址</span><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord cjk_fallback">其中</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mclose">)</span><span class="mord cjk_fallback">表示</span><span class="mspace"> </span><span class="mord cjk_fallback">变址寄存器</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mspace"> </span><span class="mord cjk_fallback">中的内容</span></span></span></span></p>
<p>变址寄存器是面向用户的，在程序执行过程中，<span style="color:red">变址寄存器的内容可由用户改变(作为偏移(量)，形式地址A不变(作为基地址)</span>。</p>
<div class="language-MIPS language-mips codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-mips codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">addi $t2, $s2, 8 # 先通过addi指令将8加到寄存器$s2上得到新的地址</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">lw $t1, 0($t2)   # 然后使用这个新地址（$s2 + 8）加载内存中的数据到$t1寄存器</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">MIPS</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div style="margin-top:80px">
<hr>
</div>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="7-基址寻址">7. 基址寻址<a href="#7-基址寻址" class="hash-link" aria-label="7. 基址寻址的直接链接" title="7. 基址寻址的直接链接">​</a></h3>
<p><strong>基址寻址(Base Addressing)</strong>: 类似于变址寻址，但这里的基准是固定的<strong>基址寄存器，加上一个偏移量得到操作数地址</strong>。有效地址是通过将基址寄存器的内容与指令中给出的偏移量相加而得到的。</p>
<p>基址寄存器的内容在程序执行过程中通常保持不变，而偏移量可以变化。</p>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-04-28_19-04-41.png ##w600##" src="/HXLoLi/assets/images/Clip_2024-04-28_19-04-41-f7fe403f78b5d1c2bd30ad28c210cdbf.png" width="695" height="167" style="width:600px;border-radius:10px"></td></tr></tbody></table>
<p>可以表示为: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><mi>B</mi><mi>R</mi><mo stretchy="false">)</mo><mo>+</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">EA = (BR) + A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em">BR</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span></p>
<ul>
<li>应用主要用于多道程序分配存储空间(由操作系统分配(面向系统的))</li>
</ul>
<div class="language-MIPS language-mips codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-mips codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">lw $t0, 12($t1) # 基址寻址示例</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">MIPS</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在 MIPS 指令集中，并没有专门的基址寻址指令，而是通过组合寄存器寻址和内存访问指令来实现基址寻址的效果。偏移量可以是一个立即数（如上例中的 12），也可以是一个寄存器的值，这提供了很大的灵活性。</p>
<p>还有一些其他的寻址方式，比如讲上述的一些寻址方式结合，成为新的寻址方式。比如寄存器间接寻址等等的。</p>
<p>小结 --- 以下统称<code>偏移寻址</code>:</p>
<ol>
<li>PC相对寻址</li>
<li>变址寻址</li>
<li>基址寻址</li>
</ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/HengXin666/HXLoLi/edit/main/docs/001-计佬常識/005-计算机组成原理/003-第二章指令系统/006-寻址方式/index.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"><span class="theme-last-updated">最后<!-- -->由 <b>Heng_Xin_666</b> <!-- -->于 <b><time datetime="2025-04-28T14:52:39.000Z" itemprop="dateModified">2025年4月28日</time></b> <!-- -->更新</span></div></div></footer></article><div style="display:flex;justify-content:flex-end;margin-top:20px">请作者喝奶茶:<div class="icon-container" style="margin-left:10px"><img src="/HXLoLi//default-icons/alipay.svg" alt="Alipay Icon" class="icon"><img src="/HXLoLi//img/alipay_qr_code.png" alt="QR Code" class="qr-code"></div><div class="icon-container" style="margin-left:10px"><img src="/HXLoLi//default-icons/wechat.svg" alt="Alipay Icon" class="icon"><img src="/HXLoLi//img/wechat_qr_code.png" alt="QR Code" class="qr-code"></div></div><div style="display:flex;justify-content:flex-end"><span style="font-size:12px">本文遵循 <img src="/HXLoLi//default-icons/cc.svg" alt="CC" style="width:14px"> <span class="tailwind"><a href="https://creativecommons.org/licenses/by-sa/4.0/" class="relative inline-block transition-all duration-300 text-fuchsia-400 hover:text-pink-700" target="_blank" rel="noopener noreferrer">CC 4.0 BY-SA<span class="absolute right-0 bottom-0 h-0.5 bg-purple-700 w-0 transition-all duration-500"></span><span class="absolute left-0 bottom-0 h-0.5 bg-purple-700 w-0"></span></a></span> 版权协议, 转载请标明出处</span></div><div><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/HXLoLi/docs/计佬常識/计算机组成原理/第二章指令系统/指令格式"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">指令格式</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/HXLoLi/docs/计佬常識/计算机组成原理/第二章指令系统/并行、指令和同步"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">并行、指令和同步</div></a></nav></div></div><div>Loading Comments...</div></div><div class="col col--3"><div class="tableOfContents_jeP5 thin-scrollbar theme-doc-toc-desktop"><div class="tailwind"><div class="text-fuchsia-400" style="border-left:1px solid var(--ifm-toc-border-color)"><div class="ml-4 -mb-2" style="border-bottom:1.5px solid var(--ifm-toc-border-color)">0<!-- -->%</div></div></div><ul class="table-of-contents table-of-contents__left-border"><li><a href="#32位立即数" class="table-of-contents__link toc-highlight">32位立即数</a></li><li><a href="#寻址" class="table-of-contents__link toc-highlight">寻址</a><ul><li><a href="#跳转-中的寻址方式-伪直接寻址" class="table-of-contents__link toc-highlight">跳转 中的寻址方式: 伪直接寻址</a></li><li><a href="#分支-中的寻址方式-pc相对寻址" class="table-of-contents__link toc-highlight">分支 中的寻址方式: PC相对寻址</a></li></ul></li><li><a href="#寻址模式的总结" class="table-of-contents__link toc-highlight">寻址模式的总结</a><ul><li><a href="#1-立即寻址" class="table-of-contents__link toc-highlight">1. 立即寻址</a></li><li><a href="#2-直接寻址" class="table-of-contents__link toc-highlight">2. 直接寻址</a></li><li><a href="#3-寄存器寻址" class="table-of-contents__link toc-highlight">3. 寄存器寻址</a></li><li><a href="#4-主存间接寻址" class="table-of-contents__link toc-highlight">4. 主存间接寻址</a></li><li><a href="#5-寄存器间接寻址" class="table-of-contents__link toc-highlight">5. 寄存器间接寻址</a></li><li><a href="#6-变址寻址" class="table-of-contents__link toc-highlight">6. 变址寻址</a></li><li><a href="#7-基址寻址" class="table-of-contents__link toc-highlight">7. 基址寻址</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/HengXin666/HXLoLi" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item">
                <a href="https://docusaurus.io" target="_blank" rel="noreferrer noopener">
                  <img src="/HXLoLi/default-img/buildwith.png" alt="build with docusaurus" width="120" height="50">
                </a>
                </li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">版权所有 © 2025 - 2025 HXLoLi, Inc. 由 Docusaurus 构建.</div></div></div></footer></div>
</body>
</html>