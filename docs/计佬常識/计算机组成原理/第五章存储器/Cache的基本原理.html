<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-计佬常識/计算机组成原理/第五章存储器/Cache的基本原理/index" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">Cache的基本原理 | HXLoLi</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://HengXin666.github.io/HXLoLi/img/logo.png"><meta data-rh="true" name="twitter:image" content="https://HengXin666.github.io/HXLoLi/img/logo.png"><meta data-rh="true" property="og:url" content="https://HengXin666.github.io/HXLoLi/docs/计佬常識/计算机组成原理/第五章存储器/Cache的基本原理"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Cache的基本原理 | HXLoLi"><meta data-rh="true" name="description" content="- 时间局部性:某个数据项在被访问之后可能很快被再次访问的特性, 即某个数据项在一个较短的时间间隔内很可能又被访问。"><meta data-rh="true" property="og:description" content="- 时间局部性:某个数据项在被访问之后可能很快被再次访问的特性, 即某个数据项在一个较短的时间间隔内很可能又被访问。"><link data-rh="true" rel="icon" href="/HXLoLi/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://HengXin666.github.io/HXLoLi/docs/计佬常識/计算机组成原理/第五章存储器/Cache的基本原理"><link data-rh="true" rel="alternate" href="https://HengXin666.github.io/HXLoLi/docs/计佬常識/计算机组成原理/第五章存储器/Cache的基本原理" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://HengXin666.github.io/HXLoLi/docs/计佬常識/计算机组成原理/第五章存储器/Cache的基本原理" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/HXLoLi/blog/rss.xml" title="HXLoLi RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/HXLoLi/blog/atom.xml" title="HXLoLi Atom Feed">





<script src="https://cdn.jsdelivr.net/npm/d3@6.2.0/dist/d3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/force-graph@1.40.3/dist/force-graph.js"></script>
<script src="https://cdn.jsdelivr.net/npm/note-graph@latest/dist/note-graph.umd.js"></script><link rel="stylesheet" href="/HXLoLi/assets/css/styles.38e40bb0.css">
<script src="/HXLoLi/assets/js/runtime~main.55041b4c.js" defer="defer"></script>
<script src="/HXLoLi/assets/js/main.8849aea1.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script>

<style>
  #open-graph-btn {
    align-items: center;
    display: flex;
    justify-content: center;
    width: 100%;
    height: 100%;
    background: none;
    border: none;
    cursor: pointer;
    font-family: inherit;
    padding: 0;
    color: var(--ifm-navbar-link-color);
    transition: color var(--ifm-transition-fast) var(--ifm-transition-timing-default);
  }

  #open-graph-btn:hover {
    color: var(--ifm-link-color);
  }

  @media screen and (max-width: 996px) {
    #open-graph-btn {
      justify-content: flex-start;
      padding-left: 1em;
    }
  }

  #graph-container {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 20px;
    background-color: var(--ifm-background-surface-color);
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    z-index: 2;
  }

  #graph-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(5px);
    z-index: 1;
  }

  #close-graph-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      cursor: pointer;
      font-size: small;
      font-weight: bold;
      z-index: 2;
    }

    canvas {
      margin: 0px auto;
    }

    .force-graph-container .graph-tooltip {
      transform: none !important;
    }
  </style><div id="__docusaurus"><link rel="preload" as="image" href="/HXLoLi/img/logo.png"><link rel="preload" as="image" href="/HXLoLi/default-icons/default_folder.svg"><link rel="preload" as="image" href="/HXLoLi//default-icons/alipay.svg"><link rel="preload" as="image" href="/HXLoLi//img/alipay_qr_code.png"><link rel="preload" as="image" href="/HXLoLi//default-icons/wechat.svg"><link rel="preload" as="image" href="/HXLoLi//img/wechat_qr_code.png"><link rel="preload" as="image" href="/HXLoLi//default-icons/cc.svg"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/HXLoLi/"><div class="navbar__logo"><img src="/HXLoLi/img/logo.png" alt="HXLoLi Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/HXLoLi/img/logo.png" alt="HXLoLi Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">HXLoLi</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/HXLoLi/docs/计佬常識/数据结构与算法/【algorithm】目録">笔记</a><a class="navbar__item navbar__link" href="/HXLoLi/blog">博客</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">更多</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/HXLoLi/blog/archive">归档</a></li></ul></div><a href="https://github.com/HengXin666/HXLoLi" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="navbar__item">
    <button id="open-graph-btn" title="Show Graph Visualisation" type="button" aria-label="Show Graph Visualisation" aria-live="polite" onclick="openGraph()">
      <svg viewBox="0 0 1024 1024" width="24" height="24" fill="currentColor">
        <path d="M512 512m-125.866667 0a125.866667 125.866667 0 1 0 251.733334 0 125.866667 125.866667 0 1 0-251.733334 0Z"></path>
        <path d="M512 251.733333m-72.533333 0a72.533333 72.533333 0 1 0 145.066666 0 72.533333 72.533333 0 1 0-145.066666 0Z"></path>
        <path d="M614.4 238.933333c0 4.266667 2.133333 8.533333 2.133333 12.8 0 19.2-4.266667 36.266667-12.8 51.2 81.066667 36.266667 138.666667 117.333333 138.666667 211.2C742.4 640 640 744.533333 512 744.533333s-230.4-106.666667-230.4-232.533333c0-93.866667 57.6-174.933333 138.666667-211.2-8.533333-14.933333-12.8-32-12.8-51.2 0-4.266667 0-8.533333 2.133333-12.8-110.933333 42.666667-189.866667 147.2-189.866667 273.066667 0 160 130.133333 292.266667 292.266667 292.266666S804.266667 672 804.266667 512c0-123.733333-78.933333-230.4-189.866667-273.066667z"></path>
        <path d="M168.533333 785.066667m-72.533333 0a72.533333 72.533333 0 1 0 145.066667 0 72.533333 72.533333 0 1 0-145.066667 0Z"></path>
        <path d="M896 712.533333m-61.866667 0a61.866667 61.866667 0 1 0 123.733334 0 61.866667 61.866667 0 1 0-123.733334 0Z"></path>
        <path d="M825.6 772.266667c-74.666667 89.6-187.733333 147.2-313.6 147.2-93.866667 0-181.333333-32-249.6-87.466667-10.666667 19.2-25.6 34.133333-44.8 44.8C298.666667 942.933333 401.066667 981.333333 512 981.333333c149.333333 0 281.6-70.4 366.933333-177.066666-21.333333-4.266667-40.533333-17.066667-53.333333-32zM142.933333 684.8c-25.6-53.333333-38.4-110.933333-38.4-172.8C104.533333 288 288 104.533333 512 104.533333S919.466667 288 919.466667 512c0 36.266667-6.4 72.533333-14.933334 106.666667 23.466667 2.133333 42.666667 10.666667 57.6 25.6 12.8-42.666667 19.2-87.466667 19.2-132.266667 0-258.133333-211.2-469.333333-469.333333-469.333333S42.666667 253.866667 42.666667 512c0 74.666667 17.066667 142.933333 46.933333 204.8 14.933333-14.933333 32-27.733333 53.333333-32z"></path>
      </svg>
      <span class="graph-only" style="margin-left: 1rem; font-size: 1rem">Graph View</span>
    </button>
    <style>
    @media only screen and (min-width: 997px) {
      .graph-only {
        display: none;
      }
    }
    </style>
    </div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd sidebarWithHideableNavbar_wUlq"><a tabindex="-1" class="sidebarLogo_isFc" href="/HXLoLi/"><img src="/HXLoLi/img/logo.png" alt="HXLoLi Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/HXLoLi/img/logo.png" alt="HXLoLi Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"><b>HXLoLi</b></a><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" style="font-size:14px" href="/HXLoLi/docs/计佬常識/数据结构与算法/【algorithm】目録"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">计佬常識</div><div style="flex:1"></div></div></a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/数据结构与算法/【algorithm】目録"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">数据结构与算法</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/设计模式/相关面试题"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">设计模式</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机网络/一、计算机网络基础"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">计算机网络</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/操作系统/とあるOSのインデックス"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">操作系统</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/【计组】目录"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">计算机组成原理</div><div style="flex:1"></div></div></a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/【计组】目录">【计组】目录</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第一章计算机概要与技术/计算机的分类及其特性"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第一章计算机概要与技术</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第二章指令系统/计算机硬件的操作与操作数"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第二章指令系统</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第三章计算机算术运算/定点数加减法"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第三章计算机算术运算</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/MIPS核心子集及实现方式"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第四章中央处理器</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第五章存储器/存储器技术"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第五章存储器</div><div style="flex:1"></div></div></a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第五章存储器/存储器技术">存储器技术</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第五章存储器/Cache的基本原理">Cache的基本原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第五章存储器/主存器">主存器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第五章存储器/可信存储器层次">可信存储器层次</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第五章存储器/虚拟存储器">虚拟存储器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第五章存储器/并行与存储器层次结构">并行与存储器层次结构</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第六章IO设备/外部设备及总线"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第六章IO设备</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第七章并行系统/并行系统"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第七章并行系统</div><div style="flex:1"></div></div></a></div></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/程序语言/C++/【C艹】目录大纲"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">程序语言</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/游戏引擎/虚幻引擎/【虚幻】目录"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">游戏引擎</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/DevOps与版本控制/Linux/【Linux】目录"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">DevOps与版本控制</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/中间件/Redis/【Redis】目录"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">中间件</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/数据库/MySQL数据库/とある「MySQL」の禁庫目録"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">数据库</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/刷题日志/做题记录"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">刷题日志</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/嵌入式/杂项/IC通信"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">嵌入式</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/Game/MineCraft/服务器/脚本"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">Game</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/HXLoLi/docs/关于">关于</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_z5aJ"><div class="docItemContainer_c0TR"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/HXLoLi/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">计佬常識</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">计算机组成原理</span><meta itemprop="position" content="2"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">第五章存储器</span><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Cache的基本原理</span><meta itemprop="position" content="4"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Cache的基本原理</h1></header>
<ul>
<li>
<p>时间局部性:某个数据项在被访问之后可能很快被再次访问的特性, 即某个数据项在一个较短的时间间隔内很可能又被访问。</p>
</li>
<li>
<p>空间局部性:某个数据项在被访问之后, 与其地址相近的数据项可能很快被访问的特性。</p>
</li>
</ul>
<p>无论数据如何分层, 数据的处理和交换过程都是两个层之间相互交换, 不可能跨层交换, 所以在描述的存储器层次结构中, &quot;块&quot;(Block)或&quot;行&quot;(Line)是数据传输的基本单位。</p>
<p>当数据从一个层次迁移到另一个层次时, 并不是以字节或者单个数据项为单位, 而是以固定大小的数据块进行。块大小的选择需要权衡多个因素, 包括程序访问模式、缓存大小、以及硬件设计的复杂性和成本。常见的块大小有32字节、64字节、128字节等, 具体大小根据不同的系统和应用需求而定。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="高速缓冲技术">高速缓冲技术<a href="#高速缓冲技术" class="hash-link" aria-label="高速缓冲技术的直接链接" title="高速缓冲技术的直接链接">​</a></h2>
<blockquote>
<p>高速缓冲技术: 就是利用局部性原理, 把程序中正在使用的部分数据存放在一个高速的、容量较小的Cache中, 使CPU的访存操作大多数针对Cache进行, 从而提高程序的执行速度。</p>
</blockquote>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="cache是什么">Cache是什么<a href="#cache是什么" class="hash-link" aria-label="Cache是什么的直接链接" title="Cache是什么的直接链接">​</a></h2>
<p>Cache是一种小容量高速缓冲存储器, 由快速的SRAM组成, 直接制作在CPU芯片内, 速度几乎与CPU一样快。</p>
<p>在CPU和主存之间设置Cache, 总是把主存中被频繁访问的活跃程序块和数据块复制到ache中。由于程序访问的局部性, 大多数情况下, CPU能直接从Cache中取得指令和数据, 而不必访问主存。</p>
<p>为便于Cache和主存间交换信息, Cache和主存空间都被划分为相等的区域。</p>
<p>主存中的区域称为<span style="color:red">块(block)</span>, 也称为主存块, 它是Cache和主存之间的信息交换单位;</p>
<p>Cache中存放一个主存块的区域称为<span style="color:red">行(line)</span>或槽(slot)。</p>
<p>因此, <span style="color:red">主存块大小等于Cache行中数据区大小</span>。</p>
<p>因为Cache的容量远小于主存的容量, 所以Cache中的块数要远少于主存中的块数, Cache 中仅保存主存中最活跃的若干块的副本。因此, 可按照某种策略预测CPU在未来一段时间内欲访存的数据, 将其装入Cache。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="cache-取指过程">Cache 取指过程<a href="#cache-取指过程" class="hash-link" aria-label="Cache 取指过程的直接链接" title="Cache 取指过程的直接链接">​</a></h2>
<p>在计算机系统中, Cache是处理器(CPU)和主存(RAM)之间的一种特殊层次, 用于存储CPU最近访问过的数据或指令。当CPU需要访问某个数据项时, 它首先会在Cache中查找。如果数据在Cache中(称为“命中”), 则CPU可以直接从Cache中读取数据, 从而大大提高了访问速度。如果数据不在Cache中(称为“未命中”), 则CPU需要从主存中读取数据, 并将其存储到Cache中, 以备后续使用。</p>
<p>Cache由一系列的小容量、高速存储单元组成, 每个单元称为一个“块”(Block), 每个块通常包含一个或多个数据项(如一个字)。每个块都有一个与之关联的标签(Tag), 用来标识该块存储的是主存中哪个地址范围的数据。</p>
<p>当处理器请求数据时, 首先会在Cache中查找该数据的标签。如果找到(即缓存命中), 数据直接从Cache提供给处理器, 这是最理想的情况, 速度极快。但如果没找到(即缓存缺失或miss), 就需要从较慢的主存储器中读取数据, 并按照一定的替换策略(如最近最少使用LRU、先进先出FIFO等)将该数据块及其对应地址的标签存入Cache中, 同时将原本Cache中的某个块替换出去(如果Cache已满)。</p>
<p>所以, 处理器首次请求的数据不在Cache中, 这就触发了一次缓存缺失。此时, 不仅需要从主存加载数据到Cache中, 还要处理这次访问带来的额外延迟, 因为处理器必须等待数据到达。</p>














<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-14_23-02-16.png ##w600##" src="/HXLoLi/assets/images/Clip_2024-07-14_23-02-16-9277705b8960cdd63f09f3ea69792b97.png" width="721" height="595" style="width:600px"></td></tr><tr><td style="text-align:center">高速缓冲存储器的工作原理</td></tr></tbody></table>
<p>根据Cache的读、写流程, 可知实现Cache时需解决以下关键问题:</p>
<ol>
<li><strong>数据查找</strong>: 如何快速判断数据是否在Cache中。</li>
<li><strong>地址映射</strong>: 主存块如何存放在Cache中, 如何将主存地址转换为Cache地址。</li>
<li><strong>替换策略</strong>: Cache 满后, 使用何种策略对Cache块进行替换或淘汰。</li>
<li><strong>写入策略</strong>: 如何既保证主存块和Cache块的数据一致性,  又尽量提升效率。</li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="一数据查找">一、数据查找<a href="#一数据查找" class="hash-link" aria-label="一、数据查找的直接链接" title="一、数据查找的直接链接">​</a></h2>
<p>由于Cache行数比主存块数少得多, 因此主存中只有一部分块的信息可放在Cache中, 因此在Cache中要为每块加一个<span style="color:red">标记位</span>, 指明它是主存中哪一块的副本。该标记的内容相当于主存中块的编号。</p>
<p>在系统启动或复位时,每个Cache行都为空,其中的信息无效,只有装人了主存块后信息才有效。为了说明Cache行中的信息是否有效, 每个Cache行需要一个<b style="color:red">有效位</b>。</p>
<p>若主存地址中的标记和Cache行的标记位对上, 并且有效位置为有效, 则在Cache中找到了指定块。再根据块内地址找数据即可。</p>
<p>由此亦可知: 主存地址会被划分为不同的字段</p>
<p>比如直接映射:</p>
<div class="language-lua codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-lua codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token comment" style="color:hsl(220, 10%, 40%)">----------------------</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain"></span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain">标记</span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain">Cache行号</span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain">块内地址</span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain"></span><span class="token comment" style="color:hsl(220, 10%, 40%)">----------------------</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">lua</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>有校位:</p>
<ul>
<li>作用:
<ol>
<li>区分空闲与有效数据</li>
<li>初始化和动态管理</li>
</ol>
</li>
</ul>
<p>实现细节:</p>
<ul>
<li>
<p><strong>存储位置</strong>: 有效位通常与缓存块的标记信息一起存储, 这样处理器在查询缓存时, 可以同时检查索引、比较标记, 并验证有效位, 以此来确定缓存命中与否。</p>
</li>
<li>
<p><strong>命中判断流程</strong>: 在缓存访问过程中, 即使索引和标记匹配, 也需要检查有效位。只有当索引、标记匹配且有效位为1时, 才算是真正的缓存命中。如果有效位为0, 则需要从主存中加载数据, 并将新数据块的有效位置1。</p>
</li>
<li>
<p><strong>性能影响</strong>: 虽然增加有效位的检查看似增加了缓存访问的复杂度, 但实际上这个操作非常迅速, 对整体性能的影响微乎其微。而且, 它对于维持缓存数据的一致性和正确性至关重要。</p>
</li>
</ul>
<p>怎样知道一个数据项是否在Cache 中?</p>
<ul>
<li>为了知道一个数据项是否在缓存中, 通常会使用一种称为&quot;标签(tag)&quot;的机制。标签存储了每个缓存块所对应的主存地址的高位部分(即除了用于直接映射的低位部分之外的部分)。当CPU想要访问一个数据项时, 它会计算数据项的主存地址的低位部分(这部分用于直接映射), 并检查缓存中对应位置的标签是否匹配数据项的主存地址的高位部分。如果匹配, 那么数据项就在缓存中；如果不匹配, 那么数据项不在缓存中, 这被称为&quot;缓存缺失&quot;</li>
</ul>
<p>如果数据项在Cache 中, 如何找到它?</p>
<ul>
<li>如果数据项在缓存中, 那么可以通过直接映射找到它。具体来说, CPU会计算数据项在主存中的地址的低位部分, 这个低位部分直接对应缓存中的一个位置(块)。然后, CPU会检查这个位置的标签是否匹配数据项的主存地址的高位部分。如果匹配, 那么数据项就在这个缓存块中。通常, 缓存块会包含多个字(例如, 一个块可能包含4、8或16个字), 所以一旦找到了正确的缓存块, CPU就可以在这个块中找到所需的数据项。</li>
</ul>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="二地址映射">二、地址映射<a href="#二地址映射" class="hash-link" aria-label="二、地址映射的直接链接" title="二、地址映射的直接链接">​</a></h2>
<p>地址映射: 主存块如何存放在Cache中, 如何将主存地址转换为Cache地址。</p>
<p>Cache行中的信息取自主存中的某个块。在将主存块复制到Cache 行时, 主存块和Cache行之间必须遵循一定的映射规则,这样,CPU要访问某个主存单元时,可以依据映射规则,到Cache对应的行中查找要访问的信息, 而不用在整个Cache中查找。</p>
<p>根据不同的映射规则,主存块和Cache行之间有以下3种映射方式。</p>
<ol>
<li><strong>直接(direct)映射</strong>: 每个主存块映射到Cache的固定行中。</li>
<li><strong>全相联(full associate)映射</strong>: 每个主存块映射到Cache的任意行中。</li>
<li><strong>组相联(set associate)映射</strong>: 每个主存块映射到Cache的固定组的任意行中。</li>
</ol>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="直接映射">直接映射<a href="#直接映射" class="hash-link" aria-label="直接映射的直接链接" title="直接映射的直接链接">​</a></h3>
<p>直接映射缓存的核心思想是为主存中的每个数据块在缓存中预设一个固定的位置。即把主存的每一块映射到固定的一一个Cache行中。这意味着, 任何给定的主存块只能映射到缓存中的一个唯一位置, 不会在缓存中有多个副本。</p>
<p>这种映射关系通过简单的数学运算实现, 最常见的方法是<code>取模运算</code>。所以也叫: 模映射。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mtext>行号</mtext><mo>=</mo><mtext>主存块号 mod </mtext><mi>C</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mtext>行数</mtext></mrow><annotation encoding="application/x-tex">Cache行号 = 主存块号 \text{ mod } Cache行数</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">行号</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord cjk_fallback">主存块号</span><span class="mord text"><span class="mord"> mod </span></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">行数</span></span></span></span></p>
<blockquote>
<p>例如, 假定Cache共有16行, 根据<code>100 mod 16=4</code>,可知: 主存第100块应映射到Cache的第4行中。<code>4 mod 16=4</code>, 主存第4块也应映射到Cache的第4行中, 因此“同余”内存块, 将被映射到同一个Cache行, 形成一个“多对一”的映射关系。</p>
</blockquote>
<p>通常Cache 的行数是2的幂次,假定 Cache 有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>c</mi></msup></mrow><annotation encoding="application/x-tex">2^c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span></span></span></span></span></span></span> 行,主存有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span> 块,这个映射函数的直观含义很简单,即以m位主存块号中后c位作为对应的Cache行号来进行Cache映射。</p>
<p>简言之,主存块以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>c</mi></msup></mrow><annotation encoding="application/x-tex">2^c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span></span></span></span></span></span></span> 为模,被映射到 Cache 的固定行中。</p>
<p>由映射函数可看出, 主存块号的低 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">c</span></span></span></span> 位正好是它要装人的Cache行号。在Cache中,给每一个行设置一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span></span></span></span> 位长的标记(tag),此处 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mi>m</mi><mo>−</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">t=m-c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">c</span></span></span></span>, 主存某块调人Cache后, 就将其块号的高 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span></span></span></span> 位设置在对应Cache行的标记中。</p>
<p>根据以上分析可知, 在直接映射中, 主存地址被分成以下3个字段:</p>
<div class="language-lua codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-lua codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token comment" style="color:hsl(220, 10%, 40%)">----------------------</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain"></span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain">标记</span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain">Cache行号</span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain">块内地址</span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain"></span><span class="token comment" style="color:hsl(220, 10%, 40%)">----------------------</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">lua</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>














<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-14_23-13-09.png ##w350##" src="/HXLoLi/assets/images/Clip_2024-07-14_23-13-09-8bd0e79b11696a1334b5add58b8b95d4.png" width="646" height="484" style="width:350px"></td></tr><tr><td style="text-align:center">Cache和主存间的映射关系</td></tr></tbody></table>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="地址结构与映射过程">地址结构与映射过程<a href="#地址结构与映射过程" class="hash-link" aria-label="地址结构与映射过程的直接链接" title="地址结构与映射过程的直接链接">​</a></h4>
<p>在直接映射缓存中, 主存地址通常被划分为三个部分:</p>
<ul>
<li>
<p><strong>块地址(Block Offset)</strong>: 指示在数据块内部的数据字的位置。这个字段对于缓存的映射决策是不相关的, 但在实际数据提取时需要用到。</p>
</li>
<li>
<p><strong>索引(Index)</strong>: 这部分地址用于确定数据块在缓存中的哪一行(或称组、槽)。通过将主存块地址的中间几位与缓存的行数进行取模运算( 块地址 mod 缓存的块数 ), 可以得到该数据块在缓存中的索引位置。</p>
</li>
<li>
<p><strong>标记(Tag)</strong>: 是主存地址的高位部分, 用于识别具体是哪一个主存块。在缓存中, 每个块都会配有一个标记存储区, 存储与之映射的主存块的标记。当处理器请求数据时, 会比较请求地址的标记与缓存中相应位置的标记, 以验证是否命中。</p>
</li>
</ul>
<div class="markdown-alert markdown-alert-tip">
<p class="markdown-alert-title"><span class="octicon octicon-tip" style="--oct-icon:url(&quot;data:image/svg+xml;utf8,%3Csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; class=&#x27;octicon octicon-light-bulb mr-2&#x27; viewBox=&#x27;0 0 16 16&#x27; version=&#x27;1.1&#x27; width=&#x27;16&#x27; height=&#x27;16&#x27; aria-hidden=&#x27;true&#x27;%3E%3Cpath d=&#x27;M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z&#x27;%3E%3C/path%3E%3C/svg%3E&quot;)"></span>Tip</p>
<p>在直接映射的缓存设计中, 由于主存中的多个块可能会映射到缓存中的同一个位置(块), 因此我们需要一种机制来区分这些不同块中的数据。这就是为何我们会在缓存中为每个缓存块(或称为缓存行)设置一组“标记”(tag)的原因。</p>
</div>
<ul>
<li><strong>有效位</strong>: 在缓存设计中, 除了标记外, 通常还会为每个缓存块(或称为缓存行)增加一个有效位来标识该块是否包含有效数据。这个有效位对于确保缓存的正确操作至关重要, 尤其是在系统启动时或缓存块被替换后。</li>
</ul>
<p>有效位的作用:</p>
<ol>
<li>区分空闲与有效数据</li>
<li>初始化和动态管理</li>
</ol>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="访问流程">访问流程<a href="#访问流程" class="hash-link" aria-label="访问流程的直接链接" title="访问流程的直接链接">​</a></h4>
<ul>
<li>
<p><strong>缓存命中(Hit)</strong>: 当处理器请求数据时, 首先计算该数据块的索引值, 然后检查对应索引位置的缓存块的有效位(Valid Bit), 以及标记是否与请求地址的标记匹配。如果匹配且有效位为1, 说明数据在缓存中, 直接读取该数据, 无需访问主存, 这就是缓存命中。</p>
</li>
<li>
<p><strong>缓存缺失(Miss)</strong>: 如果计算的索引位置的标记与请求地址不匹配, 或者有效位为0, 表示数据不在缓存中, 发生缓存缺失。这时, 需要从主存中读取整个数据块到缓存中指定的索引位置, 替换掉之前(如果有的话)的缓存块, 并更新相应的标记和有效位。同时, 处理器需要等待这次主存访问完成才能继续执行。</p>
</li>
</ul>
<p>cache访问访存过程如下:</p>
<ol>
<li>
<p>根据访存地址中间的c位, 直接找到对应的cache行。</p>
</li>
<li>
<p>将对应cache行中的标记和主存地址的高t位标记进行比较。</p>
</li>
<li>
<p>若相等并有效位为1, 则访问cache&quot;命中”, 此时,根据主存地址中低位的块内地址,在对应的cache行中存取信息。</p>
</li>
<li>
<p>若不相等或有效位为0, 则“不命中”(缺失), 此时, CPU从主存中读出该地址所在的一块信息送到对应的cache行中, 将有效位置1, 并将标记设置为地址中的高t位, 同时将该地址中的内容送CPU。</p>
</li>
</ol>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-16_10-15-34.png ##w400##" src="/HXLoLi/assets/images/Clip_2024-07-16_10-15-34-0d050df93c90d11e63fe0f668dbc4176.png" width="784" height="654" style="width:400px"></td></tr></tbody></table>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="直接映射缓存的设计和计算">直接映射缓存的设计和计算<a href="#直接映射缓存的设计和计算" class="hash-link" aria-label="直接映射缓存的设计和计算的直接链接" title="直接映射缓存的设计和计算的直接链接">​</a></h4>
<p>主存地址的每个字段的位数:</p>
<ul>
<li>
<p><strong>32位主存地址</strong>: 这意味着地址总共有32位, 可以被划分为几个部分来指导数据的访问。</p>
</li>
<li>
<p><strong>直接映射缓存</strong>: 每个主存地址只能映射到缓存的一个固定位置。</p>
</li>
<li>
<p><strong>标记位(Tag Bits)</strong>: 用于唯一标识主存中哪个块的内容当前存储在缓存的特定位置。标记位的计算是总地址位数减去索引位和块内偏移位的总和。</p>
</li>
<li>
<p><strong>索引位(Index Bits)</strong>: 用于确定<code>数据块</code>在缓存中的位置。如果缓存有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 个块, 那么需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 位索引。</p>
</li>
<li>
<p><strong>块内偏移位(Block Offset Bits)</strong>: 用于确定块内特定字节的位置。如果块大小是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span> 个字节, 每个字节对应 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> 位, 那么块内偏移需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span> 位。但通常我们考虑的是块内字的索引, 而不是字节, 如果块大小是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span> 个字(每个字4字节), 则块内字索引需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span> 位。</p>
</li>
<li>
<p><strong>有效位(Valid Bit)</strong>: 每位数据块一个位, 用于标记该块是否有有效数据, 通常占 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> 位。</p>
</li>
<li>
<p><strong>计算标记位大小</strong>: 假设总地址位数是32位, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 位用于索引, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span> 位用于块内偏移, 则标记位的大小为: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mo>−</mo><mi>n</mi><mo>−</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">32 - n - m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">32</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span>。</p>
</li>
<li>
<p><strong>计算单个缓存块的位数</strong>: 块大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span> 个字, 每个字是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">4</span></span></span></span> 字节, 即块大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mo stretchy="false">(</mo></msup><mi>m</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2^(m+2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713em;vertical-align:-0.0833em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 位(因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span> 个字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">× 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">×</span><span class="mord">4</span></span></span></span> 字节/字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>+</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">= 2^{m+2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 字节 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">= 2^{m+2}×8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">8</span></span></span></span> 位)。加上标记位和有效位, 单个块的总位数为: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>m</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>×</mo><mn>8</mn><mo>+</mo><mo stretchy="false">(</mo><mn>32</mn><mo>−</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{m+2}×8 + (32 - n - m) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">32</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> 位。</p>
</li>
<li>
<p><strong>计算整个缓存的总位数</strong>: 缓存总共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 个块, 所以总位数为单个块的位数乘以块数: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>×</mo><mo stretchy="false">[</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>×</mo><mn>8</mn><mo>+</mo><mo stretchy="false">(</mo><mn>32</mn><mo>−</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">2^n × [2^{m+2}×8 + (32 - n - m) + 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mopen">[</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">32</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 位</p>
</li>
</ul>
<p>注意, 对于这个的计算不是什么一成不变的。比如对于标记位的计算, 有的地方不算字节偏移。有的地方算字节偏移, 那么就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mo>−</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mtext>字节偏移量</mtext><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">32-(n+ m+ 2(字节偏移量))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">32</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord cjk_fallback">字节偏移量</span><span class="mclose">))</span></span></span></span>。所以, 这个东西, 知道就好。如果要考试, 以考试参考教材为主。</p>
<div class="language-lua codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-lua codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token comment" style="color:hsl(220, 10%, 40%)">------------------------------------------------------</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain"></span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain">标记</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">(</span><span class="token plain">标记位</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">)</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain">  Cache行号</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">(</span><span class="token plain">索引位</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">)</span><span class="token plain">  </span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain"> 块内地址</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">(</span><span class="token plain">块内偏移位</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">)</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain"></span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token number" style="color:hsl(29, 54%, 61%)">32</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">-</span><span class="token plain"> n </span><span class="token operator" style="color:hsl(207, 82%, 66%)">-</span><span class="token plain"> m </span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain"> </span><span class="token function" style="color:hsl(207, 82%, 66%)">log_2</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">{</span><span class="token plain">Cache块数</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">}</span><span class="token plain">   </span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain"> </span><span class="token function" style="color:hsl(207, 82%, 66%)">log_2</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">{</span><span class="token plain">块大小 </span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">(</span><span class="token plain">B</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">)</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">}</span><span class="token plain">  </span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain"></span><span class="token comment" style="color:hsl(220, 10%, 40%)">------------------------------------------------------</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">lua</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>所以:</p>
<ul>
<li>根据<code>块大小</code>和<code>编址方式</code>确定<code>块内地址</code>的位数。</li>
<li>根据Cache块的数量, 确定<code>行号</code>的位数。</li>
<li>剩下的就是<code>标记</code>位数。</li>
</ul>
<p>注意: <code>标记</code>位数也可以用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mtext>主存块数</mtext><mrow><mi>C</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mtext>块数</mtext></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\cfrac{主存块数}{Cache块数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.59em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">块数</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.74em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord cjk_fallback">主存块数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em"><span></span></span></span></span></span><span></span></span></span></span></span> 来算。</p>
<p>Cache的容量: 一个Cache分为若干行, 即一个Cache包含若干Cache行。</p>
<p>先算一个Cache行的容量, 包含: 数据区域和标记项(标记位, 有效位)。</p>
<ol>
<li><code>数据区域</code>是存放的对应的一个主存块的数据, 所以数据区域大小就是一个主存块的容量</li>
<li><code>标记位</code>, 等于主存地址的标记位。标记位位数即主存地址的标记位的位数</li>
<li><code>有效位</code>: 1位。</li>
</ol>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-16_10-27-28.png ##w500##" src="/HXLoLi/assets/images/Clip_2024-07-16_10-27-28-8c1b2aa3ab63192d4c9dc8ce3d4f0da2.png" width="766" height="192" style="width:500px"></td></tr></tbody></table>
<p>注: 有些替换策略可能还需要一位的脏位, 这个要灵活处理。</p>
<p>例题: 主存和cache之间采用直接映射方式, 块大小为16B。 cache 的数据区容量为64KB, 主存地址为32位, 按字节编址。问: 主存地址如何划分? 并计算cache总容量为多少。</p>
<div class="language-C++ language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-cpp codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token comment" style="color:hsl(220, 10%, 40%)">// 划分</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">标记</span><span class="token operator" style="color:hsl(207, 82%, 66%)">:</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">32</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">-</span><span class="token plain"> n </span><span class="token operator" style="color:hsl(207, 82%, 66%)">-</span><span class="token plain"> m </span><span class="token operator" style="color:hsl(207, 82%, 66%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">32</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">-</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">12</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">-</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">4</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">16</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">Cache行号</span><span class="token operator" style="color:hsl(207, 82%, 66%)">:</span><span class="token plain"> log_2</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">{</span><span class="token number" style="color:hsl(29, 54%, 61%)">64</span><span class="token plain"> KB </span><span class="token operator" style="color:hsl(207, 82%, 66%)">/</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">16</span><span class="token plain"> B </span><span class="token operator" style="color:hsl(207, 82%, 66%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">10</span><span class="token operator" style="color:hsl(207, 82%, 66%)">^</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">{</span><span class="token number" style="color:hsl(29, 54%, 61%)">6</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">+</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">10</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">-</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">4</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">}</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">10</span><span class="token operator" style="color:hsl(207, 82%, 66%)">^</span><span class="token number" style="color:hsl(29, 54%, 61%)">12</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">}</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">12</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">块内地址</span><span class="token operator" style="color:hsl(207, 82%, 66%)">:</span><span class="token plain"> log_2</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">{</span><span class="token number" style="color:hsl(29, 54%, 61%)">16</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">}</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">4</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain" style="display:inline-block"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain"></span><span class="token comment" style="color:hsl(220, 10%, 40%)">// cache总容量</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">一行总容量</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain"></span><span class="token operator" style="color:hsl(207, 82%, 66%)">=</span><span class="token plain"> 数据区大小</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">(</span><span class="token plain">一块的大小</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">)</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">+</span><span class="token plain"> 标记区</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">(</span><span class="token plain">即 标记位 </span><span class="token operator" style="color:hsl(207, 82%, 66%)">+</span><span class="token plain"> 有效位</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">)</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain" style="display:inline-block"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">cache总容量 </span><span class="token operator" style="color:hsl(207, 82%, 66%)">=</span><span class="token plain"> 一行总容量 </span><span class="token operator" style="color:hsl(207, 82%, 66%)">*</span><span class="token plain"> Cache行数</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain"></span><span class="token operator" style="color:hsl(207, 82%, 66%)">=</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">(</span><span class="token number" style="color:hsl(29, 54%, 61%)">16</span><span class="token plain"> B </span><span class="token operator" style="color:hsl(207, 82%, 66%)">+</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">1</span><span class="token plain"> bit </span><span class="token operator" style="color:hsl(207, 82%, 66%)">+</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">16</span><span class="token plain"> bit</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">)</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">*</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">2</span><span class="token operator" style="color:hsl(207, 82%, 66%)">^</span><span class="token number" style="color:hsl(29, 54%, 61%)">12</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">72.5</span><span class="token plain">KB</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">C++</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-16_10-47-33.png ##w600##" src="/HXLoLi/assets/images/Clip_2024-07-16_10-47-33-fd4cee2b00ce24798e7fcb8f681013dc.png" width="1032" height="524" style="width:600px"></td></tr></tbody></table>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="cache块与缺失率">cache块与缺失率<a href="#cache块与缺失率" class="hash-link" aria-label="cache块与缺失率的直接链接" title="cache块与缺失率的直接链接">​</a></h4>
<p>较大的cache块在理论上能够更好地利用空间局部性以降低缺失率。</p>
<ul>
<li>增大块大小的优势: 提高空间局部性利用, 降低缺失率。</li>
</ul>
<p>但是过犹不及, 当块大小在 cache 容量中所占比例增加到一定程度时, 缺失率也随之增加。</p>
<ul>
<li>
<p><strong>缺失成本增加</strong></p>
<ul>
<li>
<p><strong>传输时间增加</strong>: 随着块大小的增大, 从下一层存储(如主存)读取一个块到缓存所需的时间也会增加。这是因为更大的块意味着更多的数据需要传输, 这直接影响了缺失响应时间。首个字的访问延迟可能变化不大, 但后续数据的传输时间显著增长, 从而提高了整体的缺失成本。</p>
</li>
<li>
<p><strong>性能折衷</strong>: 块大小的增加起初能有效减少由于空间局部性良好导致的缺失, 但当块大小达到一定程度, 缺失率的减少速度放缓, 而每次缺失的成本却在持续上升, 这会导致总体性能的倒退。这是因为尽管单次命中能提供更多有用数据, 但每次缺失的惩罚变得更加严重。</p>
</li>
</ul>
</li>
<li>
<p><strong>缺失率与块大小的关系</strong></p>
<ul>
<li>
<p><strong>块间竞争</strong>: 当缓存中块的数量因块大小增加而减少时, 每个块必须承载更广泛地址范围的数据, 增加了块间竞争, 导致数据块被频繁替换, 减少了数据在被有效利用前被替换出缓存的可能性, 从而间接增加了缺失率。</p>
</li>
<li>
<p><strong>空间局部性减弱</strong>: 块过大还可能削弱块内数据间的空间局部性优势。程序中往往存在局部引用的聚集, 但并非所有数据都在一个超大的块内紧密排列。因此, 过大的块可能包含大量未被及时利用的数据, 降低了缓存的有效性。</p>
</li>
</ul>
</li>
<li>
<p><strong>缓解措施</strong></p>
<ul>
<li>
<p><strong>改进存储系统设计</strong>: 为了克服大块带来的传输时间增加, 存储系统可以优化数据传输机制, 如采用更宽的数据总线、提高数据传输速率, 或采用预取技术提前加载可能需要的数据, 从而在不显著增加缺失成本的同时, 享受大块带来的好处。</p>
</li>
<li>
<p><strong>动态块大小</strong>: 某些高级缓存设计可能会采用动态块大小技术, 根据访问模式动态调整块的大小, 试图在块大小与缺失率、缺失成本之间找到最优平衡点, 以最大化缓存的整体效率。</p>
</li>
</ul>
</li>
</ul>
<p>总之, 缓存块大小的选择是一个微妙的平衡行为, 需要综合考虑多种因素, 包括程序的访问模式、存储层次的特性以及系统对性能、成本和能效的需求。</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="cache缺失处理">cache缺失处理<a href="#cache缺失处理" class="hash-link" aria-label="cache缺失处理的直接链接" title="cache缺失处理的直接链接">​</a></h4>
<p>先来看一下控制单元是如何处理 cache 缺失的。</p>
<ul>
<li>在真实的计算机系统中, 当控制单元(CPU的控制逻辑部分)遇到缓存缺失时, 它会执行一系列步骤来确保所需数据能够被正确地从主存或其他较低级缓存中获取并处理。</li>
</ul>
<ol>
<li>检测缺失</li>
<li>停止流水线</li>
<li>生成缺失处理信号</li>
<li>地址计算与请求发送</li>
<li>数据传输</li>
<li>数据处理与缓存更新</li>
<li>恢复执行</li>
<li>预取(可选)</li>
</ol>
<p>cache应用于很多地方, 但是处理的方式只是略有不同, 基本大差不差。比如:</p>
<blockquote>
<p>指令缓存缺失处理步骤:</p>
<ol>
<li>
<p><strong>地址计算与发送读请求</strong>:</p>
<p>将产生缺失的指令地址确定为当前程序计数器(PC)值减去4(因为大多数体系结构中指令预取发生在取指周期, 此时PC已经指向了下一条指令)。使用这个地址向主存发送读请求。</p>
</li>
<li>
<p><strong>等待主存响应</strong>:</p>
<p>处理器在此阶段阻塞, 等待主存完成读取操作。这期间, 处理器的指令执行流
水线会被暂停, 寄存器状态基本保持不变。</p>
</li>
<li>
<p><strong>更新缓存并继续执行</strong>:</p>
<p>当数据从主存返回后, 将其写入缓存的适当位置, 同时设置相应的标记信息和
有效位。之后, 重启指令执行流程, 从缓存中重新获取刚刚填充进来的指令, 继续执行。</p>
</li>
</ol>
<p><strong>数据缓存缺失处理步骤</strong>:</p>
<p>数据缓存缺失的处理流程与指令相似, 主要区别在于引发缺失的原因是数据访问而非指令取指:</p>
<ol>
<li>
<p><strong>地址计算与发送读请求</strong>:</p>
<p>计算实际需要的数据地址, 并向主存发送读请求。这通常是由数据加载或存储指令触发的。</p>
</li>
<li>
<p><strong>等待主存响应并阻塞</strong>:</p>
<p>同样, 处理器在数据未返回前处于阻塞状态, 流水线暂停, 等待数据填充缓存。</p>
</li>
<li>
<p><strong>更新缓存与指令继续</strong>:</p>
<p>数据从主存读取回来后, 更新缓存相应条目, 设置有效位。处理器恢复执行, 继续处理之前因缺失而暂停的指令或开始执行新的指令。</p>
</li>
</ol>
</blockquote>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="全相联映射">全相联映射<a href="#全相联映射" class="hash-link" aria-label="全相联映射的直接链接" title="全相联映射的直接链接">​</a></h3>
<blockquote>
<p>一个块可以被 放置在 cache 中的任何位置。
<strong>全相联映射(Fully Associative Mapping)</strong> 是一种缓存映射技术, 它为内存块提供最大的灵活性, 允许缓存中的任何位置存储任何内存块。相比于直接映射和, 全相联映射在减少冲突缺失方面表现更佳, 但伴随而来的是更高的硬件复杂度和成本。</p>
</blockquote>
<p>在全相联缓存中, 每个缓存条目都可以存放来自主存中任何地址的数据块。这意味着<span style="color:red"><strong>每个</strong>缓存项都有一个对应的标记(Tag)、有效位(Valid Bit)以及数据存储区域</span>(<span style="color:yellow">即每一行都有一个<code>比较器</code></span>)。有效位用来指示该缓存项是否有有效数据, 而标记则用于识别该缓存项存储的是主存中哪个地址的数据。</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="工作原理">工作原理<a href="#工作原理" class="hash-link" aria-label="工作原理的直接链接" title="工作原理的直接链接">​</a></h4>
<p><strong>分块与编号</strong>: 主存和Cache都被分为固定大小的数据块。主存分块, Cache分行, 主存的块和Cache的行大小相同。</p>
<p><strong>地址结构</strong>: 主存地址可以被细分为主存块地址(标记位)和块内偏移地址。</p>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-19_21-40-57.png ##w400##" src="/HXLoLi/assets/images/Clip_2024-07-19_21-40-57-c85c8090dd82d4ccd33ee83cb6d07048.png" width="391" height="107" style="width:400px"></td></tr></tbody></table>
<p><strong>映射算法</strong>: 主存的数据块可以映射到Cache的任意行, 即主存中的某一数据块可以放置在Cache中的任意块。</p>
<p><strong>查找机制</strong>: 为了找到指定的块, Cache中的每个项都需要被检索, 因为该块可能被存放在Cache中的任何位置。这个过程是通过一个与Cache中每个项都相关的比较器并行完成的。</p>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-19_21-42-40.png ##w600##" src="/HXLoLi/assets/images/Clip_2024-07-19_21-42-40-b52e9b9a48c5ebd3612fc53524604944.png" width="811" height="336" style="width:600px"></td></tr></tbody></table>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="优缺点">优缺点<a href="#优缺点" class="hash-link" aria-label="优缺点的直接链接" title="优缺点的直接链接">​</a></h4>
<ul>
<li>优点:
<ol>
<li><strong>高灵活性</strong>: 主存中的任何一块都可以映射到Cache中的任何一块, 提供了高度的灵活性。</li>
<li><strong>高命中率</strong>: 由于映射的灵活性, Cache的命中率通常较高, 从而提高了数据访问的效率。</li>
<li><strong>高存储空间利用率</strong>: Cache的存储空间可以更有效地被利用, 因为没有固定的映射规则限制。</li>
</ol>
</li>
<li>缺点:
<ol>
<li><strong>高硬件成本</strong>: 由于需要并行比较器来快速查找Cache中的匹配项, 这增加了硬件的复杂性和成本。</li>
<li><strong>高访问时间</strong>: 在每次访问时, 都需要与Cache中的所有项进行比较, 这可能导致访问时间增加。</li>
<li><strong>实现复杂度高</strong>: 相对于直接映射和组相联映射, 全相联映射的实现更为复杂。</li>
</ol>
</li>
</ul>
<p>全相联映射通常用于块数较少的Cache中, 因为它在硬件成本和数据访问效率之间提供了较好的平衡。然而, 随着Cache容量的增加, 全相联映射的硬件成本可能会迅速上升, 因此在实际应用中, <strong>组相联映射(Set Associative Mapping)</strong> 往往是一个更实际的选择。</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="组相联映射">组相联映射<a href="#组相联映射" class="hash-link" aria-label="组相联映射的直接链接" title="组相联映射的直接链接">​</a></h3>
<p><strong>组相联(Set Associative)</strong> 缓存设计是直接映射和全相联映射之间的一个折中方案, 它试图平衡二者的优势, 既减少冲突缺失, 又避免全相联映射的高硬件复杂度和成本。</p>
<p>在组相联缓存中, 缓存被划分为多个组, 每个组包含固定数量的缓存行(或称块)。每个内存块可以映射到与之关联的组内的任意一个缓存行, 但不能映射到其他组。这种设计结合了直接映射(通过索引确定唯一组)和全相联映射(组内任意缓存行)的特点。</p>
<p>在这种映射方式中, 主存储器和高速缓存被分成相同大小的组(Set), 每个组内再被分为相同大小的块(Block)。<span style="color:red">组间采用直接映射, 而组内的块之间则采用全相联映射</span>。</p>
<div class="markdown-alert markdown-alert-tip">
<p class="markdown-alert-title"><span class="octicon octicon-tip" style="--oct-icon:url(&quot;data:image/svg+xml;utf8,%3Csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; class=&#x27;octicon octicon-light-bulb mr-2&#x27; viewBox=&#x27;0 0 16 16&#x27; version=&#x27;1.1&#x27; width=&#x27;16&#x27; height=&#x27;16&#x27; aria-hidden=&#x27;true&#x27;%3E%3Cpath d=&#x27;M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z&#x27;%3E%3C/path%3E%3C/svg%3E&quot;)"></span>Tip</p>
<p><span style="color:yellow">若一组有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.02778em">r</span></span></span></span> 个Cache行, 被称为<code>r路组相联</code>。</span></p>
</div>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="工作原理-1">工作原理<a href="#工作原理-1" class="hash-link" aria-label="工作原理的直接链接" title="工作原理的直接链接">​</a></h4>
<p><strong>分组</strong>: 主存储器和高速缓存被划分为大小相等的组。假设主存储器有M个块, 高速缓存有N个块, 每组有S个块, 则高速缓存有N/S个组。</p>
<p><strong>索引</strong>: 当CPU需要访问主存储器中的某个块时, 首先根据主存地址的某一部分(索引域)来确定该块应映射到高速缓存的哪一个组。具体地, 假设主存地址由&lt;Tag, Index, Offset&gt;三部分组成, 其中Index用于确定组号。</p>
<p><strong>块匹配</strong>: 在确定了组号后, CPU会在该组内的所有块中查找与主存块匹配的块。匹配是通过比较主存地址的Tag部分和高速缓存块中的Tag标记来实现的。</p>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-19_21-58-25.png ##w500##" src="/HXLoLi/assets/images/Clip_2024-07-19_21-58-25-5a909a90b607d7663ae16afbaf15aef6.png" width="844" height="129" style="width:500px"></td></tr></tbody></table>
<p>组相联映射的主要思想是, 将cache所有行分成2个大小相等的组, 每组有2行。每个主存块被映射到cache固定组中的任意一行, 即组相联采用组间模映射、组内全映射的方式, 映射关系如下: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mtext>组号</mtext><mo>=</mo><mtext>主存块号 mod </mtext><mi>c</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mtext>组数</mtext></mrow><annotation encoding="application/x-tex">cache组号=主存块号 \text{ mod } cache组数</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">组号</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord cjk_fallback">主存块号</span><span class="mord text"><span class="mord"> mod </span></span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">组数</span></span></span></span></p>
<div class="markdown-alert markdown-alert-tip">
<p class="markdown-alert-title"><span class="octicon octicon-tip" style="--oct-icon:url(&quot;data:image/svg+xml;utf8,%3Csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; class=&#x27;octicon octicon-light-bulb mr-2&#x27; viewBox=&#x27;0 0 16 16&#x27; version=&#x27;1.1&#x27; width=&#x27;16&#x27; height=&#x27;16&#x27; aria-hidden=&#x27;true&#x27;%3E%3Cpath d=&#x27;M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z&#x27;%3E%3C/path%3E%3C/svg%3E&quot;)"></span>Tip</p>
<p>注: 分组映射方式不唯一</p>
</div>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-19_22-00-51.png ##w600##" src="/HXLoLi/assets/images/Clip_2024-07-19_22-00-51-cd7e4e13952e4376ffc19379b47cbd84.png" width="926" height="451" style="width:600px"></td></tr></tbody></table>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="命中与未命中">命中与未命中<a href="#命中与未命中" class="hash-link" aria-label="命中与未命中的直接链接" title="命中与未命中的直接链接">​</a></h4>
<ul>
<li>
<p>如果在高速缓存的某个组内找到了匹配的块, 则称为缓存命中(Cache Hit), CPU可以直接从该块中读取数据。</p>
</li>
<li>
<p>如果在高速缓存的某个组内没有找到匹配的块, 则称为缓存未命中(CacheMiss), CPU需要从主存储器中读取数据, 并可能将该数据块存入高速缓存中的一个空块中(根据替换策略)。</p>
</li>
</ul>
<p>注:</p>
<ul>
<li>直接映射可以看作是<code>1路组相联</code></li>
<li>全相联映射可以看作是只有1组的组相联, 即所以Cache行分为1组</li>
</ul>
<p>比较器的个数: <code>r路组相联</code>需要<code>r个比较器</code>。 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>比较器的位数</mtext><mo>=</mo><mtext>地址标记字段的位数</mtext></mrow><annotation encoding="application/x-tex">比较器的位数 = 地址标记字段的位数</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord cjk_fallback">比较器的位数</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord cjk_fallback">地址标记字段的位数</span></span></span></span></p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="优缺点-1">优缺点<a href="#优缺点-1" class="hash-link" aria-label="优缺点的直接链接" title="优缺点的直接链接">​</a></h4>
<ul>
<li>
<p>优点:</p>
<ul>
<li><strong>减少冲突缺失</strong>: 相较于直接映射, 组相联映射通过允许块在组内多个位置存放, 显著降低了冲突缺失率。</li>
<li><strong>灵活性与效率平衡</strong>: 相比全相联映射, 硬件复杂度和成本更低, 同时提供了较好的性能, 特别是在适度的组数和路数配置下。</li>
</ul>
</li>
<li>
<p>缺点:</p>
<ul>
<li><strong>硬件复杂性</strong>: 相比直接映射, 需要更复杂的硬件来实现组内标记的比较, 增加了设计难度和成本。</li>
<li><strong>查找时间</strong>: 虽然组内并行查找, 但相比直接映射, 查找时间还是要略长一些, 尤其是在高路数的组相联缓存中。</li>
</ul>
</li>
</ul>
<p>组相联映射广泛应用于现代处理器的多级缓存设计中, 尤其是在L1或L2缓存, 因为它在成本和性能之间达到了一个很好的平衡。</p>
<p>通过调整组数和路数, 设计者可以根据特定应用场景和性能目标来优化缓存性能, 比如对冲突缺失敏感的应用可能倾向于使用更高路数的组相联缓存。</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="在cache中查找一个块-组相联缓存查找过程">在cache中查找一个块: 组相联缓存查找过程<a href="#在cache中查找一个块-组相联缓存查找过程" class="hash-link" aria-label="在cache中查找一个块: 组相联缓存查找过程的直接链接" title="在cache中查找一个块: 组相联缓存查找过程的直接链接">​</a></h4>
<ol>
<li>
<p><strong>地址解析</strong>: 处理器请求的内存地址被解析为标记(Tag)、索引(Index)和偏移(Offset)。索引用于确定请求数据可能所在的组。</p>
</li>
<li>
<p><strong>组选择</strong>: 根据索引值, 直接选择对应的组。这意味着索引位数决定了组的数量, 每增加一位索引, 组数翻倍而组的大小减半。</p>
</li>
<li>
<p><strong>并行比较</strong>: 选定的组中所有缓存行的标记与请求地址的标记部分并行比较。增加相联度(每组的缓存行数)可以提高并行度, 从而可能减少查找时间, 但同时增加了硬件复杂性和成本。</p>
</li>
<li>
<p><strong>标记与偏移</strong>: 相联度的增加会导致每组的块数增多, 因此索引位减少, 标记位相应增加, 以维持地址的唯一性。标记位的增多是为了能够唯一标识组内更多的块。</p>
</li>
</ol>
<p>相联度与性能的关系</p>
<ul>
<li>
<p><strong>提高相联度</strong>: 增加每组的缓存行数可以减少冲突缺失, 因为每个块有更多的机会被放置在缓存中。然而, 这也意味着每个组的检索需要比较更多的标记, 尽管这些比较是并行进行的, 但硬件开销和潜在的比较延迟可能会增加。</p>
</li>
<li>
<p><strong>相联度与地址结构</strong>: 相联度的提高导致索引位减少, 标记位增加, 这意味着对于同样的缓存容量, 全相联缓存(相联度最大)不使用索引, 整个地址(除了偏移部分)都作为标记进行比较。</p>
</li>
</ul>
<p>硬件选择</p>
<ul>
<li>
<p>在直接映射缓存中, 由于每个内存块只能映射到缓存的一个固定位置, 因此, 一旦通过索引确定了目标缓存行, 只需对这一行的标记进行比较即可。这简化了硬件设计, 仅需一个比较器来验证请求地址的标记是否与当前缓存行匹配。直接映射缓存的这种简单性降低了硬件成本和访问延迟, 但可能面临较高的冲突缺失率。</p>
</li>
<li>
<p>相比之下, 四路组相联缓存中, 每个组包含四个可能放置数据块的位置, 每个位置都需要独立的比较, 以确定请求的数据是否存在于组内的任一缓存行中。这意味着:</p>
<ul>
<li>
<p><strong>比较器数量</strong>: 每个组需要四个比较器, 每个比较器对应一个缓存行的标记, 用于与请求地址的标记部分进行并行比较。</p>
</li>
<li>
<p><strong>多路选择器</strong>: 还需要一个4选1的多路选择器(Multiplexer), 用于在所有比较结果中选择匹配的缓存行(如果有多个匹配, 则根据替换策略决定)。这个选择器确保了在找到匹配项后, 能够正确读取或写入数据。</p>
</li>
<li>
<p><strong>开销增加</strong>: 因此, 组相联缓存相比直接映射, 硬件开销主要体现在额外的比较器和多路选择器上, 同时, 由于需要在组内进行并行比较和选择, 可能会引入额外的延迟。尽管如此, 这种设计显著降低了冲突缺失率, 提高了缓存的整体效率。</p>
</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="地址映射之例题">地址映射之例题<a href="#地址映射之例题" class="hash-link" aria-label="地址映射之例题的直接链接" title="地址映射之例题的直接链接">​</a></h2>
<p>假设某个计算机的主存地址空间大小为256MB, 按字节编址, 其数据Cache有8个Cache行, 行长为64B。</p>
<ol>
<li>
<p>若不考虑用于Cache的一致维护性位(脏位)和替换算法控制位, 并且采用直接映射方式, 则该数据Cache的总容量为多少?</p>
</li>
<li>
<p>若该Cache采用直接映射方式, 则主存地址为3200 (十进制)的主存块对应的Cache行号是多少?采用二路组相联映射时又是多少?</p>
</li>
</ol>
<div class="language-C++ language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-cpp codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token number" style="color:hsl(29, 54%, 61%)">1.</span><span class="token plain"> 数据Cache的总容量</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">,</span><span class="token plain"> 即Cache的数据区总容量</span><span class="token operator" style="color:hsl(207, 82%, 66%)">:</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">主存地址位数</span><span class="token operator" style="color:hsl(207, 82%, 66%)">:</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">256</span><span class="token plain">MB </span><span class="token operator" style="color:hsl(207, 82%, 66%)">-&gt;</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">2</span><span class="token operator" style="color:hsl(207, 82%, 66%)">^</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">{</span><span class="token number" style="color:hsl(29, 54%, 61%)">20</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">+</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">8</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">}</span><span class="token plain"> B</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">,</span><span class="token plain"> 故 </span><span class="token number" style="color:hsl(29, 54%, 61%)">28</span><span class="token plain"> 位</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">(</span><span class="token plain">标记位</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">)</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">块内地址</span><span class="token operator" style="color:hsl(207, 82%, 66%)">:</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">6</span><span class="token plain">位 </span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">(</span><span class="token number" style="color:hsl(29, 54%, 61%)">2</span><span class="token operator" style="color:hsl(207, 82%, 66%)">^</span><span class="token number" style="color:hsl(29, 54%, 61%)">6</span><span class="token plain"> B</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">)</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">行号</span><span class="token operator" style="color:hsl(207, 82%, 66%)">:</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">3</span><span class="token plain">位 </span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">(</span><span class="token number" style="color:hsl(29, 54%, 61%)">2</span><span class="token operator" style="color:hsl(207, 82%, 66%)">^</span><span class="token number" style="color:hsl(29, 54%, 61%)">3</span><span class="token plain">行</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">)</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">标记位</span><span class="token operator" style="color:hsl(207, 82%, 66%)">:</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">28</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">-</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">6</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">-</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">3</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">19</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">Cache的数据区总容量 </span><span class="token operator" style="color:hsl(207, 82%, 66%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">8</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">*</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">[</span><span class="token number" style="color:hsl(29, 54%, 61%)">64</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">*</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">8</span><span class="token plain"> bit </span><span class="token operator" style="color:hsl(207, 82%, 66%)">+</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">1</span><span class="token plain">bit</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">(</span><span class="token plain">有效位</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">)</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">+</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">19</span><span class="token plain">bit</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">]</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain" style="display:inline-block"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain"></span><span class="token number" style="color:hsl(29, 54%, 61%)">2.</span><span class="token plain"> Cache行号</span><span class="token operator" style="color:hsl(207, 82%, 66%)">:</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">主存地址</span><span class="token operator" style="color:hsl(207, 82%, 66%)">:</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">3200</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">,</span><span class="token plain"> 按字编址</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">,</span><span class="token plain"> 因为行长为</span><span class="token number" style="color:hsl(29, 54%, 61%)">64</span><span class="token plain">B</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">,</span><span class="token plain"> 即</span><span class="token number" style="color:hsl(29, 54%, 61%)">64</span><span class="token plain">字节一块 则 </span><span class="token number" style="color:hsl(29, 54%, 61%)">3200</span><span class="token operator" style="color:hsl(207, 82%, 66%)">/</span><span class="token number" style="color:hsl(29, 54%, 61%)">64</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">50</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain"></span><span class="token number" style="color:hsl(29, 54%, 61%)">50</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">%</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">8</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">2</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain" style="display:inline-block"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">二路组相联映射时</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">,</span><span class="token plain"> Cache行号</span><span class="token operator" style="color:hsl(207, 82%, 66%)">:</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain"></span><span class="token number" style="color:hsl(29, 54%, 61%)">8</span><span class="token operator" style="color:hsl(207, 82%, 66%)">/</span><span class="token number" style="color:hsl(29, 54%, 61%)">2</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">4</span><span class="token plain">组</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain"></span><span class="token number" style="color:hsl(29, 54%, 61%)">50</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">%</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">4</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">2</span><span class="token punctuation" style="color:hsl(220, 14%, 71%)">,</span><span class="token plain"> 在第二组</span><span class="token operator" style="color:hsl(207, 82%, 66%)">:</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain"></span><span class="token number" style="color:hsl(29, 54%, 61%)">0</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">1</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">2</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">3</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">4</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">5</span><span class="token plain"> </span><span class="token operator" style="color:hsl(207, 82%, 66%)">|</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">6</span><span class="token plain"> </span><span class="token number" style="color:hsl(29, 54%, 61%)">7</span><span class="token plain"></span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">那么是Cache行号`</span><span class="token number" style="color:hsl(29, 54%, 61%)">2</span><span class="token plain">或</span><span class="token number" style="color:hsl(29, 54%, 61%)">3</span><span class="token plain">`</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">C++</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="三替换策略">三、替换策略<a href="#三替换策略" class="hash-link" aria-label="三、替换策略的直接链接" title="三、替换策略的直接链接">​</a></h2>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="替换算法-可以结合os课程学">替换算法 (可以结合OS课程学)<a href="#替换算法-可以结合os课程学" class="hash-link" aria-label="替换算法 (可以结合OS课程学)的直接链接" title="替换算法 (可以结合OS课程学)的直接链接">​</a></h3>
<p>在采用<strong>全相联映射</strong>或<strong>组相联映射</strong>方式时, 从主存向Cache传送一 个新块, 当Cache或Cache组中的空间已被占满时, 就需要使用替换算法置换Cache行。</p>
<p>而采用<strong>直接映射</strong>时, 一个给定的主存块只能放到唯一的固定Cache行中, 所以在对应Cache行已有一个主存块的情况下, 新的主存块毫无选择地把原先已有的那个主存块替换掉, 因而 <strong>无须</strong> 考虑替换算法。</p>
<p>常用的替换算法有随机(RAND)算法、先进先出(FIFO)算法、近期最少使用(LRU)算法等等。其中最常用的是<code>LRU算法</code>(重点)。</p>
<ol>
<li>
<p>随机算法: 随机地确定替换的Cache行。它的实现比较简单, 但未依据程序访问的局部性原理, 因此可能命中率较低。</p>
</li>
<li>
<p>先进先出算法: 选择最早调入的Cache 行进行替换。它比较容易实现, 但也未依据程序访问的局部性原理, 因为最早进入的主存块也可能是目前经常要用的。</p>
</li>
<li>
<p>近期最少使用算法(LRU): 依据程序访问的局部性原理, 选择近期内长久未访问过的Cache行进行替换, 是堆栈类算法。</p>
</li>
</ol>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="lru替换策略">LRU替换策略<a href="#lru替换策略" class="hash-link" aria-label="LRU替换策略的直接链接" title="LRU替换策略的直接链接">​</a></h4>
<p>LRU 是一种广泛使用的缓存替换策略, 它基于这样的假设: 最近最少使用的数据块在未来被再次使用的可能性最小。因此, 当需要替换一个块时, LRU 策略会选择最久没有被访问过的块进行替换。</p>
<p>其核心思想是:</p>
<ul>
<li>
<p><strong>记录使用情况</strong>: 为缓存中的每个块维护一个&quot;最近使用&quot;的信息, 通常通过硬件或软件机制实现。</p>
</li>
<li>
<p><strong>选择替换对象</strong>: 当需要替换时, 选择最近最少使用的块。在硬件实现中, 这通常通过维护一个年龄队列或者使用计时器来记录访问顺序。</p>
</li>
</ul>
<div class="markdown-alert markdown-alert-tip">
<p class="markdown-alert-title"><span class="octicon octicon-tip" style="--oct-icon:url(&quot;data:image/svg+xml;utf8,%3Csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; class=&#x27;octicon octicon-light-bulb mr-2&#x27; viewBox=&#x27;0 0 16 16&#x27; version=&#x27;1.1&#x27; width=&#x27;16&#x27; height=&#x27;16&#x27; aria-hidden=&#x27;true&#x27;%3E%3Cpath d=&#x27;M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z&#x27;%3E%3C/path%3E%3C/svg%3E&quot;)"></span>Tip</p>
<p>408需要清楚具体的实现, 这里就不多赘述了</p>
<p>为每一个Cache行增加一个标记项: <code>LRU控制位-计数器</code>(包含若干位。取决于路数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 路组相连映射, LRU控制位为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 位 (值: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 2^n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> ))</p>
<p>|标志位|(有效位|脏位)(可能有, 需要看其写入策略等)|LRU控制位(计数位)|数据位|</p>
<p>有一个: |计数|值(块)|</p>
<ul>
<li>如果查找的存在于缓存(命中), 则这个值对应的计数清零, 并且比它小的计数全部 + 1</li>
<li>如果查找的不存在于缓存(未命中), 则去内存中查找,
<ul>
<li>如果块用完了, 则覆盖计数值最大的数, 并且计数置零, 其他计数 + 1</li>
<li>否则则写入没有用过的块, 其他计数 + 1</li>
</ul>
</li>
</ul>
<p>(注: 上面的算法不会存在两个一样的计数(除了0))</p>
</div>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="直接映射缓存的替换策略">直接映射缓存的替换策略<a href="#直接映射缓存的替换策略" class="hash-link" aria-label="直接映射缓存的替换策略的直接链接" title="直接映射缓存的替换策略的直接链接">​</a></h4>
<p>在直接映射缓存中, 替换策略是预先确定的, 因为每个内存块只能映射到缓存的一个固定位置。当发生缺失时, 占据该位置的现有块会被新块替换, 而不涉及选择过程。</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="组相联和全相联缓存的替换策略">组相联和全相联缓存的替换策略<a href="#组相联和全相联缓存的替换策略" class="hash-link" aria-label="组相联和全相联缓存的替换策略的直接链接" title="组相联和全相联缓存的替换策略的直接链接">​</a></h4>
<p><strong>LRU (Least Recently Used)</strong> 替换算法的实现涉及到跟踪每一块的相对使用情况。对于一个两路组相联的cache, 跟踪组中两个数据项的使用情况可以采用以下几种方法:</p>
<p>使用位标记:</p>
<ul>
<li>在每组中单独保留两位(bit), 每位对应一个数据项。</li>
<li>当一个数据项被访问时, 将其对应的位设置为1, 表示该数据项最近被使用过。</li>
<li>当需要替换时, 检查两位的值, 选择值为0的数据项进行替换(即最久未使用的数据项)</li>
<li>如果两位都为1, 则需要额外的逻辑来确定替换哪一个数据项, 或者可以将两位都重置为0, 并更新为当前访问的数据项(这取决于LRU策略的具体实现)。</li>
</ul>
<p>使用时间戳或计数器:</p>
<ul>
<li>为每个数据项关联一个时间戳或计数器。</li>
<li>当数据项被访问时, 更新其时间戳或增加计数器的值。</li>
<li>需要替换时, 选择时间戳最早或计数器值最小的数据项进行替换。</li>
<li>这种方法需要更多的存储空间来保存时间戳或计数器, 但提供了更精确的使用情况跟踪。</li>
</ul>
<p>使用栈或队列:</p>
<ul>
<li>将最近访问的数据项推入栈(Stack)或队列(Queue)中。</li>
<li>当需要替换时, 从栈或队列的底部(或头部, 取决于栈/队列的类型和LRU策略的实现)选择数据项进行替换。</li>
<li>这种方法需要额外的数据结构来维护访问顺序, 但可以提供直观的LRU实现。</li>
</ul>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="四写入策略">四、写入策略<a href="#四写入策略" class="hash-link" aria-label="四、写入策略的直接链接" title="四、写入策略的直接链接">​</a></h2>
<p>因为cache中的内容是主存块副本, 当对cache中的内容进行更新时,就存在cache和主存如何保持一致的问题。解决cache一致性问题的关键是处理好写操作。通常有两种写操作方式。</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="写直达">写直达<a href="#写直达" class="hash-link" aria-label="写直达的直接链接" title="写直达的直接链接">​</a></h3>
<p>当处理器执行写操作时, 为了提高效率, 数据可能先写入缓存, 而不是立即写回主存。数据在被替换出缓存之前不会更新到主存, 这就造成了缓存与主存数据的不一致(也会有其他行为导致)。而不一致可能会出现一些问题:</p>
<ul>
<li>数据错误</li>
<li>复杂性增加</li>
<li>死锁与活锁</li>
</ul>
<p>当处理器执行写操作时, 为了提高效率, 数据可能先写入缓存, 而不是立即写回主存。数据在被替换出缓存之前不会更新到主存, 这就造成了缓存与主存数据的不一致(也会有其他行为导致)。而不一致可能会出现一些问题:</p>
<ul>
<li>数据错误, 性能下降, 复杂性增加, 死锁与活锁。</li>
</ul>
<p>为了解决不一致的问题, 一个比较简单的思路就是每当处理器写cache时, 它也会立即将数据写入主存。这种方法确保了cache和主存之间的数据始终一致, 因为每次写操作都会同时更新两者。这就是我们的写直达策略。</p>
<p>当处理器执行一个写操作时, 数据不仅会被写入缓存中对应的位置, 同时也会直接写入到下一层存储器, 通常是主存中。这意味着每次写操作都会触发对主存的更新, 确保主存和缓存中的数据保持一致。</p>
<p>他的优点很明显:</p>
<ul>
<li>简单性: 实现逻辑相对简单, 因为不需要复杂的缓存一致性维护机制。</li>
<li>可靠性: 减少了数据丢失的风险, 因为数据立即被写回到持久化存储(主存), 即使在断电或系统故障时, 数据完整性也得以保证。</li>
</ul>
<p>缺点也同样明显:</p>
<ul>
<li>性能影响: 每次写操作都需要访问主存, 这可能比仅写入缓存慢, 尤其是在主存访问延迟较高的情况下。</li>
<li>带宽消耗: 频繁的写操作会大量占用主存总线, 可能影响到其他数据传输操作的性能。</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="写缺失与写缓冲">写缺失与写缓冲<a href="#写缺失与写缓冲" class="hash-link" aria-label="写缺失与写缓冲的直接链接" title="写缺失与写缓冲的直接链接">​</a></h3>
<p>当处理器执行一个写(store)操作并且数据不在cache中时(即写缺失), 处理器需要从主存中取出包含该数据的数据块, 并将其存入cache中。然后, 处理器可以将引起缺失的数据字写入cache中。如果使用写直达策略, 处理器还需要同时将数据写入主存, 这会导致性能下降, 因为写主存的操作通常比写cache要慢得多。(写分配法)</p>
<p>为了减少写操作的延迟, 现代处理器通常会使用写缓冲。写缓冲是一个在处理器和主存之间的小型存储器, 用于暂存等待写入主存的数据。当处理器执行一个写操作时, 它先将数据写入cache(如果是一个写命中)和写缓冲中, 然后继续执行下一条指令, 而不需要等待主存操作完成。这样, 处理器就可以避免由于等待写主存操作完成而产生的阻塞, 从而提高性能。</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="写回法回写法">写回法(回写法)<a href="#写回法回写法" class="hash-link" aria-label="写回法(回写法)的直接链接" title="写回法(回写法)的直接链接">​</a></h3>
<ul>
<li>
<p>写操作局部化: 当处理器执行写操作时, 数据只被更新到缓存中, 而不是立即写入主存。这意味着写操作的延迟被限制在缓存级别, 通常远低于主存访问延迟。</p>
</li>
<li>
<p>延迟更新主存: 只有当包含已修改数据的缓存块需要被替换出去, 以腾出空间给新数据时, 该块的内容才会被“回写”(write-back)到主存中。在这一过程中, 会检查数据是否被修改, 未修改的数据块无需写回操作。</p>
</li>
</ul>
<p>性能优势:</p>
<ol>
<li>减少对外部存储的访问</li>
<li>利用局部性原理</li>
<li>减少带宽需求</li>
</ol>
<p>然而, 写回机制的实现比写直达要复杂得多, 主要在于以下几点:</p>
<ol>
<li>
<p>脏位(Dirty Bit)管理: 每个缓存块需要一个脏位来记录该块是否被修改过。这是写回机制的关键, 因为只有脏块在被替换时才需要写回主存。</p>
</li>
<li>
<p>一致性问题: 在多处理器系统中, 写回机制引入了缓存一致性问题, 需要复杂的协议(如MESI协议)来确保所有处理器看到的数据是一致的。这增加了硬件和软件的复杂性。</p>
</li>
<li>
<p>写合并(Write Combining): 为了减少写回主存的次数, 处理器可能会将多个写操作合并成一个单独的写操作。这需要额外的逻辑来跟踪和合并这些写操作。</p>
</li>
</ol>
<p>为了进一步优化性能和处理写操作的顺序, 写回策略通常会配合使用写缓冲, 这也增加了设计的复杂度。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="五cache性能的评估和改进">五、cache性能的评估和改进<a href="#五cache性能的评估和改进" class="hash-link" aria-label="五、cache性能的评估和改进的直接链接" title="五、cache性能的评估和改进的直接链接">​</a></h2>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="平均存储器访问时间amat">平均存储器访问时间(AMAT)<a href="#平均存储器访问时间amat" class="hash-link" aria-label="平均存储器访问时间(AMAT)的直接链接" title="平均存储器访问时间(AMAT)的直接链接">​</a></h3>
<p>CPU 的时间可以被大致划分为两部分: 一部分是 CPU 实际执行指令所花费的时钟周期数, 另一部分是 CPU 等待存储系统(如 cache 或主存)响应所花费的时钟周期数。在评估系统性能时, 理解并量化这两部分时间是非常重要的。</p>
<p>在理想情况下, 我们假设 cache 访问命中的开销是 CPU 正常执行周期的一部分, 这意味着当 CPU从 cache 中读取或写入数据时, 其执行速度几乎与从寄存器中读写一样快。然而, 当 cache 缺失时, CPU 必须等待从下一级存储层次(如主存)中检索数据, 这通常会导致 CPU 阻塞(stall)或暂停执行, 直到所需的数据到达 cache。</p>
<p>在简化的存储系统模型中, 我们可以将 CPU 时间表示为: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>时间</mtext><mo>=</mo><mo stretchy="false">(</mo><mi>C</mi><mi>P</mi><mi>U</mi><mtext>执行时钟周期数</mtext><mo>+</mo><mtext>存储器阻塞的时钟周期数</mtext><mo stretchy="false">)</mo><mo>×</mo><mtext>时钟周期时间</mtext></mrow><annotation encoding="application/x-tex">CPU时间 = (CPU执行时钟周期数 + 存储器阻塞的时钟周期数) \times 时钟周期时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">CP</span><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="mord cjk_fallback">时间</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em">CP</span><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="mord cjk_fallback">执行时钟周期数</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord cjk_fallback">存储器阻塞的时钟周期数</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord cjk_fallback">时钟周期时间</span></span></span></span></p>
<p>但在许多情况下, cache 缺失是存储器层次结构中导致 CPU 阻塞的主要因素。</p>
<p>存储器阻塞的时钟周期数是由读操作和写操作两部分组成, 而计算读操作阻塞时钟周期数的公式也很好地体现了性能分析中的关键参数。为了进一步完整理解, 我们可以将读写操作的阻塞时钟周期数也纳入进来, 形成一个全面的性能评估框架。</p>
<p><strong>读操作阻塞的时钟周期数计算</strong></p>
<ul>
<li>
<p><strong>读次数</strong>: 这是指程序执行过程中总的内存读取请求次数, 可以通过程序分析或性能监控工具获得。</p>
</li>
<li>
<p><strong>读缺失率</strong>: 即发生读缓存缺失的概率, 可以通过统计分析或模拟得到, 反映程序访问模式与缓存配置的匹配程度。</p>
</li>
<li>
<p><strong>读缺失代价</strong>: 完成一次读缺失处理所需的时钟周期数, 包括从下一级存储(如主存)检索数据的时间、更新缓存标记和数据的时间等。</p>
</li>
</ul>
<p><strong>写操作阻塞的时钟周期数计算</strong></p>
<ul>
<li>
<p><strong>写次数</strong>: 程序执行期间的总内存写请求次数, 同样可通过监控或分析获得。</p>
</li>
<li>
<p><strong>写缺失率</strong>: 虽然写操作不直接导致传统的&quot;缺失&quot;, 但写分配(Write Alocate)策略下, 写操作到未命中缓存块时需要先从主存读取数据到缓存, 这可以看作一种特殊形式的&quot;缺失&quot;, 并计算相应的缺失率。</p>
</li>
<li>
<p><strong>写缺失代价</strong>: 这通常包括从主存读取数据到缓存的成本(如果采用写分配策略), 以及可能的缓存更新、写缓冲操作等开销。</p>
</li>
</ul>
<p>综合计算存储器阻塞的时钟周期数</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>存储器阻塞的时钟周期数</mtext><mspace linebreak="newline"></mspace><mo>=</mo><mtext>读操作阻塞的时钟周期数</mtext><mo>+</mo><mtext>写操作阻塞的时钟周期数</mtext><mspace linebreak="newline"></mspace><mo>=</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mtext>读次数</mtext><mi mathvariant="normal">/</mi><mtext>程序数</mtext><mo stretchy="false">)</mo><mo>×</mo><mtext>读缺失率</mtext><mo>×</mo><mtext>读缺失代价</mtext><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mtext>写次数</mtext><mi mathvariant="normal">/</mi><mtext>程序数</mtext><mo stretchy="false">)</mo><mo>×</mo><mtext>写缺失相关成本</mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">存储器阻塞的时钟周期数 \\= 读操作阻塞的时钟周期数 + 写操作阻塞的时钟周期数 \\= [(读次数/程序数) × 读缺失率 × 读缺失代价] + [(写次数/程序数) × 写缺失相关成本]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord cjk_fallback">存储器阻塞的时钟周期数</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord cjk_fallback">读操作阻塞的时钟周期数</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord cjk_fallback">写操作阻塞的时钟周期数</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">[(</span><span class="mord cjk_fallback">读次数</span><span class="mord">/</span><span class="mord cjk_fallback">程序数</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord cjk_fallback">读缺失率</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord cjk_fallback">读缺失代价</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">[(</span><span class="mord cjk_fallback">写次数</span><span class="mord">/</span><span class="mord cjk_fallback">程序数</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord cjk_fallback">写缺失相关成本</span><span class="mclose">]</span></span></span></span></p>
<p>请注意, 这里的“写缺失相关成本”是一个更宽泛的概念, 包括了写操作引起的各种延迟, 比如在写回缓存中更新脏位、写缓冲的管理开销、以及实际写操作到主存的代价(尤其在写直达策略下)</p>
<p>那如果处理器速度很快, 而存储系统却不快, 又会发生什么？</p>
<ul>
<li>通过<code>Amdahl定律</code>的视角来观察这一问题。当处理器速度提升, 而存储系统速度没有相应提升时, 存储器访问延迟(尤其是缓存缺失导致的延迟)对系统性能的影响会更加显著</li>
</ul>
<blockquote>
<p><strong>原始系统</strong>: CPl(每个指令的时钟周期数)为2, 其中cache缺失导致的额外CPI为3.44(假设这代表了每次缺失的额外开销), 则总CPI为5.44。</p>
<p><strong>改进后的系统</strong>: 通过优化流水线, CPI从2降到了1。但cache缺失的额外开销仍然为3.44(这里假设存储系统性能没有提升), 因此新的总CPI为4.44。</p>
<p><strong>性能比较</strong>: 理想cache(即无缺失)的系统的CPl为1, 而具有cache缺失的系统的cPl为4.44。因此, 理想cache系统的性能是cache缺失系统的4.44倍。</p>
<p><strong>存储器阻塞占比</strong>:</p>
<ul>
<li>原始系统中, 存储器阻塞时间占总执行时间的比例为<code>3.44/5.44=63%</code></li>
<li>改进后的系统中, 这一比例上升到<code>3.44/4.44=77%</code></li>
</ul>
<p>可以看到, 即使处理器速度提高了(CPI从2降到1), 但由于存储系统性能没有提升, 存储器阻塞所花费的时间在整个执行时间中的占比反而增加了。这是因为更快的处理器产生了更多的存储器访问请求, 而存储系统无法及时响应这些请求, 导致更多的cache缺失和更高的阻塞时间。</p>
</blockquote>
<p>可以看到, 主要的原因为: 1、加速不均衡 2、性能提升受限 3、频率提升的局限性</p>
<p>前面的例子和等式是建立在命中时间不计入计算 cache 性能的假设之上。如果命中时间增加, 那么从存储系统中存取一个字的总时间也会增加, 继而导致处理器时钟周期的增加。</p>
<p><strong>命中时间对cache性能的影响</strong>:</p>
<ul>
<li>当数据在cache中命中时, 处理器可以直接从cache中读取数据, 这比从主存中读取要快得多。然而, 如果命中时间增加(即处理器从cache中读取数据所需的时间变长), 那么即使数据在cache中, 处理器也需要花费更多的时间来访问这些数据。这可能会导致处理器时钟周期的增加, 从而降低处理器的性能。</li>
</ul>
<p><strong>大容量cache的影响</strong>:</p>
<ul>
<li>
<p>理论上, 一个更大容量的cache能够存储更多的数据, 从而提高数据的命中率。然而, 实际上, 大容量cache的访问时间通常会比小容量cache更长。这是因为大容量cache需要更多的时间和资源来搜索和定位数据。</p>
</li>
<li>
<p>如果大容量cache的命中时间增加得太多, 那么即使它提高了数据的命中率, 也可能因为访问时间的增加而导致处理器性能的下降。这是因为处理器需要花费更多的时间来从cache中读取数据, 从而降低了处理器的整体性能。</p>
</li>
</ul>
<p>为了更准确地评估cache设计的性能, 设计人员会使用平均存储器访问时间(AMAT)这一指标。AMAT综合考虑了命中、缺失以及不同访问的频率, 能够更全面地反映cache设计的实际效果。</p>
<p>AMAT的计算公式为: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>M</mi><mi>A</mi><mi>T</mi><mo>=</mo><mtext>命中时间</mtext><mo>+</mo><mtext>缺失率</mtext><mo>×</mo><mtext>缺失代价</mtext></mrow><annotation encoding="application/x-tex">AMAT = 命中时间 + 缺失率 × 缺失代价</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.10903em">M</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord cjk_fallback">命中时间</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord cjk_fallback">缺失率</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord cjk_fallback">缺失代价</span></span></span></span> 其中, <code>命中时间</code>是从cache中读取数据所需的时间, <code>缺失率</code>是数据在cache中未命中的概率, <code>缺失代价</code>是当数据在cache中未命中时从主存中读取数据所需的时间</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="多级cache">多级cache<a href="#多级cache" class="hash-link" aria-label="多级cache的直接链接" title="多级cache的直接链接">​</a></h3>
<p>现代计算机系统中广泛使用多级缓存结构来减少处理器和主存(通常是DRAM)之间的性能差距。</p>
<p>随着处理器时钟频率的不断提高和DRAM访问延迟的相对增加, 这种差距变得越来越大。为了缓解这个问题, 大多数现代微处理器都采用了多级缓存架构</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="一级缓存l1cache">一级缓存(L1Cache)<a href="#一级缓存l1cache" class="hash-link" aria-label="一级缓存(L1Cache)的直接链接" title="一级缓存(L1Cache)的直接链接">​</a></h4>
<ul>
<li>通常分为指令缓存(l-Cache)和数据缓存(D-Cache), 或者两者合并成一个统一的缓存(Unified Cache) 。</li>
<li>位于处理器核心内部, 具有非常短的访问延迟(通常是几个时钟周期)。</li>
<li>容量较小, 因为靠近处理器核心, 所以制造成本较高。</li>
</ul>
<p><strong>设计目标</strong>:</p>
<ul>
<li><strong>减少命中时间</strong>: 一级缓存的主要目标是确保处理器在访问数据时能够迅速找到所需的数据, 从而最小化访问延迟。</li>
<li><strong>适应处理器速度</strong>: 随着处理器时钟频率的不断提高, 一级缓存需要能够提供足够快的数据访问速度, 以匹配处理器的处理能力。</li>
</ul>
<p><strong>特性</strong>:</p>
<ul>
<li><strong>容量小</strong>: 由于一级缓存靠近处理器核心, 因此其容量通常较小, 以限制制造成本和功耗。</li>
<li><strong>块容量小</strong>: 为了减小缓存的访问延迟, 一级缓存通常使用较小的数据块(block size)。</li>
<li><strong>低缺失代价</strong>: 由于一级缓存的访问延迟较短, 因此当发生缓存缺失时, 其缺失代价相对较低。</li>
</ul>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="二级缓存l2cache">二级缓存(L2Cache)<a href="#二级缓存l2cache" class="hash-link" aria-label="二级缓存(L2Cache)的直接链接" title="二级缓存(L2Cache)的直接链接">​</a></h4>
<ul>
<li>位于处理器芯片上, 但可能不在核心内部, 因此访问延迟比L1Cache稍长。</li>
<li>容量通常比L1Cache大, 用于存储更多的常用数据。</li>
<li>当L1 Cache发生缺失时, 处理器会检查L2 Cache。</li>
</ul>
<p><strong>设计目标</strong>:</p>
<ul>
<li><strong>改善缺失率</strong>: 二级缓存的主要目标是捕获那些在一级缓存中未命中的数据, 以减少对主存的访问次数, 从而降低访存延迟。</li>
<li><strong>提供大容量</strong>: 由于二级缓存的访问速度相对较慢, 因此它可以提供比一级缓存更大的容量, 以存储更多的常用数据。</li>
</ul>
<p><strong>特性</strong>:</p>
<ul>
<li><strong>容量大</strong>: 二级缓存的容量通常比一级缓存大得多, 以存储更多的数据, 并降低缺失率。</li>
<li><strong>块容量大</strong>: 为了更有效地利用缓存空间, 二级缓存通常使用比一级缓存更大的数据块。</li>
<li><strong>高相联度</strong>: 为了提高缓存的命中率, 二级缓存通常使用比一级缓存更高的相联度
(associativity), 即每个缓存组(set)中可以包含更多的缓存行(line)。</li>
</ul>
<p>(当然还可能存在第三级)</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="多级缓存的工作原理">多级缓存的工作原理<a href="#多级缓存的工作原理" class="hash-link" aria-label="多级缓存的工作原理的直接链接" title="多级缓存的工作原理的直接链接">​</a></h4>
<ol>
<li>当处理器需要读取或写入数据时, 它首先会在L1 Cache中查找。</li>
<li>如果L1 Cache中找到了所需的数据(缓存命中), 则处理器会立即使用该数据, 从而避免了访问主存的延迟。</li>
<li>如果L1 Cache中没有找到所需的数据(缓存缺失), 处理器会检查L2 Cache。</li>
<li>如果L2 Cache中找到了数据(二级缓存命中), 则处理器会使用该数据, 但访问延迟会比L1Cache稍长。</li>
<li>如果L2 Cache中也没有找到数据(二级缓存缺失), 则处理器必须访问主存(DRAM), 这会产生更大的延迟。</li>
</ol>
<p>缓存的替换策略:</p>
<ul>
<li>当新的数据需要被缓存, 而缓存已满时, 就需要使用某种替换策略来决定哪些数据应该被替换出去。LRU(最近最少使用)替换策略是一种常用的方法。</li>
</ul>
<p>缓存的影响:</p>
<ul>
<li>多级缓存结构可以显著提高处理器的性能, 因为它减少了处理器等待数据从主存中加载的时间。</li>
<li>然而, 缓存的引入也增加了系统的复杂性和成本, 因为需要额外的硬件来存储和管理缓存数据。</li>
</ul>
<p>多级缓存系统的优势:</p>
<ul>
<li><strong>分层优化</strong>: 通过将快速但小容量的L1与慢速但大容量的L2相结合, 系统能够在保证快速响应的同时, 有效提升数据的存储量和访问效率。</li>
<li><strong>成本与性能平衡</strong>: L1的设计更注重速度, L2的设计更注重容量和缺失率, 这种分层设计在成本和性能之间找到了一个较好的平衡点。</li>
<li><strong>互补作用</strong>: 每一级缓存都针对性地解决不同类型的问题, L1减少直接的访问延迟, L2则通过减少访问主存的频率来间接提升整体性能。</li>
</ul>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="多级缓存与单级缓存的比较">多级缓存与单级缓存的比较<a href="#多级缓存与单级缓存的比较" class="hash-link" aria-label="多级缓存与单级缓存的比较的直接链接" title="多级缓存与单级缓存的比较的直接链接">​</a></h4>
<p><strong>容量和块容量的差异</strong>:</p>
<ul>
<li>
<p>多级缓存中的一级缓存由于容量和块容量的限制, 其命中率可能相对较低。然而, 由于其访问速度快, 即使发生缺失, 缺失代价也相对较低。</p>
</li>
<li>
<p>二级缓存通过提供更大的容量和块容量, 能够存储更多的数据, 并提高命中率, 从而减少了访存次数和缺失代价。</p>
</li>
</ul>
<p><strong>相联度的差异</strong>:</p>
<ul>
<li>一级缓存由于容量和硬件复杂性的限制, 通常使用较低的相联度。</li>
<li>二级缓存则可以使用更高的相联度, 以进一步提高命中率。</li>
</ul>
<p><strong>优化目标</strong>:</p>
<ul>
<li>单级缓存需要在容量、块容量、相联度等参数之间找到最佳的平衡点, 以最大化性能。</li>
<li>多级缓存则可以通过将不同层级的缓存优化为不同的目标(如一级缓存优化命中时间, 二级缓存优化缺失率), 来更好地利用有限的硬件资源, 实现更高的整体性能。</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="通过分块进行软件优化-科普了解即可">通过分块进行软件优化 (科普(了解即可))<a href="#通过分块进行软件优化-科普了解即可" class="hash-link" aria-label="通过分块进行软件优化 (科普(了解即可))的直接链接" title="通过分块进行软件优化 (科普(了解即可))的直接链接">​</a></h3>
<p>分块算法(Blocking or Tiling)是一种有效的软件优化技术, 尤其适用于处理多维数组, 如在科学计算、图像处理和矩阵运算等领域。该技术通过改变数据访问模式, 提高了缓存的利用效率, 从而显著提升了程序性能。下面是分块算法的基本思想及其如何提升缓存性能的详细解释:</p>
<p>分块算法原理</p>
<ol>
<li>
<p><strong>数据重组</strong>: 将原本连续的大数组划分为多个较小的子矩阵或块(Blocks)。这些块的尺寸通常与缓存行大小或者缓存的容量相匹配, 以充分利用缓存的空间。</p>
</li>
<li>
<p><strong>访问模式调整</strong>: 在处理这些子块时, 尽量在算法设计中安排数据访问顺序, 使得在处理一个块内的数据时, 能够连续访问, 减少缓存的冲突缺失。理想情况下, 一个块内的数据能够在一次或几次缓存装载中被完全访问, 之后才需要加载下一个块。</p>
</li>
<li>
<p><strong>循环展开</strong>: 与分块算法结合使用, 通过循环展开技术增加每次迭代中处理的数据量, 进一步提高数据局部性, 减少循环控制和分支预测的开销。</p>
</li>
</ol>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="通过分块进行软件优化">通过分块进行软件优化<a href="#通过分块进行软件优化" class="hash-link" aria-label="通过分块进行软件优化的直接链接" title="通过分块进行软件优化的直接链接">​</a></h4>
<p>应用于行列混合访问</p>
<p>对于那些既要按行访问又要按列访问的多数组操作, 传统的按行或按列存储方式往往不能充分利用缓存, 因为每次访问可能跨越多个缓存行, 导致频繁的缓存缺失。分块算法通过以下方式解决这一问题:</p>
<p><strong>交错访问</strong>: 通过将数据组织成块, 可以在一个循环迭代中集中访问一个块内的行数据, 下一个迭代则集中访问同一块内的列数据, 或者交错访问不同块的行/列数据, 从而在缓存中形成连续的访问模式。</p>
<p><strong>预取策略</strong>: 结合预取技术, 可以在处理当前块的同时, 预取下一个即将访问的块到缓存中, 进一步减少等待时间。</p>
<p>性能提升:</p>
<ul>
<li><strong>提高缓存命中率</strong>: 通过精心设计的块尺寸和访问顺序, 使得在处理一个块的过程中, 大多数数据都能从缓存中快速获取, 减少了对外部存储器的访问, 提升了命中率。</li>
<li><strong>利用空间局部性</strong>: 分块使得在处理一个任务时, 相关的数据块能够被连续访问, 充分利用了缓存的空间局部性.</li>
<li><strong>减少冲突缺失</strong>: 合理的块尺寸和布局可以减少多个块之间因争夺缓存空间而导致的冲突缺失。</li>
</ul>
<p>通过这些策略, 分块算法显著提高了数据访问的时间局部性和空间局部性, 减少了缓存缺失率, 从而提升了程序的执行效率, 尤其是在处理大规模数据集时效果尤为明显。</p>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-25_23-49-19.png ##w600##" src="/HXLoLi/assets/images/Clip_2024-07-25_23-49-19-ffc328b8c047160b691ccb468a085228.png" width="1157" height="707" style="width:600px"></td></tr></tbody></table></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/HengXin666/HXLoLi/edit/main/docs/001-计佬常識/005-计算机组成原理/006-第五章存储器/002-Cache的基本原理/index.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"><span class="theme-last-updated">最后<!-- -->由 <b>Heng_Xin_666</b> <!-- -->于 <b><time datetime="2025-04-28T14:52:39.000Z" itemprop="dateModified">2025年4月28日</time></b> <!-- -->更新</span></div></div></footer></article><div style="display:flex;justify-content:flex-end;margin-top:20px">请作者喝奶茶:<div class="icon-container" style="margin-left:10px"><img src="/HXLoLi//default-icons/alipay.svg" alt="Alipay Icon" class="icon"><img src="/HXLoLi//img/alipay_qr_code.png" alt="QR Code" class="qr-code"></div><div class="icon-container" style="margin-left:10px"><img src="/HXLoLi//default-icons/wechat.svg" alt="Alipay Icon" class="icon"><img src="/HXLoLi//img/wechat_qr_code.png" alt="QR Code" class="qr-code"></div></div><div style="display:flex;justify-content:flex-end"><span style="font-size:12px">本文遵循 <img src="/HXLoLi//default-icons/cc.svg" alt="CC" style="width:14px"> <span class="tailwind"><a href="https://creativecommons.org/licenses/by-sa/4.0/" class="relative inline-block transition-all duration-300 text-fuchsia-400 hover:text-pink-700" target="_blank" rel="noopener noreferrer">CC 4.0 BY-SA<span class="absolute right-0 bottom-0 h-0.5 bg-purple-700 w-0 transition-all duration-500"></span><span class="absolute left-0 bottom-0 h-0.5 bg-purple-700 w-0"></span></a></span> 版权协议, 转载请标明出处</span></div><div><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/HXLoLi/docs/计佬常識/计算机组成原理/第五章存储器/存储器技术"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">存储器技术</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/HXLoLi/docs/计佬常識/计算机组成原理/第五章存储器/主存器"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">主存器</div></a></nav></div></div><div>Loading Comments...</div></div><div class="col col--3"><div class="tableOfContents_jeP5 thin-scrollbar theme-doc-toc-desktop"><div class="tailwind"><div class="text-fuchsia-400" style="border-left:1px solid var(--ifm-toc-border-color)"><div class="ml-4 -mb-2" style="border-bottom:1.5px solid var(--ifm-toc-border-color)">0<!-- -->%</div></div></div><ul class="table-of-contents table-of-contents__left-border"><li><a href="#高速缓冲技术" class="table-of-contents__link toc-highlight">高速缓冲技术</a></li><li><a href="#cache是什么" class="table-of-contents__link toc-highlight">Cache是什么</a></li><li><a href="#cache-取指过程" class="table-of-contents__link toc-highlight">Cache 取指过程</a></li><li><a href="#一数据查找" class="table-of-contents__link toc-highlight">一、数据查找</a></li><li><a href="#二地址映射" class="table-of-contents__link toc-highlight">二、地址映射</a><ul><li><a href="#直接映射" class="table-of-contents__link toc-highlight">直接映射</a><ul><li><a href="#地址结构与映射过程" class="table-of-contents__link toc-highlight">地址结构与映射过程</a></li><li><a href="#访问流程" class="table-of-contents__link toc-highlight">访问流程</a></li><li><a href="#直接映射缓存的设计和计算" class="table-of-contents__link toc-highlight">直接映射缓存的设计和计算</a></li><li><a href="#cache块与缺失率" class="table-of-contents__link toc-highlight">cache块与缺失率</a></li><li><a href="#cache缺失处理" class="table-of-contents__link toc-highlight">cache缺失处理</a></li></ul></li><li><a href="#全相联映射" class="table-of-contents__link toc-highlight">全相联映射</a><ul><li><a href="#工作原理" class="table-of-contents__link toc-highlight">工作原理</a></li><li><a href="#优缺点" class="table-of-contents__link toc-highlight">优缺点</a></li></ul></li><li><a href="#组相联映射" class="table-of-contents__link toc-highlight">组相联映射</a><ul><li><a href="#工作原理-1" class="table-of-contents__link toc-highlight">工作原理</a></li><li><a href="#命中与未命中" class="table-of-contents__link toc-highlight">命中与未命中</a></li><li><a href="#优缺点-1" class="table-of-contents__link toc-highlight">优缺点</a></li><li><a href="#在cache中查找一个块-组相联缓存查找过程" class="table-of-contents__link toc-highlight">在cache中查找一个块: 组相联缓存查找过程</a></li></ul></li></ul></li><li><a href="#地址映射之例题" class="table-of-contents__link toc-highlight">地址映射之例题</a></li><li><a href="#三替换策略" class="table-of-contents__link toc-highlight">三、替换策略</a><ul><li><a href="#替换算法-可以结合os课程学" class="table-of-contents__link toc-highlight">替换算法 (可以结合OS课程学)</a><ul><li><a href="#lru替换策略" class="table-of-contents__link toc-highlight">LRU替换策略</a></li><li><a href="#直接映射缓存的替换策略" class="table-of-contents__link toc-highlight">直接映射缓存的替换策略</a></li><li><a href="#组相联和全相联缓存的替换策略" class="table-of-contents__link toc-highlight">组相联和全相联缓存的替换策略</a></li></ul></li></ul></li><li><a href="#四写入策略" class="table-of-contents__link toc-highlight">四、写入策略</a><ul><li><a href="#写直达" class="table-of-contents__link toc-highlight">写直达</a></li><li><a href="#写缺失与写缓冲" class="table-of-contents__link toc-highlight">写缺失与写缓冲</a></li><li><a href="#写回法回写法" class="table-of-contents__link toc-highlight">写回法(回写法)</a></li></ul></li><li><a href="#五cache性能的评估和改进" class="table-of-contents__link toc-highlight">五、cache性能的评估和改进</a><ul><li><a href="#平均存储器访问时间amat" class="table-of-contents__link toc-highlight">平均存储器访问时间(AMAT)</a></li><li><a href="#多级cache" class="table-of-contents__link toc-highlight">多级cache</a><ul><li><a href="#一级缓存l1cache" class="table-of-contents__link toc-highlight">一级缓存(L1Cache)</a></li><li><a href="#二级缓存l2cache" class="table-of-contents__link toc-highlight">二级缓存(L2Cache)</a></li><li><a href="#多级缓存的工作原理" class="table-of-contents__link toc-highlight">多级缓存的工作原理</a></li><li><a href="#多级缓存与单级缓存的比较" class="table-of-contents__link toc-highlight">多级缓存与单级缓存的比较</a></li></ul></li><li><a href="#通过分块进行软件优化-科普了解即可" class="table-of-contents__link toc-highlight">通过分块进行软件优化 (科普(了解即可))</a><ul><li><a href="#通过分块进行软件优化" class="table-of-contents__link toc-highlight">通过分块进行软件优化</a></li></ul></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/HengXin666/HXLoLi" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item">
                <a href="https://docusaurus.io" target="_blank" rel="noreferrer noopener">
                  <img src="/HXLoLi/default-img/buildwith.png" alt="build with docusaurus" width="120" height="50">
                </a>
                </li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">版权所有 © 2025 - 2025 HXLoLi, Inc. 由 Docusaurus 构建.</div></div></div></footer></div>
<div>
    <div id="graph-overlay"></div>
    <div id="graph-container">
      <div id="close-graph-btn" onclick="closeGraph()">
        <div style="padding: 5px">X</div>
      </div>
      <div>
        <h1 style="text-align: center">Graph View</h1>
        <div id="graphview-container" style="display: inline-block;margin: 0 auto"></div>
      </div>
    </div>
    </div>
<script>let graphViewGlobal=null,isOpen=!1;async function initGraphView(){const e=await(await fetch("/docusaurus-graph.json")).json(),n=new NOTE_GRAPH.NoteGraphModel(e);graphViewGlobal=new NOTE_GRAPH.NoteGraphView({container:document.getElementById("graphview-container"),graphModel:n,enableNodeDrag:!0,width:800,height:600})}window.onload=function(){initGraphView()};const graphContainer=document.getElementById("graph-container"),graphOverlay=document.getElementById("graph-overlay");function closeGraph(){graphContainer.style.display="none",graphOverlay.style.display="none"}function openGraph(){!0===isOpen?(closeGraph(),isOpen=!1):window.innerWidth>=800&&window.innerHeight>=720?(graphContainer.style.display="block",graphOverlay.style.display="block",graphViewGlobal.forceGraph.zoomToFit(1e3,20),isOpen=!0):alert("Your screen size must be greater than 800x720.")}graphOverlay.addEventListener("click",closeGraph)</script></body>
</html>