<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-计佬常識/计算机组成原理/第四章中央处理器/异常和中断/index" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">异常和中断 | HXLoLi</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://HengXin666.github.io/HXLoLi/img/logo.png"><meta data-rh="true" name="twitter:image" content="https://HengXin666.github.io/HXLoLi/img/logo.png"><meta data-rh="true" property="og:url" content="https://HengXin666.github.io/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/异常和中断"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="异常和中断 | HXLoLi"><meta data-rh="true" name="description" content="异常和中断是处理器用来处理非预期事件或来自外部设备请求的重要机制。这些机制对于实现稳定的系统行为和高效的I/O通信至关重要。"><meta data-rh="true" property="og:description" content="异常和中断是处理器用来处理非预期事件或来自外部设备请求的重要机制。这些机制对于实现稳定的系统行为和高效的I/O通信至关重要。"><link data-rh="true" rel="icon" href="/HXLoLi/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://HengXin666.github.io/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/异常和中断"><link data-rh="true" rel="alternate" href="https://HengXin666.github.io/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/异常和中断" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://HengXin666.github.io/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/异常和中断" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/HXLoLi/blog/rss.xml" title="HXLoLi RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/HXLoLi/blog/atom.xml" title="HXLoLi Atom Feed">





<script src="https://cdn.jsdelivr.net/npm/d3@6.2.0/dist/d3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/force-graph@1.40.3/dist/force-graph.js"></script>
<script src="https://cdn.jsdelivr.net/npm/note-graph@latest/dist/note-graph.umd.js"></script><link rel="stylesheet" href="/HXLoLi/assets/css/styles.38e40bb0.css">
<script src="/HXLoLi/assets/js/runtime~main.3842a9d0.js" defer="defer"></script>
<script src="/HXLoLi/assets/js/main.d2c816a5.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script>

<style>
  #open-graph-btn {
    align-items: center;
    display: flex;
    justify-content: center;
    width: 100%;
    height: 100%;
    background: none;
    border: none;
    cursor: pointer;
    font-family: inherit;
    padding: 0;
    color: var(--ifm-navbar-link-color);
    transition: color var(--ifm-transition-fast) var(--ifm-transition-timing-default);
  }

  #open-graph-btn:hover {
    color: var(--ifm-link-color);
  }

  @media screen and (max-width: 996px) {
    #open-graph-btn {
      justify-content: flex-start;
      padding-left: 1em;
    }
  }

  #graph-container {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 20px;
    background-color: var(--ifm-background-surface-color);
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    z-index: 2;
  }

  #graph-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(5px);
    z-index: 1;
  }

  #close-graph-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      cursor: pointer;
      font-size: small;
      font-weight: bold;
      z-index: 2;
    }

    canvas {
      margin: 0px auto;
    }

    .force-graph-container .graph-tooltip {
      transform: none !important;
    }
  </style><div id="__docusaurus"><link rel="preload" as="image" href="/HXLoLi/img/logo.png"><link rel="preload" as="image" href="/HXLoLi/default-icons/default_folder.svg"><link rel="preload" as="image" href="/HXLoLi//default-icons/alipay.svg"><link rel="preload" as="image" href="/HXLoLi//img/alipay_qr_code.png"><link rel="preload" as="image" href="/HXLoLi//default-icons/wechat.svg"><link rel="preload" as="image" href="/HXLoLi//img/wechat_qr_code.png"><link rel="preload" as="image" href="/HXLoLi//default-icons/cc.svg"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/HXLoLi/"><div class="navbar__logo"><img src="/HXLoLi/img/logo.png" alt="HXLoLi Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/HXLoLi/img/logo.png" alt="HXLoLi Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">HXLoLi</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/HXLoLi/docs/关于">笔记</a><a class="navbar__item navbar__link" href="/HXLoLi/blog">博客</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">更多</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/HXLoLi/blog/archive">归档</a></li></ul></div><a href="https://github.com/HengXin666/HXLoLi" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="navbar__item">
    <button id="open-graph-btn" title="Show Graph Visualisation" type="button" aria-label="Show Graph Visualisation" aria-live="polite" onclick="openGraph()">
      <svg viewBox="0 0 1024 1024" width="24" height="24" fill="currentColor">
        <path d="M512 512m-125.866667 0a125.866667 125.866667 0 1 0 251.733334 0 125.866667 125.866667 0 1 0-251.733334 0Z"></path>
        <path d="M512 251.733333m-72.533333 0a72.533333 72.533333 0 1 0 145.066666 0 72.533333 72.533333 0 1 0-145.066666 0Z"></path>
        <path d="M614.4 238.933333c0 4.266667 2.133333 8.533333 2.133333 12.8 0 19.2-4.266667 36.266667-12.8 51.2 81.066667 36.266667 138.666667 117.333333 138.666667 211.2C742.4 640 640 744.533333 512 744.533333s-230.4-106.666667-230.4-232.533333c0-93.866667 57.6-174.933333 138.666667-211.2-8.533333-14.933333-12.8-32-12.8-51.2 0-4.266667 0-8.533333 2.133333-12.8-110.933333 42.666667-189.866667 147.2-189.866667 273.066667 0 160 130.133333 292.266667 292.266667 292.266666S804.266667 672 804.266667 512c0-123.733333-78.933333-230.4-189.866667-273.066667z"></path>
        <path d="M168.533333 785.066667m-72.533333 0a72.533333 72.533333 0 1 0 145.066667 0 72.533333 72.533333 0 1 0-145.066667 0Z"></path>
        <path d="M896 712.533333m-61.866667 0a61.866667 61.866667 0 1 0 123.733334 0 61.866667 61.866667 0 1 0-123.733334 0Z"></path>
        <path d="M825.6 772.266667c-74.666667 89.6-187.733333 147.2-313.6 147.2-93.866667 0-181.333333-32-249.6-87.466667-10.666667 19.2-25.6 34.133333-44.8 44.8C298.666667 942.933333 401.066667 981.333333 512 981.333333c149.333333 0 281.6-70.4 366.933333-177.066666-21.333333-4.266667-40.533333-17.066667-53.333333-32zM142.933333 684.8c-25.6-53.333333-38.4-110.933333-38.4-172.8C104.533333 288 288 104.533333 512 104.533333S919.466667 288 919.466667 512c0 36.266667-6.4 72.533333-14.933334 106.666667 23.466667 2.133333 42.666667 10.666667 57.6 25.6 12.8-42.666667 19.2-87.466667 19.2-132.266667 0-258.133333-211.2-469.333333-469.333333-469.333333S42.666667 253.866667 42.666667 512c0 74.666667 17.066667 142.933333 46.933333 204.8 14.933333-14.933333 32-27.733333 53.333333-32z"></path>
      </svg>
      <span class="graph-only" style="margin-left: 1rem; font-size: 1rem">Graph View</span>
    </button>
    <style>
    @media only screen and (min-width: 997px) {
      .graph-only {
        display: none;
      }
    }
    </style>
    </div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd sidebarWithHideableNavbar_wUlq"><a tabindex="-1" class="sidebarLogo_isFc" href="/HXLoLi/"><img src="/HXLoLi/img/logo.png" alt="HXLoLi Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/HXLoLi/img/logo.png" alt="HXLoLi Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"><b>HXLoLi</b></a><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/HXLoLi/docs/关于">关于</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" style="font-size:14px" href="/HXLoLi/docs/计佬常識/数据结构与算法/【algorithm】目録"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">计佬常識</div><div style="flex:1"></div></div></a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/数据结构与算法/【algorithm】目録"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">数据结构与算法</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/设计模式/相关面试题"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">设计模式</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机网络/一、计算机网络基础"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">计算机网络</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/操作系统/とあるOSのインデックス"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">操作系统</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/【计组】目录"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">计算机组成原理</div><div style="flex:1"></div></div></a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/【计组】目录">【计组】目录</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第一章计算机概要与技术/计算机的分类及其特性"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第一章计算机概要与技术</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第二章指令系统/计算机硬件的操作与操作数"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第二章指令系统</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第三章计算机算术运算/定点数加减法"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第三章计算机算术运算</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/MIPS核心子集及实现方式"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第四章中央处理器</div><div style="flex:1"></div></div></a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/MIPS核心子集及实现方式">MIPS核心子集及实现方式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/逻辑设计基础">逻辑设计基础</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/构建一个基本算数逻辑单元">构建一个基本算数逻辑单元</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/逻辑设计的一般方法">逻辑设计的一般方法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/建立一个数据通路">建立一个数据通路</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/实现MIPS子集">实现MIPS子集</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/流水线技术">流水线技术</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/流水线冒险">流水线冒险</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/异常和中断">异常和中断</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第五章存储器/存储器技术"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第五章存储器</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第六章IO设备/外部设备及总线"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第六章IO设备</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第七章并行系统/并行系统"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第七章并行系统</div><div style="flex:1"></div></div></a></div></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/程序语言/C++/【C艹】目录大纲"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">程序语言</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/游戏引擎/虚幻引擎/【虚幻】目录"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">游戏引擎</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/DevOps与版本控制/Linux/【Linux】目录"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">DevOps与版本控制</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/中间件/Redis/【Redis】目录"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">中间件</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/数据库/MySQL数据库/とある「MySQL」の禁庫目録"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">数据库</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/刷题日志/做题记录"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">刷题日志</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/嵌入式/杂项/IC通信"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">嵌入式</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/Game/MineCraft/服务器/脚本"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">Game</div><div style="flex:1"></div></div></a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_z5aJ"><div class="docItemContainer_c0TR"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/HXLoLi/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">计佬常識</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">计算机组成原理</span><meta itemprop="position" content="2"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">第四章中央处理器</span><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">异常和中断</span><meta itemprop="position" content="4"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>异常和中断</h1></header>
<p>异常和中断是处理器用来<span style="color:yellow">处理非预期事件或来自外部设备请求</span>的重要机制。这些机制对于实现稳定的系统行为和高效的I/O通信至关重要。</p>
<p><strong>异常(Exception)</strong></p>
<ul>
<li>
<p>定义: 异常是由处理器内部检测到的错误或特定事件触发的, 例如算术溢出、无效的内存访问、除以零等。</p>
</li>
<li>
<p>处理: 当异常发生时, 处理器会暂停当前指令的执行, 保存当前的状态(如寄存器、程序计数器PC等), 然后跳转到特定的异常处理代码(异常处理程序)去处理这个异常。</p>
</li>
<li>
<p>重要性: 异常处理机制是处理器稳定性的关键, 因为它允许处理器在出现错误时不会崩溃, 而是能够以一种可控的方式响应并尝试恢复或通知用户。</p>
</li>
</ul>
<p><strong>中断(Interrupt)</strong></p>
<ul>
<li>
<p>定义: 中断是由外部设备(如I/O设备)或处理器的内部事件触发的, 用于通知处理器有某个特定的事件需要处理。</p>
</li>
<li>
<p>类型: 中断可以是可屏蔽的(可以被其他中断或处理器内的逻辑禁用)或不可屏蔽的
(必须立即处理)。</p>
</li>
<li>
<p>处理: 当中断发生时, 处理器会保存当前的状态(如寄存器、程序计数器PC等), 然后跳转到特定的中断服务程序(ISR)去处理这个中断。处理完中断后, 处理器会恢复之前的状态并继续执行。</p>
</li>
<li>
<p>重要性: 中断处理机制是处理器与外部设备通信的关键, 它允许处理器在需要时暂停当
前的任务去处理外部事件, 从而提高了系统的响应性和效率。</p>
</li>
</ul>
<p>异常和中断作为控制流中的非顺序转移事件, 对处理器的设计提出了特别的挑战, 主要体现在以下几个方面:</p>
<ol>
<li>
<p><strong>精确性</strong>: 处理器需要能够精确地识别何时发生异常或中断, 并准确记录当前程序状态(如程序计数器PC值、寄存器内容等), 以便在处理完异常或中断后能恢复到正确的执行点继续执行。这要求有高效的上下文保存和恢复机制。</p>
</li>
<li>
<p><strong>及时响应</strong>: 中断尤其是外部中断(如I/O完成、硬件故障等)需要处理器能够迅速响应, 以确保系统的实时性和交互性。这要求处理器设计中有快速的中断处理路径和低延迟的中断服务例程(ISR)执行机制</p>
</li>
<li>
<p><strong>优先级处理</strong>: 在多中断环境下, 处理器需要有能力根据中断的紧急程度或优先级来决定处理顺序, 这就涉及到中断嵌套和优先级仲裁机制的设计。</p>
</li>
<li>
<p><strong>同步与异步事件的统一处理</strong>: 异常通常是程序执行过程中的同步事件(如除零错误), 而中断往往是异步的(如外部输入)。处理器必须设计有机制能够统一高效地处理这两种不同性质的事件。</p>
</li>
<li>
<p><strong>安全性与一致性</strong>: 异常和中断处理过程中要确保内存访问的一致性, 避免数据竞争和一致性问题, 尤其是在多核处理器环境中, 这要求有严格的内存管理策略和一致性协议。</p>
</li>
<li>
<p><strong>兼容性与标准化</strong>: 为了支持操作系统和软件的跨平台运行, 处理器的异常和中断机制需要遵循一定的标准或规范(如x86架构中的中断向量表、ARM架构的异常模型等), 这在设计时也需要考虑进去。</p>
</li>
</ol>
<p>在处理器设计中, 异常处理通常是一个复杂且关键的部分, 因为它需要处理器能够识别、响应并可能地恢复从各种异常情况(如算术溢出、非法指令、访问违规等)中。</p>
<p><strong>关键路径(Critical Path)</strong> 是处理器中决定时钟周期长度的路径。这个路径上的操作必须在一个时钟周期内完成, 否则处理器就需要更长的时钟周期来执行指令, 从而降低性能。检测异常情况并采取适当举措, 通常处于处理器的关键路径上。</p>
<p>异常处理对关键路径的影响主要体现在以下几个方面:</p>
<ol>
<li>性能开销  2. 设计复杂性  3. 实现复杂性</li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="异常处理过程-算术溢出为例">异常处理过程: 算术溢出为例<a href="#异常处理过程-算术溢出为例" class="hash-link" aria-label="异常处理过程: 算术溢出为例的直接链接" title="异常处理过程: 算术溢出为例的直接链接">​</a></h2>
<p>我们使用<code>add $1,$2,$1</code>指令作为例子来探讨算术溢出类型的异常处理时, 我们可以详细解析处理器需要执行的基本步骤。</p>
<p>算术溢出通常发生在加法、减法、乘法等运算中, 结果超出了目标寄存器能表示的范围。</p>
<p>在大多数体系结构中, 比如MIPS或类RISC架构, 处理这种异常的一般流程如下:</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="异常处理过程">异常处理过程<a href="#异常处理过程" class="hash-link" aria-label="异常处理过程的直接链接" title="异常处理过程的直接链接">​</a></h2>
<ol>
<li>
<p><strong>检测异常</strong>: 在执行<code>add$1, $2, $1</code>指令前或执行过程中, 处理器的算术逻辑单元(ARLU)会检查操作结果是否会导致溢出。如果发现有溢出条件, 硬件会生成一个异常信号。</p>
</li>
<li>
<p><strong>保存现场</strong>: 一旦检测到异常, 处理器首先需要保存当前执行状态, 以便异常处理完毕后能恢复到出错前的状态。这通常包括:</p>
<ul>
<li>保存通用寄存器的内容, 特别是那些包含重要数据或指针的寄存器。</li>
<li>保存程序计数器(PC)的值, 即下一条指令的地址。但在算术溢出这类异常中, 更关键的是保存导致异常的指令地址, 因此:</li>
</ul>
</li>
<li>
<p><strong>设置EPC</strong>: 将导致异常的指令地址(即<code>add$1, $2, $1</code>的地址)保存到异常程序计数器(EPC)中。这样, 操作系统在处理完异常后, 可以知道应该从哪里重新开始执行。(后面我们会讲到这个)</p>
</li>
<li>
<p><strong>切换到内核模式</strong>: 为了安全地处理异常, 处理器需要从用户模式切换到内核模式(或称为特权模式、超级用户模式), 这样操作系统可以访问所有资源来妥善处理异常。(到时候操作系统会详细讲这两个状态)</p>
</li>
<li>
<p><strong>跳转到异常处理程序</strong>: 根据异常类型(在这个例子中是算术溢出), 处理器将控制权转移给操作系统预先定义好的异常处理入口点。这个入口地址通常是固定的, 操作系统在此处放置了异常处理代码。</p>
</li>
<li>
<p><strong>异常处理</strong>: 在操作系统层面, 异常处理程序会根据EPC中的地址分析异常原因, 可能执行的操作包括: 记录日志、执行特定的错误恢复操作、或者干脆终止引起异常的任务。7.恢复现场与返回: 异常处理完成后, 操作系统需要恢复之前保存的处理器状态, 包括从EPC中恢复PC值, 从而回到出错前的指令位置或跳转到一个安全的恢复点继续执行。如果异常不能被完全恢复, 则可能会执行进程终止或系统重启等操作。</p>
</li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="操作系统的响应方式">操作系统的响应方式<a href="#操作系统的响应方式" class="hash-link" aria-label="操作系统的响应方式的直接链接" title="操作系统的响应方式的直接链接">​</a></h2>
<p>从以上步骤可以看出, 操作系统在面对算术溢出这类异常时, 需要多种策略来应对, 每种策略的选择取决于异常的性质、程序的要求以及系统的安全策略。我们可以得出操作系统几种响应方式:</p>
<ol>
<li>提供服务或修正操作</li>
<li>警告用户并请求输入</li>
<li>日志记录与监控</li>
<li>终止程序并报告错误</li>
<li>继续执行</li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="异常原因记录">异常原因记录<a href="#异常原因记录" class="hash-link" aria-label="异常原因记录的直接链接" title="异常原因记录的直接链接">​</a></h2>
<p>为了处理异常, 操作系统除了要知道是哪条指令引起异常之外, 还必须知道引起异常的原因。就好像报错bug一样, 要告诉你哪里有问题。主要有两种方法用于表示产生异常的原因:</p>
<ol>
<li>
<p>MIPS架构的Cause寄存器方法在MIPS架构中, 处理异常的一个关键组件是<strong>Cause寄存器</strong>。当异常或中断发生时, 处理器会自动将异常原因编码到Cause寄存器中的特定字段。这个寄存器不仅记录了异常或中断发生的事实, 还精确指明了其原因, 如是否是因为算术错误、地址越界、非法指令等。操作系统随后可以通过读取Cause寄存器来确定具体异常类型, 并采取相应的处理措施。此外, MIPS架构还利用<strong>EPC(ExceptionProgram Counter)寄存器</strong>来保存异常发生时的下一条指令地址, 以便异常处理结束后恢复执行。</p>
</li>
<li>
<p>向量中断方法向量中断是一种经典的异常处理机制, 广泛应用于各种处理器架构中。在这种方法中, 每个异常或中断都有一个预定义的、固定的<strong>中断向量地址</strong>。当异常或中断发生时, 硬件会自动将程序计数器(PC)设置为对应异常或中断类型的向量地址, 从而立即将控制权转移至该地址处的中断服务例程(ISR)。这意味着异常处理的起始点直接由异常或中断的类型决定, 无需通过查询寄存器来确定异常原因, 从而加快了响应速度。</p>
</li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="在流水线中实现的异常-以算数异常为例">在流水线中实现的异常: 以算数异常为例<a href="#在流水线中实现的异常-以算数异常为例" class="hash-link" aria-label="在流水线中实现的异常: 以算数异常为例的直接链接" title="在流水线中实现的异常: 以算数异常为例的直接链接">​</a></h2>
<ol>
<li>
<p><strong>异常识别与响应</strong>: 当检测到算术溢出这类异常时, 首先需要中止当前的指令执行流程, 确保不会因异常而破坏预期的程序状态。</p>
</li>
<li>
<p><strong>流水线清理</strong>:</p>
<ul>
<li>
<p><strong>ID级清理: 通过引入<code>ID.FIush</code>信号</strong></p>
<ul>
<li><strong>目的</strong>: 在指令译码(ID)阶段发现异常需要处理时, 防止该指令及其后续指令继续向下流动, 以免对系统状态造成不必要的影响或错误的改变。</li>
<li><strong>机制</strong>: 通过一个控制信号<code>ID.Flush</code>, 这个信号连接到ID级的多路复用器。当<code>ID.Flush</code>被激活时, 它会阻塞&quot;ID级的输出, 意味着不向前级(如执行阶段)发送任何指令信息。这样, 后续的流水线阶段(如执行、内存访问、写回等)就不会接收到来自当前异常指令的数据或控制信号, 从而避免了潜在的错误传播。</li>
</ul>
</li>
<li>
<p><strong>EX级清理: 使用<code>EX.Flush</code>信号</strong></p>
<ul>
<li><strong>目的</strong>: 在执行(EX)阶段检测到异常时, 确保异常指令的执行结果不会被错误地写回到寄存器文件中, 保护了异常发生前的原始寄存器状态。</li>
<li><strong>机制</strong>: 引入<code>EX.Flush</code>信号, 当它被激活时, 控制执行阶段到寄存器文件的写回路径被关闭。这意味着, 尽管执行阶段可能已经计算出了结果, 但这个结果不会被写回到寄存器中覆盖原有的数据, 从而保护了异常发生前寄存器的值, 这对后续的错误恢复和处理至关重要。</li>
</ul>
</li>
<li>
<p><strong>指令替换: 从异常处理地址开始执行</strong></p>
<ul>
<li><strong>目的</strong>: 确保在异常处理完成后, 能够从异常处理程序的入口地址开始执行, 而不是继续执行原本的指令序列。</li>
<li><strong>机制</strong>: 在程序计数器(PC)的多路复用器中添加一个额外的输入选项, 这个输入对应于异常处理程序的起始地址(例如MIPS中的<code>8000 0180g</code>)。当异常发生时, 通过控制信号选择这个特定的地址作为PC的新值, 从而使流水线从异常处理程序的第一条指令开始取指执行。这个操作有效地&quot;重置&quot;了流水线的取指点, 确保了异常处理流程的正确启动。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>原始数据保护</strong>: 异常处理的一个关键考虑是保护异常发生时的原始数据。通过在EX级检测异常并阻止结果写回(通过<code>EX.Flush</code>), 可以确保目标寄存器中的原始值不受影响, 这对于后续的调试和正确处理异常至关重要。</p>
</li>
<li>
<p><strong>异常处理后重执行</strong>: 许多情况下, 需要在处理完异常后重新执行引起异常的指令。这通常涉及清除该指令、完成异常处理流程, 然后基于EPC寄存器中的地址(已调整为异常前的指令地址)重新取指执行。</p>
</li>
<li>
<p><strong>EPC更新</strong>: 异常处理机制还需负责将引起异常的指令地址(通常是该指令的下一条指令地址, 即PC+4)保存到EPC(Exception Program Counter)寄存器中。这样做是为了在异常处理完毕后能够恢复执行。注意, 由于保存的是&quot;下一条指令&quot;的地址, 异常处理代码在真正处理异常指令之前需要对EPC的值进行调整(减4), 以指向真正的异常源指令。</p>
</li>
</ol>
<p>操作系统与硬件在处理异常时是协同工作的。旨在确保系统的健壮性和稳定性。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="硬件的角色">硬件的角色<a href="#硬件的角色" class="hash-link" aria-label="硬件的角色的直接链接" title="硬件的角色的直接链接">​</a></h2>
<ol>
<li>
<p><strong>暂停指令流</strong>: 一旦检测到异常或中断, 硬件会立刻停止当前指令的执行, 防止错误状态的进一步传播。</p>
</li>
<li>
<p><strong>执行已完成指令</strong>: 在停止当前指令前, 硬件会确保所有已经进入流水线并完成执行的指令其效果得到固化, 这保证了系统状态的一致性。</p>
</li>
<li>
<p><strong>清除后续指令</strong>: 尚未执行或正在执行中的后续指令需要被清除或取消, 确保它们不对系统状态产生影响。</p>
</li>
<li>
<p><strong>设置异常寄存器</strong>: 硬件会设置特定的寄存器(如MIPS架构中的CauSe和EPC寄存器)记录异常原因和发生异常的指令地址, 为操作系统提供必要信息。</p>
</li>
<li>
<p><strong>跳转执行</strong>: 硬件会将控制权转移给操作系统预定义的异常处理程序, 通常是一个特定的地址, 开始执行异常处理流程。</p>
</li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="操作系统的作用">操作系统的作用<a href="#操作系统的作用" class="hash-link" aria-label="操作系统的作用的直接链接" title="操作系统的作用的直接链接">​</a></h2>
<ol>
<li>
<p><strong>异常分析</strong>: 操作系统首先会检查异常寄存器, 确定异常类型, 比如是非法指令、算术溢出、I/0请求还是页面错误。</p>
</li>
<li>
<p><strong>程序终止或恢复</strong>: 对于致命异常(如未定义指令、硬件错误、算术溢出), OS可能会终止引起异常的进程, 并记录错误信息。而对于I/O请求或系统调用, 操作系统会保存当前进程的状态(如寄存器内容、堆栈指针), 执行I/O操作或服务调用, 完成后恢复进程状态, 让其继续执行。</p>
</li>
<li>
<p><strong>任务调度</strong>: 在处理I/O请求时, 操作系统可能利用这段时间调度其他就绪任务执行, 实现并发和资源的有效利用, 这也是现代操作系统多任务处理的关键特性。</p>
</li>
<li>
<p><strong>页缺失处理</strong>: 特别地, 页缺失和TLB(Translation Lookaside Buffer)异常需要操作系统介入, 通过查找页表, 将所需页面从磁盘加载到内存, 更新页表和TLB, 然后重新执行导致异常的指令。</p>
</li>
</ol>
<p><strong>保存和恢复</strong>:</p>
<p>保存和恢复任务状态是异常处理和多任务操作系统的核心机制。它确保了任务可以在中断后从精确的断点恢复, 无论是由于I/O等待、页面错误处理还是响应其他中断。状态的正确保存和恢复是实现程序执行连贯性、系统可靠性和响应性的基础, 同时也是实现高效资源管理和并发执行的前提。</p>
<p>因为流水线的特性使得多条指令同时处于不同的执行阶段, 而异常可能在任意时刻发生。精确异常要求能够准确识别并报告导致异常的具体指令, 即使它与其他正常指令混合在流水线中。这就意味着处理器需要有复杂的机制来跟踪和管理指令的执行状态, 确保异常处理时能够正确地回溯到引起异常的那条指令。</p>
<p><strong>非精确异常(Imprecise Exception)处理机制</strong>则在某些设计中作为一种折衷方案被采用, 特别是在早期或资源受限的处理器中。这种机制在检测到异常时, 可能无法精确指出是哪条指令导致异常, 而是报告一个范围或最近的检查点。因为那条指令可能仍然在流水线的某个阶段中。因此, 处理器可能会将当前程序计数器(PC)的值, 即下一个将要执行的指令的地址, 作为异常程序计数器(EPC)的值。这可能导致操作系统在异常处理时难以准确地确定是哪条指令引起的异常。</p>
<p>MIPS架构以及现今多数高性能处理器追求精确异常处理, 确保了更好的程序调试能力和系统稳定性。它们通过复杂的硬件设计, 如指令流水线的停顿机制、结果转发控制、以及精确的异常报告逻辑, 来实现这一点。这些设计使得处理器能够在异常发生时, 准确地识别异常指令, 并将正确的PC值(即导致异常的指令地址)保存至EPC寄存器中, 从而减轻了操作系统在异常处理上的负担, 并提高了整体系统的确定性和效率。</p>
<h1>指令级并行</h1>
<p>流水线挖掘了指令间潜在的并行性。这种并行性被称为指令级并行 。指令级并行(的两种主要方法:</p>
<ul>
<li>流水线深度的增加(也称为流水线级数的增加)和多发射技术。</li>
</ul>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="超流水线技术-增加流水线深度">超流水线技术: 增加流水线深度<a href="#超流水线技术-增加流水线深度" class="hash-link" aria-label="超流水线技术: 增加流水线深度的直接链接" title="超流水线技术: 增加流水线深度的直接链接">​</a></h2>
<p>首先, 通过增加流水线的阶段数量(即流水线深度), 可以更细粒度地分解指令的执行过程, 使得更多的指令在不同的执行阶段并行处理。在处理器设计中, 这要求每个阶段的时间尽可能相近, 以避免瓶颈, 确保流水线的顺畅运转。增加的流水线深度理论上能够提升吞吐量, 但可能会增加流水线的延迟(即从开始到完成一条指令的时间), 并可能引入了更多控制和数据相关的风险, 需要复杂的解决策略。</p>
<p>但是, 仅仅增加流水线的级数并不一定能提高处理器的性能。为了获得最佳的性能提升, 需要确保所有流水级都有相同的执行时间(即需要“平衡”流水线)。如果某个流水级的执行时间比其他级长得多, 那么整个流水线的性能就会被这个最慢的级所限制(称为“瓶颈”)。</p>
<p><strong>多发射技术</strong>: 是指处理器在每个时钟周期能够同时启动多个指令进入流水线的不同阶段。在处理器设计中, 这意味着拥有多个执行单元(如ALU、浮点运算单元、负载/存储单元等)且它们能够并行工作。通过同时发射多条指令, 处理器能够更充分地利用计算资源, 尤其是在存在指令间独立性较好的代码上, 可以显著提升性能。多发射技术的实现需要先进的指令调度和分配逻辑, 以处理指令间的依赖关系, 确保数据和控制的一致性。</p>
<p>多发射技术可以分为两种类型: <code>静态多发射</code>和<code>动态多发射</code>:</p>
<ul>
<li>
<p><strong>静态多发射(Static Multi-issue)</strong>: 在编译时确定哪些指令可以在同一个时钟周期内并行执行。这通常要求编译器具有足够的智能来识别和利用指令间的并行性。</p>
</li>
<li>
<p><strong>动态多发射(Dynamic Multi-issue)</strong>: 在运行时动态地决定哪些指令可以在同一个时钟周期内并行执行。这通常需要一个复杂的调度器来跟踪指令的依赖性和资源使用情况。多发射技术能够显著提高处理器的性能, 因为它能够同时执行多条指令, 从而提高了指令的吞吐量。然而, 多发射技术也增加了设计的复杂性, 并且需要更多的硬件资源来实现。</p>
</li>
</ul>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="静态多发射-超长指令字技术">静态多发射: 超长指令字技术<a href="#静态多发射-超长指令字技术" class="hash-link" aria-label="静态多发射: 超长指令字技术的直接链接" title="静态多发射: 超长指令字技术的直接链接">​</a></h2>
<p><strong>静态多发射</strong>: 在每个时钟周期内, 处理器能够固定数量的指令同时进入执行单元进行处理, 这个数量在设计时就被预先确定且在运行时不可更改。与之相对的是动态多发射, 后者在每个时钟周期内可以依据实际指令的依赖关系和资源情况动态决定发射指令的数量。</p>
<p>工作原理</p>
<ol>
<li>
<p><strong>指令预处理</strong>: 在执行前, 处理器的前端会对指令进行解码, 分析指令间的依赖关系(数据依赖、控制依赖), 并进行指令调度, 准备好的指令被送入发射队列。</p>
</li>
<li>
<p><strong>固定数量发射</strong>: 在每个时钟周期, 不论当前指令的依赖关系如何, 处理器都会尝试发射预设数量的指令到执行单元。例如, 一个4路静态多发射处理器会在每个周期试图发射4条指令, 如果存在依赖无法满足, 则发射槽位可能空缺或用NOP填充。</p>
</li>
<li>
<p><strong>执行与退休</strong>: 发射出去的指令在各自的执行单元中并行处理, 完成计算后, 若没有数据冲突或异常, 指令将被&quot;退休&quot;, 即更新架构状态(如寄存器、内存)。</p>
</li>
</ol>
<p>特点:</p>
<ul>
<li>设计简单, 可预测性能, 利用率可能不高。</li>
</ul>
<p>局限性:</p>
<ul>
<li>效率问题, 灵活性不足, 资源分配固定。</li>
</ul>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="动态多发射-超标量流水线技术">动态多发射: 超标量流水线技术<a href="#动态多发射-超标量流水线技术" class="hash-link" aria-label="动态多发射: 超标量流水线技术的直接链接" title="动态多发射: 超标量流水线技术的直接链接">​</a></h2>
<p><strong>动态多发射</strong>: 允许处理器在每个时钟周期内根据当前指令的依赖关系和可用资源动态地决定发射指令的数量和类型。</p>
<p>与静态多发射相比, 动态多发射更加灵活和高效, 但同时也带来了更高的设计复杂度。</p>
<p>工作原理</p>
<ol>
<li>
<p><strong>指令预处理与分析</strong>: 首先, 处理器的前端会进行指令预取、解码, 并通过指令调度器分析指令之间的数据依赖(ReadAfterWrite, WriteAfterRead,WriteAfterWrite)和控制依赖。这一阶段还会考虑到指令对资源的需求, 比如ALU、浮点单元、访存单元等。</p>
</li>
<li>
<p><strong>动态资源分配</strong>: 根据当前指令队列中指令的依赖关系和各个执行单元的可用状态, 动态多发射处理器在每个时钟周期内智能地决定可以并行执行多少条指令。如果有足够的资源且没有数据依赖, 处理器可能会发射多条指令; 如果资源紧张或存在依赖, 发射数量则会减少。</p>
</li>
<li>
<p><strong>乱序执行</strong>: 动态多发射通常伴随着乱序执行(Out-of-OrderExecution)机制, 允许理器在不影响程序结果的前提下, 不按程序顺序执行指令, 进一步提高并行度和性能。</p>
</li>
<li>
<p><strong>指令完成与退休</strong>: 当指令执行完毕, 且所有依赖解决, 数据一致性和异常处理完毕, 指令被视为&quot;退休&quot;。这一步会更新架构状态, 如更新寄存器、内存等。</p>
</li>
</ol>
<p>特点:</p>
<ul>
<li>高度灵活性, 高效利用资源, 提高ILP。</li>
</ul>
<p>局限性:</p>
<ul>
<li>设计复杂, 预测错误风险, 功耗问题。</li>
</ul>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="推测技术">推测技术<a href="#推测技术" class="hash-link" aria-label="推测技术的直接链接" title="推测技术的直接链接">​</a></h2>
<p><strong>推测(Speculation)</strong> 用于提高处理器的指令级并行性(ILP)。通过预判未来可能的执行路径来提前执行指令, 从而提升处理器的指令级并行性(ILP), 是现代高性能计算领域的一项重要创新。它既可以在编译器级别实施, 也能在硬件层面实现, 旨在挖掘并行性, 加速程序执行。</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="编译器推测与硬件推测">编译器推测与硬件推测<a href="#编译器推测与硬件推测" class="hash-link" aria-label="编译器推测与硬件推测的直接链接" title="编译器推测与硬件推测的直接链接">​</a></h3>
<ul>
<li>
<p><strong>编译器推测</strong>: 在编译阶段, 编译器通过分析代码结构, 重排指令顺序, 如提前执行分支后的指令(基于分支预测)或交换load与store指令(假设地址不冲突), 以提升并行度。这种推测可能需要插入验证推测正确性的额外检查代码, 并准备好错误恢复逻辑。</p>
</li>
<li>
<p><strong>硬件推测</strong>: 处理器在运行时动态实施推测, 如分支预测、乱序执行、store-load转发等, 硬件会缓存推测结果, 直到确定推测正确与否。错误推测会导致缓存的清除和指令的重新执行。硬件还需处理推测引发的异常管理, 确保仅在推测指令实际被执行时才触发异常处理。</p>
</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="静态与动态推测技术">静态与动态推测技术<a href="#静态与动态推测技术" class="hash-link" aria-label="静态与动态推测技术的直接链接" title="静态与动态推测技术的直接链接">​</a></h3>
<ul>
<li>
<p><strong>静态推测</strong>: 编译器在编译时进行的推测。它基于代码的静态分析, 识别出可以进行推测的指令或代码段, 并对它们进行优化。静态推测的优点是可以在编译时完成大部分工作, 减少运行时的开销; 缺点是它无法适应程序运行时的动态变化。</p>
</li>
<li>
<p><strong>动态推测</strong>: 处理器在运行时进行的推测。它基于处理器的状态和程序的动态行为, 动态地决定哪些指令可以进行推测。动态推测的优点是能够适应程序的动态变化, 提高推测的准确性; 缺点是增加了处理器的复杂性和功耗。</p>
</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="错误恢复机制">错误恢复机制<a href="#错误恢复机制" class="hash-link" aria-label="错误恢复机制的直接链接" title="错误恢复机制的直接链接">​</a></h3>
<ul>
<li>
<p><strong>软件层面</strong>: 编译器插入的检查点和修复代码用于验证推测的正确性, 如果推测错误, 则执行特定的回退逻辑, 恢复到正确状态, 这可能涉及指令的重执行和状态的回滚。</p>
</li>
<li>
<p><strong>硬件层面</strong>: 处理器通过保留推测执行的状态, 如使用保留站(ReservationStations)、重命名寄存器等机制, 来快速响应推测错误。一旦推测被证明错误, 硬件会撤销错误的执行效果, 恢复到正确状态, 并重新执行正确的指令序列。</p>
</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="推测引发的异常处理">推测引发的异常处理<a href="#推测引发的异常处理" class="hash-link" aria-label="推测引发的异常处理的直接链接" title="推测引发的异常处理的直接链接">​</a></h3>
<ul>
<li>
<p><strong>异常的不当触发</strong>: 推测执行可能导致本不应发生的异常, 如非法地址访问。这要求有机制区分推测执行时的异常与实际执行时的异常。</p>
</li>
<li>
<p><strong>编译器处理</strong>: 通过更复杂的推测逻辑, 暂时忽略在推测阶段产生的异常, 直至确认异常确实发生。</p>
</li>
<li>
<p><strong>硬件处理</strong>: 硬件缓存异常状态, 直到推测指令确定被执行。若推测正确, 则正常处理异常; 若推测错误, 异常被忽略, 避免误报。</p>
</li>
</ul>
<p>处理器设计经历了从指令集结构和工艺技术出发, 到流水线和多发射技术的应用, 再到面对功耗墙转向多处理器并行, 最终面临存储器层次挑战的演变过程。这一系列发展体现了计算机体系结构不断寻求性能提升的探索和优化路径, 以及解决随之而来的新问题的历程。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/HengXin666/HXLoLi/edit/main/docs/001-计佬常識/005-计算机组成原理/005-第四章中央处理器/009-异常和中断/index.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"><span class="theme-last-updated">最后<!-- -->由 <b>Heng_Xin_666</b> <!-- -->于 <b><time datetime="2025-04-28T14:52:39.000Z" itemprop="dateModified">2025年4月28日</time></b> <!-- -->更新</span></div></div></footer></article><div style="display:flex;justify-content:flex-end;margin-top:20px">请作者喝奶茶:<div class="icon-container" style="margin-left:10px"><img src="/HXLoLi//default-icons/alipay.svg" alt="Alipay Icon" class="icon"><img src="/HXLoLi//img/alipay_qr_code.png" alt="QR Code" class="qr-code"></div><div class="icon-container" style="margin-left:10px"><img src="/HXLoLi//default-icons/wechat.svg" alt="Alipay Icon" class="icon"><img src="/HXLoLi//img/wechat_qr_code.png" alt="QR Code" class="qr-code"></div></div><div style="display:flex;justify-content:flex-end"><span style="font-size:12px">本文遵循 <img src="/HXLoLi//default-icons/cc.svg" alt="CC" style="width:14px"> <span class="tailwind"><a href="https://creativecommons.org/licenses/by-sa/4.0/" class="relative inline-block transition-all duration-300 text-fuchsia-400 hover:text-pink-700" target="_blank" rel="noopener noreferrer">CC 4.0 BY-SA<span class="absolute right-0 bottom-0 h-0.5 bg-purple-700 w-0 transition-all duration-500"></span><span class="absolute left-0 bottom-0 h-0.5 bg-purple-700 w-0"></span></a></span> 版权协议, 转载请标明出处</span></div><div><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/流水线冒险"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">流水线冒险</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/HXLoLi/docs/计佬常識/计算机组成原理/第五章存储器/存储器技术"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">存储器技术</div></a></nav></div></div><div>Loading Comments...</div></div><div class="col col--3"><div class="tableOfContents_jeP5 thin-scrollbar theme-doc-toc-desktop"><div class="tailwind"><div class="text-fuchsia-400" style="border-left:1px solid var(--ifm-toc-border-color)"><div class="ml-4 -mb-2" style="border-bottom:1.5px solid var(--ifm-toc-border-color)">0<!-- -->%</div></div></div><ul class="table-of-contents table-of-contents__left-border"><li><a href="#异常处理过程-算术溢出为例" class="table-of-contents__link toc-highlight">异常处理过程: 算术溢出为例</a></li><li><a href="#异常处理过程" class="table-of-contents__link toc-highlight">异常处理过程</a></li><li><a href="#操作系统的响应方式" class="table-of-contents__link toc-highlight">操作系统的响应方式</a></li><li><a href="#异常原因记录" class="table-of-contents__link toc-highlight">异常原因记录</a></li><li><a href="#在流水线中实现的异常-以算数异常为例" class="table-of-contents__link toc-highlight">在流水线中实现的异常: 以算数异常为例</a></li><li><a href="#硬件的角色" class="table-of-contents__link toc-highlight">硬件的角色</a></li><li><a href="#操作系统的作用" class="table-of-contents__link toc-highlight">操作系统的作用</a></li><li><a href="#超流水线技术-增加流水线深度" class="table-of-contents__link toc-highlight">超流水线技术: 增加流水线深度</a></li><li><a href="#静态多发射-超长指令字技术" class="table-of-contents__link toc-highlight">静态多发射: 超长指令字技术</a></li><li><a href="#动态多发射-超标量流水线技术" class="table-of-contents__link toc-highlight">动态多发射: 超标量流水线技术</a></li><li><a href="#推测技术" class="table-of-contents__link toc-highlight">推测技术</a><ul><li><a href="#编译器推测与硬件推测" class="table-of-contents__link toc-highlight">编译器推测与硬件推测</a></li><li><a href="#静态与动态推测技术" class="table-of-contents__link toc-highlight">静态与动态推测技术</a></li><li><a href="#错误恢复机制" class="table-of-contents__link toc-highlight">错误恢复机制</a></li><li><a href="#推测引发的异常处理" class="table-of-contents__link toc-highlight">推测引发的异常处理</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/HengXin666/HXLoLi" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item">
                <a href="https://docusaurus.io" target="_blank" rel="noreferrer noopener">
                  <img src="/HXLoLi/default-img/buildwith.png" alt="build with docusaurus" width="120" height="50">
                </a>
                </li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">版权所有 © 2025 - 2025 HXLoLi, Inc. 由 Docusaurus 构建.</div></div></div></footer></div>
<div>
    <div id="graph-overlay"></div>
    <div id="graph-container">
      <div id="close-graph-btn" onclick="closeGraph()">
        <div style="padding: 5px">X</div>
      </div>
      <div>
        <h1 style="text-align: center">Graph View</h1>
        <div id="graphview-container" style="display: inline-block;margin: 0 auto"></div>
      </div>
    </div>
    </div>
<script>let graphViewGlobal=null,isOpen=!1;async function initGraphView(){const e=await(await fetch("/docusaurus-graph.json")).json(),n=new NOTE_GRAPH.NoteGraphModel(e);graphViewGlobal=new NOTE_GRAPH.NoteGraphView({container:document.getElementById("graphview-container"),graphModel:n,enableNodeDrag:!0,width:800,height:600})}window.onload=function(){initGraphView()};const graphContainer=document.getElementById("graph-container"),graphOverlay=document.getElementById("graph-overlay");function closeGraph(){graphContainer.style.display="none",graphOverlay.style.display="none"}function openGraph(){!0===isOpen?(closeGraph(),isOpen=!1):window.innerWidth>=800&&window.innerHeight>=720?(graphContainer.style.display="block",graphOverlay.style.display="block",graphViewGlobal.forceGraph.zoomToFit(1e3,20),isOpen=!0):alert("Your screen size must be greater than 800x720.")}graphOverlay.addEventListener("click",closeGraph)</script></body>
</html>