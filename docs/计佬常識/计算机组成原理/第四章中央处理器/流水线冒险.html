<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-计佬常識/计算机组成原理/第四章中央处理器/流水线冒险/index" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">流水线冒险 | HXLoLi</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://HengXin666.github.io/HXLoLi/img/logo.png"><meta data-rh="true" name="twitter:image" content="https://HengXin666.github.io/HXLoLi/img/logo.png"><meta data-rh="true" property="og:url" content="https://HengXin666.github.io/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/流水线冒险"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="流水线冒险 | HXLoLi"><meta data-rh="true" name="description" content="流水线冒险(Pipeline Hazards) 是指在流水线处理器中, 当前级流水线的指令可能会阻止下一条连续指令在流水线中预期的时钟周期内执行的情况。这会引起流水线阻塞或停顿(stall), 导致流水线的性能下降, 降低流水化所带来的理想加速比。"><meta data-rh="true" property="og:description" content="流水线冒险(Pipeline Hazards) 是指在流水线处理器中, 当前级流水线的指令可能会阻止下一条连续指令在流水线中预期的时钟周期内执行的情况。这会引起流水线阻塞或停顿(stall), 导致流水线的性能下降, 降低流水化所带来的理想加速比。"><link data-rh="true" rel="icon" href="/HXLoLi/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://HengXin666.github.io/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/流水线冒险"><link data-rh="true" rel="alternate" href="https://HengXin666.github.io/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/流水线冒险" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://HengXin666.github.io/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/流水线冒险" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/HXLoLi/blog/rss.xml" title="HXLoLi RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/HXLoLi/blog/atom.xml" title="HXLoLi Atom Feed">





<script src="https://cdn.jsdelivr.net/npm/d3@6.2.0/dist/d3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/force-graph@1.40.3/dist/force-graph.js"></script>
<script src="https://cdn.jsdelivr.net/npm/note-graph@latest/dist/note-graph.umd.js"></script><link rel="stylesheet" href="/HXLoLi/assets/css/styles.38e40bb0.css">
<script src="/HXLoLi/assets/js/runtime~main.915a4d70.js" defer="defer"></script>
<script src="/HXLoLi/assets/js/main.a9c6d754.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script>

<style>
  #open-graph-btn {
    align-items: center;
    display: flex;
    justify-content: center;
    width: 100%;
    height: 100%;
    background: none;
    border: none;
    cursor: pointer;
    font-family: inherit;
    padding: 0;
    color: var(--ifm-navbar-link-color);
    transition: color var(--ifm-transition-fast) var(--ifm-transition-timing-default);
  }

  #open-graph-btn:hover {
    color: var(--ifm-link-color);
  }

  @media screen and (max-width: 996px) {
    #open-graph-btn {
      justify-content: flex-start;
      padding-left: 1em;
    }
  }

  #graph-container {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 20px;
    background-color: var(--ifm-background-surface-color);
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    z-index: 2;
  }

  #graph-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(5px);
    z-index: 1;
  }

  #close-graph-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      cursor: pointer;
      font-size: small;
      font-weight: bold;
      z-index: 2;
    }

    canvas {
      margin: 0px auto;
    }

    .force-graph-container .graph-tooltip {
      transform: none !important;
    }
  </style><div id="__docusaurus"><link rel="preload" as="image" href="/HXLoLi/img/logo.png"><link rel="preload" as="image" href="/HXLoLi/default-icons/default_folder.svg"><link rel="preload" as="image" href="/HXLoLi//default-icons/alipay.svg"><link rel="preload" as="image" href="/HXLoLi//img/alipay_qr_code.png"><link rel="preload" as="image" href="/HXLoLi//default-icons/wechat.svg"><link rel="preload" as="image" href="/HXLoLi//img/wechat_qr_code.png"><link rel="preload" as="image" href="/HXLoLi//default-icons/cc.svg"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/HXLoLi/"><div class="navbar__logo"><img src="/HXLoLi/img/logo.png" alt="HXLoLi Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/HXLoLi/img/logo.png" alt="HXLoLi Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">HXLoLi</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/HXLoLi/docs/计佬常識/数据结构与算法/【algorithm】目録">笔记</a><a class="navbar__item navbar__link" href="/HXLoLi/blog">博客</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">更多</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/HXLoLi/blog/archive">归档</a></li></ul></div><a href="https://github.com/HengXin666/HXLoLi" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="navbar__item">
    <button id="open-graph-btn" title="Show Graph Visualisation" type="button" aria-label="Show Graph Visualisation" aria-live="polite" onclick="openGraph()">
      <svg viewBox="0 0 1024 1024" width="24" height="24" fill="currentColor">
        <path d="M512 512m-125.866667 0a125.866667 125.866667 0 1 0 251.733334 0 125.866667 125.866667 0 1 0-251.733334 0Z"></path>
        <path d="M512 251.733333m-72.533333 0a72.533333 72.533333 0 1 0 145.066666 0 72.533333 72.533333 0 1 0-145.066666 0Z"></path>
        <path d="M614.4 238.933333c0 4.266667 2.133333 8.533333 2.133333 12.8 0 19.2-4.266667 36.266667-12.8 51.2 81.066667 36.266667 138.666667 117.333333 138.666667 211.2C742.4 640 640 744.533333 512 744.533333s-230.4-106.666667-230.4-232.533333c0-93.866667 57.6-174.933333 138.666667-211.2-8.533333-14.933333-12.8-32-12.8-51.2 0-4.266667 0-8.533333 2.133333-12.8-110.933333 42.666667-189.866667 147.2-189.866667 273.066667 0 160 130.133333 292.266667 292.266667 292.266666S804.266667 672 804.266667 512c0-123.733333-78.933333-230.4-189.866667-273.066667z"></path>
        <path d="M168.533333 785.066667m-72.533333 0a72.533333 72.533333 0 1 0 145.066667 0 72.533333 72.533333 0 1 0-145.066667 0Z"></path>
        <path d="M896 712.533333m-61.866667 0a61.866667 61.866667 0 1 0 123.733334 0 61.866667 61.866667 0 1 0-123.733334 0Z"></path>
        <path d="M825.6 772.266667c-74.666667 89.6-187.733333 147.2-313.6 147.2-93.866667 0-181.333333-32-249.6-87.466667-10.666667 19.2-25.6 34.133333-44.8 44.8C298.666667 942.933333 401.066667 981.333333 512 981.333333c149.333333 0 281.6-70.4 366.933333-177.066666-21.333333-4.266667-40.533333-17.066667-53.333333-32zM142.933333 684.8c-25.6-53.333333-38.4-110.933333-38.4-172.8C104.533333 288 288 104.533333 512 104.533333S919.466667 288 919.466667 512c0 36.266667-6.4 72.533333-14.933334 106.666667 23.466667 2.133333 42.666667 10.666667 57.6 25.6 12.8-42.666667 19.2-87.466667 19.2-132.266667 0-258.133333-211.2-469.333333-469.333333-469.333333S42.666667 253.866667 42.666667 512c0 74.666667 17.066667 142.933333 46.933333 204.8 14.933333-14.933333 32-27.733333 53.333333-32z"></path>
      </svg>
      <span class="graph-only" style="margin-left: 1rem; font-size: 1rem">Graph View</span>
    </button>
    <style>
    @media only screen and (min-width: 997px) {
      .graph-only {
        display: none;
      }
    }
    </style>
    </div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd sidebarWithHideableNavbar_wUlq"><a tabindex="-1" class="sidebarLogo_isFc" href="/HXLoLi/"><img src="/HXLoLi/img/logo.png" alt="HXLoLi Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/HXLoLi/img/logo.png" alt="HXLoLi Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"><b>HXLoLi</b></a><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" style="font-size:14px" href="/HXLoLi/docs/计佬常識/数据结构与算法/【algorithm】目録"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">计佬常識</div><div style="flex:1"></div></div></a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/数据结构与算法/【algorithm】目録"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">数据结构与算法</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/设计模式/相关面试题"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">设计模式</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机网络/一、计算机网络基础"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">计算机网络</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/操作系统/とあるOSのインデックス"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">操作系统</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/【计组】目录"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">计算机组成原理</div><div style="flex:1"></div></div></a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/【计组】目录">【计组】目录</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第一章计算机概要与技术/计算机的分类及其特性"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第一章计算机概要与技术</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第二章指令系统/计算机硬件的操作与操作数"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第二章指令系统</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第三章计算机算术运算/定点数加减法"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第三章计算机算术运算</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/MIPS核心子集及实现方式"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第四章中央处理器</div><div style="flex:1"></div></div></a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/MIPS核心子集及实现方式">MIPS核心子集及实现方式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/逻辑设计基础">逻辑设计基础</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/构建一个基本算数逻辑单元">构建一个基本算数逻辑单元</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/逻辑设计的一般方法">逻辑设计的一般方法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/建立一个数据通路">建立一个数据通路</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/实现MIPS子集">实现MIPS子集</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/流水线技术">流水线技术</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/流水线冒险">流水线冒险</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/异常和中断">异常和中断</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第五章存储器/存储器技术"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第五章存储器</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第六章IO设备/外部设备及总线"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第六章IO设备</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" tabindex="0" href="/HXLoLi/docs/计佬常識/计算机组成原理/第七章并行系统/并行系统"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">第七章并行系统</div><div style="flex:1"></div></div></a></div></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/程序语言/C++/【C艹】目录大纲"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">程序语言</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/游戏引擎/虚幻引擎/【虚幻】目录"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">游戏引擎</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/DevOps与版本控制/Linux/【Linux】目录"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">DevOps与版本控制</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/中间件/Redis/【Redis】目录"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">中间件</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/数据库/MySQL数据库/とある「MySQL」の禁庫目録"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">数据库</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/刷题日志/做题记录"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">刷题日志</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/嵌入式/杂项/IC通信"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">嵌入式</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" style="font-size:14px" href="/HXLoLi/docs/Game/MineCraft/服务器/脚本"><img src="/HXLoLi/default-icons/default_folder.svg" style="width:20px;margin-right:5px"><div style="display:flex;flex-direction:column"><div style="flex:1">Game</div><div style="flex:1"></div></div></a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/HXLoLi/docs/关于">关于</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_z5aJ"><div class="docItemContainer_c0TR"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/HXLoLi/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">计佬常識</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">计算机组成原理</span><meta itemprop="position" content="2"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">第四章中央处理器</span><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">流水线冒险</span><meta itemprop="position" content="4"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>流水线冒险</h1></header>
<p><strong>流水线冒险(Pipeline Hazards)</strong> 是指在流水线处理器中, 当前级流水线的指令可能会阻止下一条连续指令在流水线中预期的时钟周期内执行的情况。这会引起流水线阻塞或停顿(stall), 导致流水线的性能下降, 降低流水化所带来的理想加速比。</p>
<p>流水线冒险主要分为三种类型:</p>
<ul>
<li>结构冒险(Structural Hazards)、</li>
<li>数据冒险(DataHazards)、</li>
<li>控制冒险(Control Hazards)。</li>
</ul>
<p>以下分别介绍其原因和对策。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="结构冒险资源冲突">结构冒险(资源冲突)<a href="#结构冒险资源冲突" class="hash-link" aria-label="结构冒险(资源冲突)的直接链接" title="结构冒险(资源冲突)的直接链接">​</a></h2>
<p>当<span style="color:red"><strong>硬件资源</strong>不足以支持多条指令在同一时钟周期内并行执行时</span>, 会发生<strong>结构冒险</strong>, 也称为<strong>硬件资源冲突</strong>。</p>
<p>比如, 如果MIPS流水线设计只使用了一个存储器来同时处理指令预取(IF阶段)和数据存取(MEM阶段), 那么当指令预取和数据存取尝试在<strong>同一时钟周期内访问存储器</strong>时, 就会发生结构冒险。这是因为存储器在同一时间只能进行一个操作(读取指令或读写数据)。</p>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-07_22-40-27.png ##w600##" src="/HXLoLi/assets/images/Clip_2024-07-07_22-40-27-4b585cf76b1c03d4fae906a95c92520e.png" width="1136" height="569" style="width:600px"></td></tr></tbody></table>
<p>解决方案:</p>
<p>MIPS(以及许多其他处理器架构)采用了<strong>分离的程序存储器和数据存储器</strong>。这意味着指令预取(IF阶段)从程序存储器(通常是高速缓存)中读取指令, 而数据存取(MEM阶段)从数据存储器(如主存或数据高速缓存)中读写数据。这两个存储器可以独立工作, 从而避免了结构冒险。(即<code>有钱堆硬件</code>)</p>
<p>或者, 前一指令访存时, 使<strong>后一条</strong>冲突的指令(及其后续指令)<strong>暂停延后一个周期</strong>。</p>
<p>我们还有其他的方法, 比如</p>
<ul>
<li>
<p><strong>资源分配逻辑</strong>: 通过复杂的资源分配逻辑来调度和管理不同指令对共享硬件资源的使用, 确保在任何给定时刻不会有冲突发生。</p>
</li>
<li>
<p><strong>重排序缓冲区</strong>: 在更高级的设计中, 可能会使用重排序缓冲区来临时存放结果, 直到所有依赖项准备好, 以此来缓解资源竞争。</p>
</li>
</ul>
<p>通过这些设计策略, MIPS和其他现代处理器架构能够有效地减少甚至消除结构冒险, 保证流水线的顺畅执行, 从而提升处理器的性能和效率。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="数据冒险数据冲突">数据冒险(数据冲突)<a href="#数据冒险数据冲突" class="hash-link" aria-label="数据冒险(数据冲突)的直接链接" title="数据冒险(数据冲突)的直接链接">​</a></h2>
<p><strong>数据冒险</strong> 是流水线处理器中一种常见的冒险情况, 它发生在<strong>当前指令</strong>需要<strong>等待之前指令的结果</strong>才能继续执行时。这通常是因为当前指令的操作数(即源操作数)是之前某条指令的目标操作数(即目的操作数)。</p>
<p>在流水线处理器中, 指令是按照一定的顺序在流水线的不同阶段中并行执行的。如果后一条指令依赖于前一条指令的结果, 而前一条指令的结果尚未产生(或尚未写入到目标位置), 那么后一条指令的执行就会受到阻碍, 从而导致流水线暂停或“停顿”(stall)。这种数据冒险也称为“写后读”(RAW)</p>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-07_22-51-11.png ##w600##" src="/HXLoLi/assets/images/Clip_2024-07-07_22-51-11-93adaeaeeba3cb885d5a5b092848d5c6.png" width="1151" height="518" style="width:600px"></td></tr></tbody></table>
<p>在这个例子中, 流水线在第三个、第四个和第五个时钟周期中对于减法指令来说是无效的, 因为它在等待加法指令的结果。这浪费了三个时钟周期。</p>
<p>为了解决这种数据冒险问题, 现代处理器使用了多种技术, 其中之一就是<strong>数据前递</strong>(也称为<code>数据旁路</code>或数据前推)。</p>
<p>这种方法允许在指令的正式写回寄存器之前, 其产生的数据被后续指令直接使用。在我们给出的例子中, 一旦ALU完成了加法运算并产生了结果, 这个结果可以直接“前递”给接下来需要它的减法指令, 而无需等待加法结果完全写回到寄存器<code>$s0</code>中。</p>
<p>数据前递的工作流程大致如下:</p>
<ol>
<li>
<p><strong>检测冒险</strong>: 处理器的控制单元监测到即将发生的RAW(Read-After-Write)数据冒险, 即下一个指令依赖于前一个指令还未完成的计算结果。</p>
</li>
<li>
<p><strong>数据准备</strong>: 当加法指令在执行阶段或者更早的适合阶段产生结果时, 这个结果被临时保存, 并准备好前递。</p>
</li>
<li>
<p><strong>前递执行</strong>: 在减法指令的执行阶段, 而不是等待<code>$s0</code>寄存器更新, 处理器直接从前递路径获取加法的结果, 并用于减法运算的输入, 从而避免了流水线停滞。</p>
</li>
<li>
<p><strong>正式写回(可选顺序)</strong>: 加法的结果可能在减法指令利用它之后或者同时写回到<code>$s0</code>寄存器中, 具体依处理器设计而异。</p>
</li>
</ol>
<p>通过数据前递技术, <strong>处理器能够减少因数据冒险导致的流水线停顿</strong>, 提高了指令执行的并行度和整体效率。这是现代处理器设计中非常关键的一项优化技术, 对于保持高性能计算至关重要。</p>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-07_22-56-43.png ##w800##" src="/HXLoLi/assets/images/Clip_2024-07-07_22-56-43-524926f016f8c4b371d92af371755c60.png" width="1685" height="892" style="width:800px"></td></tr></tbody></table>
<p>尽管旁路可以改善流水线性能, 但它<span style="color:yellow">仍然不能完全避免流水线阻塞</span>的问题。</p>
<p>例如, 如果第一条指令是装载(lw)指令, 那么它需要从存储器中读取数据, 这会导致数据依赖问题, 因为装载指令的执行阶段(EX)比下一条指令的译码/寄存器读取阶段(ID)晚, 所以无法实现旁路, 从而导致流水线阻塞。</p>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-07_22-58-07.png ##w700##" src="/HXLoLi/assets/images/Clip_2024-07-07_22-58-07-0c2312f1ee9fc4224928258bf7cd8942.png" width="1329" height="452" style="width:700px"></td></tr></tbody></table>
<p>尽管使用了旁路(Forwarding)机制, 但在<code>lw</code>指令的MEM阶段(即数据从内存加载到寄存器)之前, <code>sub</code>指令无法使用<code>$s0</code>中的数据。因此, 流水线不得不阻塞一个或多个步骤, 等待<code>lw</code>指令完成其MEM阶段并将数据写入<code>$s0</code>。这种阻塞在流水线中形成了一个“气泡”(Bubble), 表示在该步骤中没有有效的指令执行。</p>
<p>(在硬件上采取措施,使相关指令延迟执行, 通过 <strong>硬件阻塞(stall)</strong> 方式阻止后续指令执行。这种硬件阻塞的方式称为“插人气泡”)</p>
<p>所以, 在遇到 <strong>取数-使用型数据冒险(load-use data hazard)</strong> 时, 即使采用了旁路机制, 流水线也不得不阻塞一个或多个步骤来等待数据准备好。这是因为<span style="color:yellow">从存储器访问的输出到执行级的输入之间的路径在时间上必须是<code>顺序</code>的, 而不是倒着的。</span>为了避免这种情况, 处理器通常会采用硬件和软件的解决方案, 例如硬件的转发机制和软件的指令重新排序。</p>
<hr>
<p>前面我们讲了四个指令集的设计原则, 从旁路(Bypassing)机制中, 我们可以引申出MIPS体系结构指令集的另一个重要设计原则: 每条MIPS指令<strong>最多只写一个结果</strong>, 并且在流水线的<strong>最后一级</strong>执行。</p>
<p>这个原则是基于流水线处理中数据依赖和冒险的考虑。在流水线处理中, 如果一条指令需要等待前一条指令的结果才能继续执行(即存在数据依赖), 那么流水线就会阻塞, 导致性能下降。为了避免这种情况, MIPS指令集设计确保每条指令最多只写一个结果, 并且这个写操作发生在流水线的最后一级(即写回阶段)</p>
<p>这样做的好处是:</p>
<ol>
<li>简化旁路设计</li>
<li>减少数据冒险</li>
<li>提高指令并行性</li>
</ol>
<p>综合来看, 数据冒险主要有以下几种类型:</p>
<ol>
<li>
<p>【常见】<strong>写后读冒险(RAW, Read-After-WriteHazard)</strong>: 这是最常见的数据冒险类型, 即后继指令需要读取一个寄存器的值, 而这个寄存器正好是先行指令即将写入的。例如, 如果指令2需要使用指令1计算后写入寄存器R1的值, 但在指令1的写回操作完成前, 指令2就开始读取R1, 就会发生RAW冒险。</p>
</li>
<li>
<p><strong>读后写冒险(WAR,Write-After-ReadHazard)</strong>: 虽然在大多数现代处理器设计中不太常见, 这种冒险发生在当一条指令尝试写入一个寄存器, 而之前另一条指令已经读取了这个寄存器的值。理论上, 这不会影响计算结果, 但在某些特定设计中可能需要处理以保持一致性。</p>
</li>
<li>
<p><strong>写后写冒险(WAW, Write-After-WriteHazard)</strong>: 当两条指令尝试写入同一个寄存器, 且后写的指令不关心前一个写入的值时, 这通常需要处理器确保写操作的顺序以维护数据的一致性。</p>
</li>
</ol>
<p>至此, 我们已经看到了数据冒险是什么样子。现在, 我们再来看一个实际程序中的情况。</p>
<div class="language-MIPS language-mips codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-mips codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">sub $2, $1, $3</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">and $12, $2, $5</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">or $13, $6, $2</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">add $14, $2, $2</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">sw $15, 100($2)</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">MIPS</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>如果<code>$2</code>初始值为<code>10</code>, <code>$1</code>的值为<code>30</code>, 则执行后<code>$2</code>的值变为<code>-20</code>。后续指令在执行时都会看到这个值, 也就是都依赖于第一步产生的<code>-20</code>, 这个指令在流水线中是如何执行的呢?</p>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-07_23-07-49.png ##w700##" src="/HXLoLi/assets/images/Clip_2024-07-07_23-07-49-768aa0542a3ca5c1f2e39b8bd9d4937d.png" width="1344" height="851" style="width:700px"></td></tr></tbody></table>
<p>其中, 中间这些类似隔板一样的东西是流水线寄存器, 即:</p>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-07_23-11-12.png ##w800##" src="/HXLoLi/assets/images/Clip_2024-07-07_23-11-12-974adb759e403eb7c591b69c7c41389e.png" width="1523" height="846" style="width:800px"></td></tr></tbody></table>
<p>在流水化处理器中, 如果要将中间结果从一级传送到另外一级, 而源寄存器与目标地址可能并非直接相邻, 这时候就是流水线寄存器发挥作用的时候了。例如: 要在存储指令中存储的寄存器值是在ID期间进行读取的, 但要等到MEM才会真正用到; 他在MEM级中通过两个流水线寄存器传送到数据寄存器。于此类似, ALU指令的结果是在EX期间计算的, 但要等到WB才会实际存储;</p>
<p>所以有必要对每个寄存器进行命名, 称为: IF/ID, ID/EX, EX/MEM, MEM/WB。</p>
<p><strong>同一时间读写</strong>:</p>
<p>这里还有一个潜在的问题, 就是<code>add</code>的第五个周期, <span style="color:red">当一个寄存器在同一时钟周期内同时读和写时</span>会发生什么呢？理论上如果寄存器<code>写操作</code>安排在时钟周期的<code>前半段</code>完成, 而<code>读操作</code>紧接着在同一个时钟周期的<code>后半段</code>进行, 可以确保读操作能获取到最新的写入值, 从而避免了数据(和结构)冒险。</p>
<p>为了实现这种设计, 通常涉及到以下几点关键实现:</p>
<ol>
<li>寄存器更新的时机</li>
<li>寄存器的多端口设计 (结构冒险)</li>
<li>旁路技术的补充</li>
<li>控制逻辑的复杂性</li>
</ol>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="冒险检测-流水线寄存器">冒险检测: 流水线寄存器<a href="#冒险检测-流水线寄存器" class="hash-link" aria-label="冒险检测: 流水线寄存器的直接链接" title="冒险检测: 流水线寄存器的直接链接">​</a></h3>
<p>一种用于精确描述处理器流水线中数据冒险条件的技术是流水线寄存器。它利用流水线寄存器的特定字段来识别和解决潜在的数据相关性问题。这种表述方式有助于深入理解和分析处理器流水线的内部工作原理, 特别是在设计含有复杂控制逻辑和数据依赖关系的现代处理器时。就类似写<code>if..else</code>一样, 我们把条件整理好。这样他在运行的时候就可以进行检测了。</p>
<p>有哪些条件呢？</p>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-08_22-43-05.png ##w700##" src="/HXLoLi/assets/images/Clip_2024-07-08_22-43-05-e9667365ae239f610000c11a93895a7c.png" width="1474" height="620" style="width:700px"></td></tr></tbody></table>
<p>冒险条件:</p>
<ol>
<li>
<p><code>EX/MEM</code>.Register<code>Rd</code> = <code>ID/EX</code>.Register<code>Rs</code></p>
<p><code>EX/MEM</code>.Register<code>Rd</code> = <code>ID/EX</code>.Register<code>Rt</code></p>
</li>
<li>
<p><code>MEM/WB</code>.Register<code>Rd</code> = <code>ID/EX</code>.Register<code>Rs</code></p>
<p><code>MEM/WB</code>.Register<code>Rd</code> = <code>ID/EX</code>.Register<code>Rt</code></p>
</li>
</ol>
<p>其实本质上就对应了我们之前说过的那几种数据冒险的方式。</p>
<p>说回我们刚才得例子, 在这个例子中, <code>sub $2,$1,$3</code>指令的结果将在完成计算后被存储在寄存器<code>$2</code>中, 而<code>and $12,$2,$5</code>指令需要读取寄存器<code>$2</code>作为其一个操作数。
当<code>sub $2,$1,$3</code>指令处于 MEM 阶段(准备将其结果写回寄存器<code>$2</code>)时, <code>and $12,$2,$5</code>指令可能正处于 EX阶段(准备读取寄存器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo stretchy="false">)</mo><mtext>。如果流水线继续不进行任何处理</mtext><mo separator="true">,</mo><mtext>那么</mtext><mi mathvariant="normal">‘</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">‘</mi><mtext>指令可能会读取到</mtext><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">2)。如果流水线继续不进行任何处理, 那么`and`指令可能会读取到`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord cjk_fallback">。如果流水线继续不进行任何处理</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord cjk_fallback">那么</span><span class="mord">‘</span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mord">‘</span><span class="mord cjk_fallback">指令可能会读取到</span><span class="mord">‘</span></span></span></span>2<code>寄存器的一个旧值(如果</code>$2<code>在此之前被其他指令写过), 而不是</code>sub`指令刚刚计算出
的新值。</p>
<p>所以, 对于这个冒险的检测就是<code>EX/MEM.RegisterRd = ID/EX.RegisterRt = $2</code>。</p>
<p>进一步优化和补充</p>
<p>虽然我们已经看过了这么多数据冒险和检测方法, 但是, 直接采用总是旁路的方式解决冒险是不正确的, 因为某些指令可能不写回寄存器, 就会产生一些不必要的旁路。一种简单的解决方法是检测<code>RegWrite</code>信号是否是活动的, 即通过检测流水线寄存器在 EX 和 MEM 级的 WB 控制字段以确定<code>RegWrite</code>是否被有效。</p>
<p><strong>特殊处理0寄存器</strong>: 在MIPS架构中, 寄存器0始终被硬件保持为0, 任何对0的写操作都会被忽略, 而读取0总是返回0。因此, 当指令的目标寄存器是0时(例如, sll <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">0, </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em"></span><span class="mord">0</span><span class="mpunct">,</span></span></span></span>1,2), 即使存在看似可能的数据冒险, 实际上也无需旁路, 因为0的值永远不会改变。所以在设计旁路逻辑时, 需要加入额外的检查条件, 确保目标寄存器不是0。即在判断冒险条件时, 除了原有的寄存器匹配条件外, 还应增加<code>𝐸𝑋/𝑀𝐸𝑀.𝑅𝑒𝑔𝑖𝑠𝑡𝑒𝑟𝑅𝑑 ≠ 0</code>和<code>𝑀𝐸𝑀/𝑊𝐵.𝑅𝑒𝑔𝑖𝑠𝑡𝑒𝑟𝑅𝑑 ≠ 0</code>这样的条件, 以排除些目标寄存器为<code>0</code>。</p>
<blockquote>
<p>如果(Ex/MEM.RegisterRd==ID/EX.RegisterRs)并且(EX/MEM.RegWrite是活动的)并且(EX/MEM.RegisterRd ≠ 0)则进行旁路操作, 将 EX 阶段的结果传递给ID/EX 阶段的指令</p>
</blockquote>
<p>这样, 我们的处理器的冒险解决机制变得更加精确和高效, 既避免了不必要的资源浪费, 也确保了程序执行的正确性。</p>
<p>至此, 我们介绍了检测冒险的方法, 问题已经解决了一半, 但仍然需要解决旁路数据策略的问题。</p>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-08_22-55-21.png ##w700##" src="/HXLoLi/assets/images/Clip_2024-07-08_22-55-21-81221584eae2f7d74536ffb4181b55e2.png" width="1499" height="954" style="width:700px"></td></tr></tbody></table>
<p>蓝线部分描述了流水线寄存器和ALU输入之间的一个相关性。这里的相关性开始于一个流
水线寄存器而不是等待 WB 级写操作的寄存器堆。由于流水线寄存器保存了需要旁路的数据, 因此后面的指令能够获得相应的数据。</p>
<p>如果可以从任何流水线寄存器而不仅仅从 ID/EX 中得到 ALU 的输入, 那么就可以旁路所需的数据。通过在 ALU 的输入中加入多选器和正确的控制策略, 就可以在存在相关性的情况下仍然能够全速运行流水线。</p>
<p>在遇到 <strong>取数-使用型数据冒险(load-use data hazard)</strong> 时, 即使采用了旁路机制, 流水线也<strong>不得不</strong>阻塞一个或多个步骤来等待数据准备好。</p>
<p>例如:</p>
<div class="language-MIPS language-mips codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-mips codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">LOAD R1, [address] # 第一条指令, 从内存地址adress处加载数据到寄存器R1</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">ADD R2, R1, R3     # 第二条指令, R1 + R3 存入 R2</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">MIPS</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>假设我们是先load, 在执行其他操作。由于装载指令和紧随其后的指令之间的相关性在时间上是回溯的, 这种冒险<strong>不可能</strong>通过旁路来解决。(前面在时间上是不回溯的。也就是时间是按顺序来的 所以可以使用旁路)。必须采用相应的机制阻塞流水线 。</p>
<p>对于此类冒险的检测和阻塞处理:</p>
<ol>
<li>
<p><strong>位置与作用</strong>: 冒险检测单元位于流水线的1D(Decode/Decode)级, 即在译码阶段。它的主要职责是在指令进入执行阶段之前, 检查并预测潜在的数据冒险, 特别是载入冒险。</p>
</li>
<li>
<p><strong>检测条件</strong>:</p>
<ul>
<li>
<p><strong>装载指令检测</strong>: 首先确认当前译码阶段(ID)的指令是否涉及内存读取操作, 即是否为装载指令(LOAD)。</p>
</li>
<li>
<p><strong>目的寄存器匹配</strong>: 检查译码阶段(ID)的装载指令目的寄存器(RegisterRt)与指令fetch/decode阶段(IF/ID)的指令源寄存器(RegisterRs或RegisterRt)是否相同或重叠。这表明了后一条指令依赖于前一条装载指令的结果。</p>
</li>
</ul>
</li>
<li>
<p><strong>阻塞操作</strong>: 一旦检测到上述条件满足, 即存在载入冒险, 冒险检测单元会触发流水线的阻塞机制。这意味着在译码阶段(ID)的指令会被暂停一个时钟周期, 同时为了保持指令序列的完整性, 指令fetch阶段(IF)也需要暂停, 以避免指令丢失。</p>
</li>
<li>
<p><strong>流水线的&quot;空转&quot;</strong>: 阻塞期间, 从执行(EX)阶段到后续的流水线段(如内存访问MEM、写回WB)会执行<strong>空指令(NOP)</strong>, 确保这些阶段不会对数据或程序状态造成意外改变。</p>
</li>
</ol>
<p>当然, 这种阻塞也有明显的缺点和优点:</p>
<ul>
<li>
<p><strong>PC与流水线寄存器保持不变</strong>: 为了维持指令的连续性, 程序计数器(PC)和IF/ID流水线寄存器的值不会更新, 确保在解除阻塞后, 能够正确恢复执行流。</p>
</li>
<li>
<p><strong>性能影响</strong>: 虽然阻塞机制保证了数据的正确性, 但它会引入额外的延迟, 降低处理器的吞吐量。因此, 在高性能处理器设计中, 通常还会考虑其他优化手段, 如数据转发或更复杂的预测逻辑, 来减少阻塞的频率和影响。</p>
</li>
</ul>
<p>那我们怎么在流水线中插入空指令(就像气泡一样)呢?</p>
<p>在流水线处理器中插入空指令(或称为“气泡”)来处理数据冒险或流水线冲突的一种方法是, 通过控制逻辑来暂时停止流水线中某些阶段的执行。即当在ID阶段识别到冒险(比如数据冒险)时, <code>流水线控制器可以将ID/EX边界的EX、MEM和WB阶段的控制信号置为0</code>, 从而在流水线中创建一个“气泡”。</p>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-08_23-06-24.png ##w700##" src="/HXLoLi/assets/images/Clip_2024-07-08_23-06-24-7929f288871e593c3d7312b8753adb86.png" width="1075" height="678" style="width:700px"></td></tr></tbody></table>
<p>创建一个“气泡”的具体步骤:</p>
<ol>
<li>冒险识别阶段(ID级): 冒险检测单元</li>
<li>控制信号置零: 设置气泡</li>
<li>气泡的传播: 前移气泡</li>
<li>流水线行为: 空转阶段</li>
<li>资源管理: 避免副作用</li>
<li>性能考量: 效率牺牲</li>
</ol>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="总结">总结<a href="#总结" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h3>
<p>数据冒险: RAW  WAR  WAW</p>
<p>解决: 数据旁路</p>
<p>冒险检测: 流水线寄存器</p>
<p>取数-使用型数据冒险: 只好加气泡解决</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="控制冒险控制冲突">控制冒险(控制冲突)<a href="#控制冒险控制冲突" class="hash-link" aria-label="控制冒险(控制冲突)的直接链接" title="控制冒险(控制冲突)的直接链接">​</a></h2>
<p><strong>控制冒险(Control Hazard)</strong>, 是流水线处理器中的另一种重要挑战, 它发生在处
理器需要根据某条指令的结果(通常是分支或跳转指令的结果)来决定下一步执行哪条指令时, 而这时后续指令已经被预取并开始在流水线中前进。</p>
<p>简而言之, 就是处理器在<strong>未确定实际执行路径前</strong>, 已经<strong>提前取了可能是错误路径上的指令</strong>进入流水线。</p>
<div class="language-MIPS language-mips codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-mips codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">beq $s0, $s1, target_label # if $s0 == $s1: goto target_label</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">add $t0, $t1, $t2</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">MIPS</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>具体来说, 控制冒险通常与以下几种情况相关:</p>
<ol>
<li>
<p><strong>条件分支</strong>: 当处理器遇到条件分支指令时, 它需要先计算条件表达式的真假, 然后决定是否跳转。在计算完成前, 流水线可能已经取了分支后的指令, 如果分支被最终评估为需要跳转, 则这些指令实际上不应该被执行。</p>
</li>
<li>
<p><strong>间接跳转</strong>: 间接跳转(如通过寄存器内容决定跳转地址)也会引发控制冒险, 因为目标地址直到执行阶段计算完成前都是未知的。</p>
</li>
<li>
<p><strong>异常和中断</strong>: 某些指令执行期间可能触发异常或中断, 这也需要改变正常的指令流, 而此时后续指令可能已在流水线中。</p>
</li>
</ol>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="解决方案">解决方案<a href="#解决方案" class="hash-link" aria-label="解决方案的直接链接" title="解决方案的直接链接">​</a></h3>
<ol>
<li>
<p><strong>取分支指令后立即阻塞流水线</strong>, 直到流水线确定分支指令的结果并知道下一条真正要执行的指令在哪为止。</p>
</li>
<li>
<p><strong>分支预测(Branch Prediction)技术</strong>: 分支预测的基本思想是在分支指令的结果实际计算出来之前, 先预测它将采取哪条路径(即是否跳转), 然后提前取指并执行预测路径上的指令。如果预测正确, 那么流水线就可以保持连续运行, 从而避免阻塞；如果预测错误, 那么就需要采取一些措施来恢复流水线的正确状态, 如撤销已经执行的错误指令、刷新流水线等。</p>
</li>
<li>
<p><strong>延迟分支</strong>: &quot;延迟分支&quot;(Delayed Branch)是一种处理控制冒险的技术, 它通过在实际执行分支指令之前先行执行一条或多条不受分支结果影响的指令来减少流水线停顿。在MIPS体系结构中, 这种技术的实现是通过编译器的支持来完成的, 确保了对程序员的透明性。</p>
</li>
</ol>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="分支预测静态分支预测">分支预测—静态分支预测<a href="#分支预测静态分支预测" class="hash-link" aria-label="分支预测—静态分支预测的直接链接" title="分支预测—静态分支预测的直接链接">​</a></h3>
<p>分支预测技术中的一种最基本形式, 称为<strong>静态不分支预测(Static Not-Taken Prediction)</strong>, 或者简称<strong>不带预测的执行</strong>。这种方法假定所有的条件分支都不会发生(即<strong>默认程序会顺序执行</strong>), 因此在遇到分支指令时, 处理器不等待分支条件的评估结果, 而是直接继续预取和执行后续的指令。</p>
<p>当这种预测正确, 即分支确实未发生时, 流水线可以不间断地执行, 保持最大效率。然而, 如果预测错误(分支实际发生了), 处理器就需要采取措施来修正错误的预测, 这通常涉及到以下步骤:</p>
<ol>
<li><strong>流水线清空</strong>: 已经错误地取出和开始执行的后续指令需要被取消或丢弃。</li>
<li><strong>更新状态</strong>: 处理器回到分支指令的位置, 重新评估分支条件。</li>
<li><strong>重新取指与执行</strong>: 从正确的分支目标地址开始重新取指令并执行。</li>
</ol>
<p>一种更加成熟的分支预测 (branch prediction) 方法是预测一些分支发生而预测另一些分支不发生。即基于局部性的分支预测。循环体底部的分支预测是一个典型例子, 体现了循环展开和定向分支预测的思想</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="分支预测动态分支预测">分支预测—动态分支预测<a href="#分支预测动态分支预测" class="hash-link" aria-label="分支预测—动态分支预测的直接链接" title="分支预测—动态分支预测的直接链接">​</a></h3>
<p>与基于固定模式或简单规则的静态预测不同, 动态预测器能够根据程序执行过程中每条分支指令的实际行为实时调整其预测策略, 从而在程序生命周期内不断优化预测准确性。</p>
<ol>
<li>
<p><strong>历史记录的使用</strong>: 动态预测器通常会维护一个或多个<strong>分支历史表</strong>(如分支历史寄存器、分支目标缓冲区BTB中的预测位、或更复杂的全局历史状态), 用来记录每个分支点过去的表现(即分支是否发生)。这些历史记录帮助预测器建立一个关于分支行为的模型, 基于此模型对未来分支结果进行预测。</p>
</li>
<li>
<p><strong>预测算法</strong>: 动态预测器采用多种算法来利用这些历史记录, 常见的如<strong>二元预测器</strong>(根据最近几次分支是否发生来预测)、<strong>饱和计数器</strong>(使用多位计数器表示分支倾向)、以及更复杂的perceptron预测器(多层神经网络模型, 能捕捉更深层次的分支间相关性)等。这些算法随着历史记录的积累和更新, 逐渐调整预测策略, 以匹配当前程序的执行特征。</p>
</li>
</ol>
<p>例如这个是<code>二元预测器</code>:</p>











<table><thead><tr><th style="text-align:center">##container##</th></tr></thead><tbody><tr><td style="text-align:center"><img decoding="async" loading="lazy" alt="Clip_2024-07-08_23-20-31.png ##w500##" src="/HXLoLi/assets/images/Clip_2024-07-08_23-20-31-c2ec7096007782658415411cd7ab7d4e.png" width="932" height="500" style="width:500px"></td></tr></tbody></table>
<p>好处:</p>
<ol>
<li>
<p><strong>自适应性</strong>: 动态预测器的精髓在于其自适应性, 即能够根据新获得的信息自我调整和优化。当预测正确时, 预测器会强化当前的预测模型；而预测错误时, 则会调整模型参数以期望在未来做出更准确的预测。</p>
</li>
<li>
<p><strong>错误预测的处理</strong>: 当预测错误发生时, 处理器需要采取措施纠正错误预测的影响。这通常涉及流水线的刷新(flushing the pipeline), 即丢弃错误预测路径上已经开始执行但未完成的指令, 以及恢复到正确的执行路径, 从正确的分支目标地址开始重新填充流水线。这一过程会引入额外的延迟, 称为分支误测惩罚, 是动态预测器设计中需要权衡的关键因素之一。</p>
</li>
<li>
<p><strong>高正确率</strong>: 随着技术的发展, 现代动态分支预测器通过采用更精细的历史记录和复杂的预测算法, 能够达到非常高的预测准确率, 90%甚至更高。这极大地减少了因控制冒险导致的流水线停顿, 提升了处理器的整体执行效率。</p>
</li>
</ol>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="延迟分支">延迟分支<a href="#延迟分支" class="hash-link" aria-label="延迟分支的直接链接" title="延迟分支的直接链接">​</a></h3>
<ol>
<li>
<p><strong>编译器优化</strong>: MIPS编译器在生成机器码时, 会自动分析和重排指令顺序, 使得分支指令之后紧跟的至少一条指令是与分支结果无关的, 即无论分支是否发生, 这条指令都需要执行。这样, 即使分支结果尚未确定, 这条&quot;安全&quot;指令也能在分支指令执行之前被提前取出并执行, 从而隐藏了分支带来的延迟。</p>
</li>
<li>
<p><strong>分支延迟隐藏</strong>: 通过这种方式, 分支指令本身的延迟(例如, 用于计算分支条件和更新PC寄存器的时间)被隐藏, 因为在这段时间里, 流水线仍然在处理其他有用的指令。在给出的例子中, add指令如果与分支结果无关, 就可以被安排在分支指令之后执行, 使得流水线的前几个阶段在分支真正执行前保持忙碌。</p>
</li>
<li>
<p><strong>限制</strong>: 延迟分支技术的有效性依赖于分支延迟时间较短。如果分支延迟超过了单个时钟周期这种方法就难以有效隐藏延迟, 因为流水线会被迫停顿等待分支结果。在这种情况下, 使用硬件分支预测器会更加合适, 因为它可以在分支指令真正执行之前就开始取指和执行后续指令, 即使这些指令可能基于错误的分支预测。</p>
</li>
<li>
<p><strong>与硬件分支预测的对比</strong>: 硬件分支预测器通过预测分支结果并提前执行后续指令, 能够在更长的分支延迟情况下保持流水线的高效运转。虽然预测错误时会带来恢复成本, 但在多数应用程序中, 其总体效果仍然是积极的, 特别是在分支预测准确率高的情况下。</p>
</li>
</ol>
<p>(简单地说就是, 既然我们预测可能失败, 然后会浪费部分已经执行的指令, 但是我们是否可以通过指令重排(没有数据冲突), 然后让即使执行的指令也是预先要执行的指令, 这样在不影响结果的情况下, 减小了预测失败带来的风险)</p>
<p>未优化前的代码示例:</p>
<div class="language-MIPS language-mips codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-mips codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">add $t0, $s1, $s2     # 加法操作, 结果存入$t0</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">beq $s0, $zero, Label # 条件分支, 如果$s0等于$zero, 则跳转到Label</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">sub $t1, $s3, $s4     # 减法操作, 此操作可能会受到分支影响</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">Label:</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">mul $t2, $t0, $t1     # 乘法操作, 使用$t0和$t1的结果</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">MIPS</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在这个例子中,  beq 指令是一个分支指令, 它检查寄存器 s0 是否为0, 如果是, 则跳转到<code>Label</code>处继续执行。但是, 按照正常的流水线执行,  sub 指令会在分支结果确定之前就开始执行, 这可能导致错误的运算结果或者需要昂贵的流水线清除操作。</p>
<p>使用延迟分支技术优化:</p>
<div class="language-MIPS language-mips codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(220, 13%, 18%);--prism-color:hsl(220, 14%, 71%)"><div class="codeBlockContent_m3Ux" style="border-top-left-radius:0px;border-top-right-radius:0px"><pre tabindex="0" class="prism-code language-mips codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187 codeBlockLinesWithNumbering_OFgW"><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">beq $s0, $zero, Label # 先执行分支指令, 但不立即决定分支</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">add $t0, $s1, $s2     # 原先的加法操作移动到分支之后</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">sub $t1, $s3, $s4     # 这个减法操作在分支结果确定前执行, 且假设它不受分支影响</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">Label:</span></span><br></span><span class="token-line codeLine_lJS_" style="color:hsl(220, 14%, 71%);text-shadow:0 1px rgba(0, 0, 0, 0.3)"><span class="codeLineNumber_Tfdd"></span><span class="codeLineContent_feaV"><span class="token plain">mul $t2, $t0, $t1     # 乘法操作</span></span><br></span></code></pre><div class="buttonGroup_6DOT"><span class="languageName_x0G5">MIPS</span><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>请注意, 这个例子简化了一些复杂性, 实际的MIPS处理器和编译器在应用延迟分支时会有更复杂的考虑, 包括但不限于指令调度、数据依赖性和预测失败时的恢复策略。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/HengXin666/HXLoLi/edit/main/docs/001-计佬常識/005-计算机组成原理/005-第四章中央处理器/008-流水线冒险/index.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"><span class="theme-last-updated">最后<!-- -->由 <b>Heng_Xin_666</b> <!-- -->于 <b><time datetime="2025-04-28T14:52:39.000Z" itemprop="dateModified">2025年4月28日</time></b> <!-- -->更新</span></div></div></footer></article><div style="display:flex;justify-content:flex-end;margin-top:20px">请作者喝奶茶:<div class="icon-container" style="margin-left:10px"><img src="/HXLoLi//default-icons/alipay.svg" alt="Alipay Icon" class="icon"><img src="/HXLoLi//img/alipay_qr_code.png" alt="QR Code" class="qr-code"></div><div class="icon-container" style="margin-left:10px"><img src="/HXLoLi//default-icons/wechat.svg" alt="Alipay Icon" class="icon"><img src="/HXLoLi//img/wechat_qr_code.png" alt="QR Code" class="qr-code"></div></div><div style="display:flex;justify-content:flex-end"><span style="font-size:12px">本文遵循 <img src="/HXLoLi//default-icons/cc.svg" alt="CC" style="width:14px"> <span class="tailwind"><a href="https://creativecommons.org/licenses/by-sa/4.0/" class="relative inline-block transition-all duration-300 text-fuchsia-400 hover:text-pink-700" target="_blank" rel="noopener noreferrer">CC 4.0 BY-SA<span class="absolute right-0 bottom-0 h-0.5 bg-purple-700 w-0 transition-all duration-500"></span><span class="absolute left-0 bottom-0 h-0.5 bg-purple-700 w-0"></span></a></span> 版权协议, 转载请标明出处</span></div><div><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/流水线技术"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">流水线技术</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/HXLoLi/docs/计佬常識/计算机组成原理/第四章中央处理器/异常和中断"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">异常和中断</div></a></nav></div></div><div>Loading Comments...</div></div><div class="col col--3"><div class="tableOfContents_jeP5 thin-scrollbar theme-doc-toc-desktop"><div class="tailwind"><div class="text-fuchsia-400" style="border-left:1px solid var(--ifm-toc-border-color)"><div class="ml-4 -mb-2" style="border-bottom:1.5px solid var(--ifm-toc-border-color)">0<!-- -->%</div></div></div><ul class="table-of-contents table-of-contents__left-border"><li><a href="#结构冒险资源冲突" class="table-of-contents__link toc-highlight">结构冒险(资源冲突)</a></li><li><a href="#数据冒险数据冲突" class="table-of-contents__link toc-highlight">数据冒险(数据冲突)</a><ul><li><a href="#冒险检测-流水线寄存器" class="table-of-contents__link toc-highlight">冒险检测: 流水线寄存器</a></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li></ul></li><li><a href="#控制冒险控制冲突" class="table-of-contents__link toc-highlight">控制冒险(控制冲突)</a><ul><li><a href="#解决方案" class="table-of-contents__link toc-highlight">解决方案</a></li><li><a href="#分支预测静态分支预测" class="table-of-contents__link toc-highlight">分支预测—静态分支预测</a></li><li><a href="#分支预测动态分支预测" class="table-of-contents__link toc-highlight">分支预测—动态分支预测</a></li><li><a href="#延迟分支" class="table-of-contents__link toc-highlight">延迟分支</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/HengXin666/HXLoLi" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item">
                <a href="https://docusaurus.io" target="_blank" rel="noreferrer noopener">
                  <img src="/HXLoLi/default-img/buildwith.png" alt="build with docusaurus" width="120" height="50">
                </a>
                </li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">版权所有 © 2025 - 2025 HXLoLi, Inc. 由 Docusaurus 构建.</div></div></div></footer></div>
<div>
    <div id="graph-overlay"></div>
    <div id="graph-container">
      <div id="close-graph-btn" onclick="closeGraph()">
        <div style="padding: 5px">X</div>
      </div>
      <div>
        <h1 style="text-align: center">Graph View</h1>
        <div id="graphview-container" style="display: inline-block;margin: 0 auto"></div>
      </div>
    </div>
    </div>
<script>let graphViewGlobal=null,isOpen=!1;async function initGraphView(){const e=await(await fetch("/docusaurus-graph.json")).json(),n=new NOTE_GRAPH.NoteGraphModel(e);graphViewGlobal=new NOTE_GRAPH.NoteGraphView({container:document.getElementById("graphview-container"),graphModel:n,enableNodeDrag:!0,width:800,height:600})}window.onload=function(){initGraphView()};const graphContainer=document.getElementById("graph-container"),graphOverlay=document.getElementById("graph-overlay");function closeGraph(){graphContainer.style.display="none",graphOverlay.style.display="none"}function openGraph(){!0===isOpen?(closeGraph(),isOpen=!1):window.innerWidth>=800&&window.innerHeight>=720?(graphContainer.style.display="block",graphOverlay.style.display="block",graphViewGlobal.forceGraph.zoomToFit(1e3,20),isOpen=!0):alert("Your screen size must be greater than 800x720.")}graphOverlay.addEventListener("click",closeGraph)</script></body>
</html>