# 浮点数乘除法
> [!TIP]
> 以下内容了解即可, 非408内容

## 十进制的情况
先看十进制下的乘除：首先对操作数判0

$$(1.2 \times 10^6) \times (2.0 \times 10^2) = (1.2 \times 2 \times 10^{6+2})$$

$$(1.2 \times 10^6) ÷ (2.0 \times 10^2) = (1.2 ÷ 2 \times 10^{6-2})$$


浮点数乘除运算步骤类似于浮点数加、减运算步骤,两者的主要区别是:

- 加、减运算需要对阶,而对乘、除运算来说,无须这一步。

- 两者对结果的后处理步骤也一样，都包括规格化、舍人和溢出判断处理。


$x\times(÷)y=z$ 为例，基于`IEEE754标准`，以乘法为例

## 浮点数乘法 & 除法
### 1. 尾数相乘, 阶码相加

尾数的乘法运算定点原码小数乘法算法。

在运算时, 需要将隐藏位1还原到尾数中, 并注意乘积的小数点位置。

因为x和y是规格化浮点数, 所以其尾数的真值形式都是正负`1.b...b`。进行尾数相乘时,符号和数值部分分开运算, 符号由 $x$ 和 $y$ 两数符号`异或`得到, 数值部分将两个形为`1.b..`的定点无符号数进行 $n$ 位数乘法运算, 其结果为 $2n$ 位乘积: `bb.b...b`, 小数点应该默认在第二位和第三位之间。

阶码执行移码相加: 最终得到结果的`移码`表示的阶数。

指采用移码相加运算算法。根据`IEEE 754标准`的阶码的定义, 得到阶码的加法运算规则如下:

$$[E_b]_移 = [E_x]_移 + [E_x]_移 + 129 (\mod 2^8)$$

证明: 

$[Ex+Ey]_移\\=E_x+E_y+127\\=[E_x]_移+[E_y]_移-127\\=[E_x]_移+[E_y]_移+[-127]_补\\=[E_x]_移+[E_y]_移+10000001(\mod2^8)\\=[E_x]_移+[E_y]_移+129(\mod 2^8)$

注意: 除法: 尾数相除, 阶码相减.

$$[E_b]_移 = [E_x]_移 + [-[E_x]_移]_补 + 127 (\mod 2^8)$$

### 2. 尾数规格化
#### 乘法

在得到的 $2n$ 位乘积数值部分`bb.b...b`中, 小数点`左边` **一定至少** 有一个 $1$, 可能是`01`、`10`、`11`三种情况:
- 若是`01`, 则不需要规格化;
- 若是`10`或`11`, 则需要右规一次, 此时, 尾数右移一位, 阶码加 $1$。规格化后得到的尾数数值部分的形式为`01.b...b`小数点左边的 $1$ 就是隐藏位。

对于`IEEE754浮点数`的乘法运算 **不需要** 进行左规处理。

#### 除法

商的形式: `b.b...b`, 小数点左边可能是 $0$, 可能是 $1$。

对于`IEEE754浮点数`的除法运算 **不需要** 进行右规处理。

## 3. 尾数舍入

同加减法的舍入

## 4. 溢出判断

在进行指数相加、右规和舍人时, 要对指数进行溢出判断。右规和舍入时的溢出判断与浮点数加减运算中的溢出判断方法相同。而在进行指数相加时的溢出判断则要根据参与运算的操作数及结果的阶码的最高位的取值情况进行。