---
authors: Heng_Xin
title: 【C++】如何将「字符串」作为「非类型模板实参」
date: 2025-09-14 21:14:00
tags:
    - C++
---

冷门应用场景, 但是也算是比较方便吧~

<!-- truncate -->

> [!TIP]
> 环境: C++20

## 一、实现的效果

```cpp [c1-使用效果] vscode
// 代码节选
auto musicDAO
    = dao::MemoryDAOPool::get<MusicDAO, "./file/db/music.db">();
auto playlistDAO
    = dao::MemoryDAOPool::get<PlaylistDAO, "./file/db/playlist.db">();

// 直接传入字符串, 而不是 char...
auto playlistDAO
    = dao::MemoryDAOPool::get<
        PlaylistDAO,
        '.', '/', 'f', 'i', 'l', 'e', '/', 'd', 'b', '/', 'p', 'l',
        'a', 'y', 'l', 'i', 's', 't', '.', 'd', 'b'
    >();
```

```cpp [c1-为何使用] vscode
struct MemoryDAOPool {
    template <typename T, meta::FixedString Path> // 这两个参数, 保证单例唯一
    static std::shared_ptr<T> get() {
        using PathStr = meta::ToCharPack<Path>;
        static auto dao = std::make_shared<T>(db::SQLiteDB{PathStr::view()}); // 单例
        return dao;
    }
};

// 其中 db::SQLiteDB 为
class SQLiteDB {
public:
    SQLiteDB(std::string_view filePath) // 需要参数, 作为路径
        : SQLiteDB{}
    {
        if (::sqlite3_open(filePath.data(), &_db) != SQLITE_OK) [[unlikely]] {
            throw std::runtime_error{
                "Failed to open database: " + std::string{::sqlite3_errmsg(_db)}
            };
        }
    }
};
```

## 二、如何匹配非类型模板参数

> 附: C风格字符串, 是 `const char (&)[N]` 类型(`C风格数组`). 即: 数组不是指针...

```cpp
using StrType = decltype("123"); // const char (&)[4]
auto& str = "123"; // const char (&)[4]

// 下面发生了隐式转换
using StrType = decltype(+"123"); // const char*
auto str = "123"; // const char*
```

### 2.1 `<char... Cs>`

```cpp
template <char... Cs>
void strTp() {}

strTp<"123">(); // 报错, 显然不匹配
```

### 2.2 `<auto Str>`

C++17 auto占位非类型模版形参:

```cpp
template <auto Str>
void strAutoTp() {}

strAutoTp<"123">(); // 报错, 它仅支持 整型常量/枚举常量/指针常量/成员指针/std::nullptr_t/  浮点数(C++20)
                    // 未支持 const char* 或者 const char (&)[]
```

### 2.3 NTTP (C++20)

- https://en.cppreference.com/w/cpp/language/template_parameters.html

- https://ctrpeach.io/posts/cpp20-class-as-non-type-template-param

> 即 `constexpr 类` 实例作为模板参数

所以, 在 C++20 中, 我们可以自定义一个 constexpr 类, 并且其通过 `C风格字符串` 构造, 从而实现: 「字符串」作为「非类型模板实参」

## 三、代码实现

```cpp
template <std::size_t N>
struct CStr {
    char _str[N];

    // constexpr 构造函数 + 默认析构
    constexpr CStr(const char (&str)[N]) {
        for (std::size_t i = 0; i < N; ++i)
            _str[i] = str[i];
    }

    constexpr char operator[](std::size_t i) const noexcept {
        return _str[i];
    }

    constexpr auto size() const noexcept {
        return N - 1; // 去掉 '\0'
    }
};

template <CStr Str> // CStr 可作为 NTTP 类型
void strCStrTp() {}

strCStrTp<"123">(); // 合法
```

其他的使用, 比如:

```cpp [c2-访问字符串]
template <CStr Str>
void strCStrTp() {
    for (std::size_t i = 0; i < Str.size(); ++i)
        Str[i]; // todo...
}
```

```cpp [c2-展开到 char...]
template <char... Cs>
struct CStrWrap {};

template <CStr Str>
using ToCs = decltype([] <std::size_t... Idx> (std::index_sequence<Idx...>) {
    return CStrWrap<Str[Idx]...>{};
}(std::make_index_sequence<Str.size()>{}));

// === 等价于 ===

template <std::size_t Idx>
constexpr auto toCs(std::index_sequence<Idx...>) -> CStrWrap<Str[Idx]...>;

template <CStr Str>
using ToCs = decltype(toCs(std::make_index_sequence<Str.size()>{}));

// === END ===

template <char... Cs>
constexpr auto toNum(CStrWrap<Cs...>) {
    static_assert((('0' <= Cs && Cs <= '9') && ...) && sizeof...(Cs) <= 18,
        "Only numeric characters allowed");
    constexpr char str[] = {Cs...};
    std::size_t value = 0;
    for (std::size_t i = 0; i < sizeof...(Cs); ++i) {
        value = value * static_cast<std::size_t>(10) 
              + static_cast<std::size_t>(str[i] - '0');
    }
    return value;
}

template <CStr Str>
constexpr auto strCStrTp() {
    return toNum(ToCs<Str>{});
}

static_assert(toNum<"123"> == 123, ""); // ok
```

完整代码: https://godbolt.org/z/fqas758MK