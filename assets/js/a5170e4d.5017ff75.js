"use strict";(self.webpackChunkhx_loli=self.webpackChunkhx_loli||[]).push([[34844],{571:(n,i,e)=>{e.d(i,{A:()=>t});const t=e.p+"assets/images/Clip_2024-02-07_10-14-11-70e48da24402bdaf9fce2195db31e48e.png"},28453:(n,i,e)=>{e.d(i,{R:()=>c,x:()=>a});var t=e(96540);const d={},r=t.createContext(d);function c(n){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof n?n(i):{...i,...n}}),[i,n])}function a(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(d):n.components||d:c(n.components),t.createElement(r.Provider,{value:i},n.children)}},73092:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>s,contentTitle:()=>a,default:()=>A,frontMatter:()=>c,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/\u6700\u5c0f\u751f\u6210\u6811/Prim\u7b97\u6cd5/index","title":"Prim\u7b97\u6cd5","description":"\u7b97\u6cd5\u63cf\u8ff0","source":"@site/docs/001-\u8ba1\u4f6c\u5e38\u8b58/001-\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/005-\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/005-\u6700\u5c0f\u751f\u6210\u6811/003-Prim\u7b97\u6cd5/index.md","sourceDirName":"001-\u8ba1\u4f6c\u5e38\u8b58/001-\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/005-\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/005-\u6700\u5c0f\u751f\u6210\u6811/003-Prim\u7b97\u6cd5","slug":"/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/\u6700\u5c0f\u751f\u6210\u6811/Prim\u7b97\u6cd5/","permalink":"/HXLoLi/docs/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/\u6700\u5c0f\u751f\u6210\u6811/Prim\u7b97\u6cd5/","draft":false,"unlisted":false,"editUrl":"https://github.com/HengXin666/HXLoLi/edit/main/docs/001-\u8ba1\u4f6c\u5e38\u8b58/001-\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/005-\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/005-\u6700\u5c0f\u751f\u6210\u6811/003-Prim\u7b97\u6cd5/index.md","tags":[],"version":"current","lastUpdatedBy":"Heng_Xin_666","lastUpdatedAt":1745851959000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Kruskal\u7b97\u6cd5","permalink":"/HXLoLi/docs/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/\u6700\u5c0f\u751f\u6210\u6811/Kruskal\u7b97\u6cd5/"},"next":{"title":"Dijkstra\u7b97\u6cd5","permalink":"/HXLoLi/docs/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/\u6700\u77ed\u8def\u5f84/Dijkstra\u7b97\u6cd5/"}}');var d=e(74848),r=e(28453);const c={},a="Prim\u7b97\u6cd5",s={},o=[{value:"\u7b97\u6cd5\u63cf\u8ff0",id:"\u7b97\u6cd5\u63cf\u8ff0",level:2},{value:"\u4e3e\u4f8b",id:"\u4e3e\u4f8b",level:2},{value:"\u6587",id:"\u6587",level:3},{value:"\u56fe",id:"\u56fe",level:3},{value:"\u4ee3\u7801",id:"\u4ee3\u7801",level:2},{value:"\u7ade\u8d5b\u7248",id:"\u7ade\u8d5b\u7248",level:3},{value:"\u5b66\u4e60\u7248",id:"\u5b66\u4e60\u7248",level:3}];function l(n){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(i.header,{children:(0,d.jsx)(i.h1,{id:"prim\u7b97\u6cd5",children:"Prim\u7b97\u6cd5"})}),"\n",(0,d.jsx)(i.h2,{id:"\u7b97\u6cd5\u63cf\u8ff0",children:"\u7b97\u6cd5\u63cf\u8ff0"}),"\n",(0,d.jsx)(i.p,{children:"\u666e\u91cc\u59c6\u7b97\u6cd5\u5728\u627e\u6700\u5c0f\u751f\u6210\u6811\u65f6\uff0c\u5c06\u9876\u70b9\u5206\u4e3a\u4e24\u7c7b:"}),"\n",(0,d.jsxs)(i.ul,{children:["\n",(0,d.jsx)(i.li,{children:"\u4e00\u7c7b\u662f\u5728\u67e5\u627e\u7684\u8fc7\u7a0b\u4e2d\u5df2\u7ecf\u5305\u542b\u5728\u751f\u6210\u6811\u4e2d\u7684\u9876\u70b9\uff08\u5047\u8bbe\u4e3aA\u7c7b\uff09\uff0c"}),"\n",(0,d.jsx)(i.li,{children:"\u5269\u4e0b\u7684\u4e3a\u53e6\u4e00\u7c7b\uff08\u5047\u8bbe\u4e3aB\u7c7b\uff09\u3002"}),"\n"]}),"\n",(0,d.jsxs)(i.ol,{children:["\n",(0,d.jsxs)(i.li,{children:["\u5bf9\u4e8e\u7ed9\u5b9a\u7684\u8fde\u901a\u7f51\uff0c",(0,d.jsx)(i.strong,{children:"\u8d77\u59cb\u72b6\u6001\u5168\u90e8\u9876\u70b9\u90fd\u5f52\u4e3aB\u7c7b"}),"\u3002"]}),"\n",(0,d.jsx)(i.li,{children:"\u5728\u627e\u6700\u5c0f\u751f\u6210\u6811\u65f6\uff0c\u9009\u5b9a\u4efb\u610f\u4e00\u4e2a\u9876\u70b9\u4f5c\u4e3a\u8d77\u59cb\u70b9\uff0c\u5e76\u5c06\u4e4b\u4ece B \u7c7b\u79fb\u81f3 A \u7c7b\uff1b"}),"\n",(0,d.jsxs)(i.li,{children:["\u7136\u540e\u627e\u51fa ",(0,d.jsx)(i.strong,{children:"B \u7c7b\u4e2d\u5230 A \u7c7b\u4e2d\u7684\u9876\u70b9\u4e4b\u95f4\u6743\u503c\u6700\u5c0f\u7684\u9876\u70b9"}),"\uff0c\u5c06\u4e4b\u4ece B \u7c7b\u79fb\u81f3 A \u7c7b\uff0c"]}),"\n",(0,d.jsx)(i.li,{children:"\u5982\u6b64\u91cd\u590d\uff0c\u76f4\u5230B\u7c7b\u4e2d\u6ca1\u6709\u9876\u70b9\u4e3a\u6b62\u3002\u6240\u8d70\u8fc7\u7684\u9876\u70b9\u548c\u8fb9\u5c31\u662f\u8be5\u8fde\u901a\u56fe\u7684\u6700\u5c0f\u751f\u6210\u6811\u3002"}),"\n"]}),"\n",(0,d.jsx)(i.h2,{id:"\u4e3e\u4f8b",children:"\u4e3e\u4f8b"}),"\n",(0,d.jsx)(i.h3,{id:"\u6587",children:"\u6587"}),"\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(i.table,{children:[(0,d.jsx)(i.thead,{children:(0,d.jsx)(i.tr,{children:(0,d.jsx)(i.th,{style:{textAlign:"center"},children:"##container##"})})}),(0,d.jsx)(i.tbody,{children:(0,d.jsx)(i.tr,{children:(0,d.jsx)(i.td,{style:{textAlign:"center"},children:(0,d.jsx)(i.img,{alt:"Clip_2024-02-07_10-11-28.png ##w300##",src:e(76336).A+"",width:"453",height:"444"})})})})]}),"\n",(0,d.jsxs)(i.ol,{children:["\n",(0,d.jsx)(i.li,{children:"\u5047\u5982\u4ece\u9876\u70b9A\u51fa\u53d1\uff0c\u9876\u70b9 B\u3001C\u3001D \u5230\u9876\u70b9 A \u7684\u6743\u503c\u5206\u522b\u4e3a 2\u30014\u30012\uff0c\u6240\u4ee5\uff0c\u5bf9\u4e8e\u9876\u70b9 A \u6765\u8bf4\uff0c\u9876\u70b9 B \u548c\u9876\u70b9 D \u5230 A \u7684\u6743\u503c\u6700\u5c0f\uff0c\u5047\u8bbe\u5148\u627e\u5230\u7684\u9876\u70b9 B;"}),"\n",(0,d.jsx)(i.li,{children:"\u7ee7\u7eed\u5206\u6790\u9876\u70b9 C \u548c D\uff0c\u9876\u70b9 C \u5230 B \u7684\u6743\u503c\u4e3a 3\uff0c\u5230 A \u7684\u6743\u503c\u4e3a 4\uff1b\u9876\u70b9 D \u5230 A \u7684\u6743\u503c\u4e3a 2\uff0c\u5230 B \u7684\u6743\u503c\u4e3a\u65e0\u7a77\u5927\uff08\u5982\u679c\u4e4b\u95f4\u6ca1\u6709\u76f4\u63a5\u901a\u8def\uff0c\u8bbe\u5b9a\u6743\u503c\u4e3a\u65e0\u7a77\u5927\uff09\u3002\u6240\u4ee5\u9876\u70b9 D \u5230 A \u7684\u6743\u503c\u6700\u5c0f;"}),"\n",(0,d.jsx)(i.li,{children:"\u6700\u540e\uff0c\u53ea\u5269\u4e0b\u9876\u70b9 C\uff0c\u5230 A \u7684\u6743\u503c\u4e3a 4\uff0c\u5230 B \u7684\u6743\u503c\u548c\u5230 D \u7684\u6743\u503c\u4e00\u6837\u5927\uff0c\u4e3a 3\u3002\u6240\u4ee5\u8be5\u8fde\u901a\u56fe\u6709\u4e24\u4e2a\u6700\u5c0f\u751f\u6210\u6811;"}),"\n"]}),"\n",(0,d.jsx)(i.h3,{id:"\u56fe",children:"\u56fe"}),"\n",(0,d.jsx)(i.p,{children:"\u5177\u4f53\u5230\u7b97\u6cd5, \u5219\u9700\u8981\u8bb0\u5f55:"}),"\n",(0,d.jsx)(i.pre,{children:(0,d.jsx)(i.code,{className:"language-C",children:"// \u521b\u5efa\u4e00\u4e2a Prim \u7b97\u6cd5 \u7684\u8bb0\u5f55\u6570\u7ec4\nint *min_weight = (int *)malloc(sizeof(int) * G->add_index);    // \u8bb0\u5f55\u6743\u7684\u6700\u5c0f\u503c\nint *connect = (int *)malloc(sizeof(int) * G->add_index);       // \u4e0e\u8c01\u7684\u8fde\u63a5\n_Bool *visit = (_Bool *)malloc(sizeof(_Bool) * G->add_index);   // \u662f\u5426\u88ab\u8bbf\u95ee\n"})}),"\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(i.table,{children:[(0,d.jsx)(i.thead,{children:(0,d.jsx)(i.tr,{children:(0,d.jsx)(i.th,{style:{textAlign:"center"},children:"##container##"})})}),(0,d.jsx)(i.tbody,{children:(0,d.jsx)(i.tr,{children:(0,d.jsx)(i.td,{style:{textAlign:"center"},children:(0,d.jsx)(i.img,{alt:"Clip_2024-02-07_10-14-11.png ##w800##",src:e(571).A+"",width:"2439",height:"964"})})})})]}),"\n",(0,d.jsx)(i.h2,{id:"\u4ee3\u7801",children:"\u4ee3\u7801"}),"\n",(0,d.jsx)(i.h3,{id:"\u7ade\u8d5b\u7248",children:"\u7ade\u8d5b\u7248"}),"\n",(0,d.jsx)(i.pre,{children:(0,d.jsx)(i.code,{className:"language-C++",children:'void prim_01(void)\n{\n    const int INF = 1e6;\n    // \u7ed9\u51fa\u4e00\u4e2a\u65e0\u5411\u56fe\uff0c\u6c42\u51fa\u6700\u5c0f\u751f\u6210\u6811\uff0c\u5982\u679c\u8be5\u56fe\u4e0d\u8fde\u901a\uff0c\u5219\u8f93\u51fa orz\n    int n, m;\n    scanf("%d %d", &n, &m);\n    vector<vector<int>> G(n, vector<int>(n, INF));\n\n    for (int i = 0, j, k, w; i < m; ++i) {\n        scanf("%d %d %d", &j, &k, &w);\n        // \u8003\u8651: \u53ef\u80fd\u50bbder\u4f1a\u8f93\u5165\u91cd\u590d\u8fb9\n        G[j - 1][k - 1] = min(G[j - 1][k - 1], w);\n        G[k - 1][j - 1] = min(G[k - 1][j - 1], w);\n    }\n\n    // prim \u7b97\u6cd5\n    vector<bool> if_G(n, 1);    // \u5982\u679c\u4e3a 0 \u5219\u662f\u88ab\u9009\n    vector<int> G_fd(n, -1);    // \u8bb0\u5f55\u7ed3\u70b9\u7236\u8282\u70b9 (\u4e0d\u7528\u8f93\u51fa\u8be5\u6811, \u5219\u4e0d\u9700\u8981\u8fd9\u4e2a)\n    vector<int> G_Wmin(n, INF); // \u8bb0\u5f55\u6700\u5c0f\u6743\u503c\n\n    G_Wmin[0] = 0;\n\n    for (int i = 0, j, k; ;) {\n        // \u9009\u62e9[0][j] \u4e3a\u7b2c\u4e00\u4e2a\u7ed3\u70b9\n        k = -1;\n        for (j = 0; j < n; ++j) {\n            // \u904d\u5386\u5224\u65ad \u6ca1\u6709\u88ab\u9009 \u7684 \u6700\u5c0f\u6743\u503c\n            if (if_G[j]) {\n                // \u5224\u65ad\u8fd9\u4e2a\u7ed3\u70b9\u7684\u6743\u503c\u662f\u5426\u6bd4\u5f53\u524d\u7ed3\u70b9\u7684\u5c0f\n                if (G[i][j] != INF && G[i][j] < G_Wmin[j]) {\n                    // \u6709\u66f4\u5c0f\u7684\u6743\u503c: \u66f4\u65b0\u4e00\u4e0b\n                    G_Wmin[j] = G[i][j];\n                    G_fd[j] = i;\n                }\n\n                // \u987a\u4fbf\u5728\u672a\u88ab\u9009\u7684\u4e2d\u9009\u62e9\u6700\u5c0f\u7684\n                if (k == -1 || G_Wmin[k] > G_Wmin[j]) {\n                    k = j;\n                }\n            }\n        }\n\n        if (k == -1)\n            break;\n\n        if_G[k] = 0;\n        i = k;\n    }\n\n    int res = 0;\n    for (auto& it : G_Wmin) {\n        res += it;\n    }\n\n    if (res > INF)\n        printf("orz");\n    else\n        printf("%d\\n", res);\n}\n'})}),"\n",(0,d.jsx)(i.h3,{id:"\u5b66\u4e60\u7248",children:"\u5b66\u4e60\u7248"}),"\n",(0,d.jsx)(i.pre,{children:(0,d.jsx)(i.code,{className:"language-C",children:'#include <stdio.h>\n#include <stdlib.h>\n\n#define ARR_LEN_MAX 12\ntypedef int Element;\n\ntypedef struct\n{\n    char **show;    // \u6253\u5370\n    int **weight;   // \u6743\n    int *tagArray;  // \u7528\u4e8e\u904d\u5386\u65f6\u5019\u7684\u6807\u8bb0\n    int side_num;   // \u8fb9\u7684\u4e2a\u6570\n    int add_index;  // \u7ed3\u70b9\u6570\n    int number;     // \u603b\u5927\u5c0f\n} AdjacencyMatrix;\n\nAdjacencyMatrix *initAdjacencyMatrix(int n);                // \u521d\u59cb\u5316AdjacencyMatrix\nvoid addAdjacencyMatrix(AdjacencyMatrix *A, char *show);    // \u6dfb\u52a0\u5143\u7d20\nvoid connectAdjacencyMatrix(AdjacencyMatrix *A, char *show_1, char *show_2, int weight);    // \u8fde\u63a5\u5143\u7d20\nvoid initTagArray(AdjacencyMatrix *A);                      // \u91cd\u7f6e\u904d\u5386\u7684\u6807\u8bb0\u6570\u7ec4 (-1)\nvoid DFS(AdjacencyMatrix *A, int index);                    // \u6df1\u5ea6\u4f18\u5148\u904d\u5386\nvoid BFS(AdjacencyMatrix *A);                               // \u5e7f\u5ea6\u4f18\u5148\u904d\u5386\nvoid freeAdjacencyMatrix(AdjacencyMatrix *A);               // \u514d\u8d39\n\nAdjacencyMatrix *initAdjacencyMatrix(int n)\n{\n    AdjacencyMatrix *A = (AdjacencyMatrix *)malloc(sizeof(AdjacencyMatrix));\n    if (!A)\n    {\n        MALLOC_ERROR:\n        printf("Malloc ERROR!\\n");\n        return NULL;\n    }\n\n    A->show = (char **)malloc(sizeof(char *) * n);\n    if (!A->show)\n        goto MALLOC_ERROR;\n    \n    A->weight = (int **)malloc(sizeof(int *) * n);\n    if (!A->weight)\n        goto MALLOC_ERROR;\n\n    for (int i = 0; i < n; ++i)\n    {\n        A->weight[i] = (int *)malloc(sizeof(int) * n);\n        if (!A->weight[i])\n            goto MALLOC_ERROR;\n        for (int j = 0; j < n; ++j)\n            A->weight[i][j] = 0;        // \u8fd9\u4e2a\u662f\u6807\u8bb0\u6570_\u53ef\u6539, \u8bb00\u4e3a\u672a\u8fde\u63a5\n    }\n    \n    A->side_num = 0;\n    A->add_index = 0;\n    A->number = n;\n    A->tagArray = (int *)malloc(sizeof(int) * n);\n    if (!A->tagArray)\n        goto MALLOC_ERROR;\n    initTagArray(A);\n    return A;\n}\n\nvoid addAdjacencyMatrix(AdjacencyMatrix *A, char *show)\n{\n    if (A->add_index == A->number)\n        return; // ERROR\n    A->show[A->add_index++] = show;\n}\n\nvoid initTagArray(AdjacencyMatrix *A)\n{\n    for (int i = 0; i < A->number; ++i)\n        A->tagArray[i] = -1;\n}\n\nvoid connectAdjacencyMatrix(AdjacencyMatrix *A, char *show_1, char *show_2, int weight)\n{\n    int s_1 = -1;\n    for (int i = 0; i < A->number; ++i)\n    {\n        if (A->show[i] == show_1)\n            s_1 = i;\n    }\n\n    if (s_1 == -1)\n        return; // \u627e\u4e0d\u5230\n    \n    int s_2 = -1;\n    for (int i = 0; i < A->number; ++i)\n    {\n        if (A->show[i] == show_2)\n            s_2 = i;\n    }\n\n    if (s_2 == -1)\n        return; // \u627e\u4e0d\u5230\n    \n    A->weight[s_1][s_2] = weight;\n    A->weight[s_2][s_1] = weight;\n    ++A->side_num;\n}\n\n// \u6ce8\u610f\u904d\u5386\u7684\u662f\u8fde\u901a\u56fe\nvoid DFS(AdjacencyMatrix *A, int index)\n{\n    printf("%s ", A->show[index]);\n    A->tagArray[index] = 1;\n    for (int i = 0; i < A->add_index; ++i)\n    {\n        if (A->weight[index][i] != 0 && A->tagArray[i] == -1)\n        {\n            DFS(A, i);\n        }\n    }\n}\n\n// \u4f9d\u65e7\u662f\u8fde\u901a\u56fe\n// \u590d\u6742\u8fc7\u5934\u4e86\u5427...\nvoid BFS(AdjacencyMatrix *A)\n{\n    // \u4e34\u65f6\u961f\u5217\n    int queue[A->add_index];\n    int q_h = 0;\n    int q_t = 0;\n    printf("%s ", A->show[0]);\n    A->tagArray[0] = 1;\n    for (int i = 0; i < A->add_index; ++i)\n    {\n        for (int j = 0; j < A->add_index; ++j)\n        {\n            if (A->weight[i][j] != 0 && A->tagArray[j] == -1)\n            {\n                A->tagArray[j] = 1;\n                queue[q_t++] = j;\n                q_t = q_t % A->add_index;\n            }\n        }\n\n        if (q_h != q_t)\n            break;\n    }\n    \n    while (q_h != q_t)\n    {\n        printf("%s ", A->show[queue[q_h]]);\n        for (int i = 0; i < A->add_index; ++i)\n        {\n            if (A->weight[queue[q_h]][i] != 0 && A->tagArray[i] == -1)\n            {\n                A->tagArray[q_t == 0 ? A->add_index - 1 : q_t - 1] = 1;\n                queue[q_t++] = i;\n                q_t = q_t % A->add_index;\n            }\n        }\n        ++q_h;\n        q_h = q_h % A->add_index;\n    }\n}\n\nvoid freeAdjacencyMatrix(AdjacencyMatrix *A)\n{\n    free(A->show);\n    for (int i = 0; i < A->number; ++i)\n    {\n        free(A->weight[i]);\n    }\n    free(A->weight);\n    free(A->tagArray);\n    free(A);\n}\n\ntypedef struct\n{\n    int begin;  // \u5f00\u59cb\u7aef\u70b9\n    int end;    // \u7ed3\u675f\u7aef\u70b9\n    int weight; // \u6743\n} Edge;\n\ntypedef struct\n{\n    int *vertex;    // \u9876\u70b9\u96c6 (G\u7684\u7d22\u5f15)\n    Edge *side;     // \u8fb9\u96c6\n    int side_len;   // \u8fb9\u96c6\u957f\u5ea6\n    int vertex_len; // \u9876\u70b9\u96c6\u957f\u5ea6\n} EdgeSet;      // \u8fb9\u96c6\u6570\u7ec4\n\n// prim\nEdgeSet *prim(AdjacencyMatrix *G, int s_index);   // \u7ed9\u5165\u4e00\u4e2a \u90bb\u63a5\u77e9\u9635, \u8fd4\u56de\u4e00\u4e2a\u6700\u5c0f\u751f\u6210\u6811\n\n// \u83b7\u53d6\u6743\u548c\nint getWeightSum(const AdjacencyMatrix *G,const EdgeSet *E)\n{\n    int res = 0;\n    printf("\u6700\u5c0f\u751f\u6210\u6811\u8fb9\u4e3a %d\\n", E->side_len);\n    for (int i = 0; i < E->side_len; ++i)\n    {\n        //printf("%d--%d--%d\\n", E->side[i].begin, E->side[i].weight, E->side[i].end);\n        printf("%s--%d--%s\\n", G->show[E->side[i].begin], E->side[i].weight, G->show[E->side[i].end]);\n        res += E->side[i].weight;\n    }\n    return res;\n}\n\nEdgeSet *prim(AdjacencyMatrix *G, int s_index)\n{\n    // \u521b\u5efa \u8fd4\u56de\u7684\u8fb9\u96c6\u6570\u7ec4\n    EdgeSet *resES = (EdgeSet *)malloc(sizeof(EdgeSet));\n    if (!resES)\n    {\n        ERROR:\n        printf("malloc error!\\n");\n        return NULL;\n    }\n\n    resES->side = (Edge *)malloc(sizeof(Edge) * (G->add_index - 1));\n    if (!resES->side)\n        goto ERROR;\n\n    resES->vertex = (int *)malloc(sizeof(int) * G->side_num);\n    if (!resES->vertex)\n        goto ERROR;\n\n\n    for (int i = 0, k = 0; i < G->add_index; ++i)\n    {\n        resES->vertex[i] = i;\n    }\n\n    resES->side_len = G->add_index - 1; // dddd\n    resES->vertex_len = G->add_index;\n\n    // \u521b\u5efa\u4e00\u4e2a Prim \u7b97\u6cd5 \u7684\u8bb0\u5f55\u6570\u7ec4\n    int *min_weight = (int *)malloc(sizeof(int) * G->add_index);    // \u8bb0\u5f55\u6743\u7684\u6700\u5c0f\u503c\n    int *connect = (int *)malloc(sizeof(int) * G->add_index);       // \u4e0e\u8c01\u7684\u8fde\u63a5\n    _Bool *visit = (_Bool *)malloc(sizeof(_Bool) * G->add_index);   // \u662f\u5426\u88ab\u8bbf\u95ee\n    \n    for (int i = 0; i < G->add_index; ++i)\n    {   // \u521d\u59cb\u5316\n        min_weight[i] = INT_MAX;\n        connect[i] = -1;\n        visit[i] = 0;\n    }\n\n    int index = s_index, // \u5f53\u524d\u8bbf\u95ee\u7684\u7ed3\u70b9\n        add_index = 0;   // \u8fb9\u96c6\u6570\u7ec4\u6dfb\u52a0\u7684\u7d22\u5f15\n    visit[index] = 1;\n    \n    // \u6b63\u5f0f\u5f00\u59cb \u5728\u90bb\u63a5\u77e9\u9635\u91cc\u9762\u8bbf\u95ee\u5c31\u884c\u4e86\n    while (1)\n    {\n        int weight_min_node = -1;   // \u8bb0\u5f55\u5f53\u524d\u5faa\u73af\u4e2d\u6743\u503c\u6700\u5c0f\u7684\u7ed3\u70b9\u7684\u7d22\u5f15 \u4e0b\u6b21\u5faa\u73af\u5c31\u662f\n        for (int i = 0; i < G->add_index; ++i)\n        {\n            if (visit[i])   // \u8bbf\u95ee\u8fc7\u7684\u8df3\u8fc7\n                continue;\n\n            if (G->weight[index][i] != 0)   // 0\u662f\u65e0\u6548\u503c\n            {\n                if (G->weight[index][i] < min_weight[i])\n                {\n                    min_weight[i] = G->weight[index][i];\n                    connect[i] = index;\n                }\n            }\n\n            if ((weight_min_node == -1 && min_weight[i] != INT_MAX) || min_weight[weight_min_node] > min_weight[i])\n                weight_min_node = i;\n        }\n\n        if (weight_min_node == -1)\n            break;\n\n        visit[weight_min_node] = 1;\n        resES->side[add_index].begin = weight_min_node;\n        resES->side[add_index].end = connect[weight_min_node];\n        resES->side[add_index].weight = min_weight[weight_min_node];\n        ++add_index;\n        // printf("index = %d ||%d -- %d -- %d\\n", index ,weight_min_node, min_weight[weight_min_node], connect[weight_min_node]);\n        index = weight_min_node;\n    }\n\n    // \u91ca\u653e\u8d44\u6e90\n    free(connect);\n    free(min_weight);\n    free(visit);\n\n    return resES;\n}\n\n\nvoid text(void)\n{\n    AdjacencyMatrix *A = initAdjacencyMatrix(6);\n    addAdjacencyMatrix(A, "A");\n    addAdjacencyMatrix(A, "B");\n    addAdjacencyMatrix(A, "C");\n    addAdjacencyMatrix(A, "D");\n    addAdjacencyMatrix(A, "E");\n    addAdjacencyMatrix(A, "F");\n    connectAdjacencyMatrix(A, "E", "F", 5);\n    connectAdjacencyMatrix(A, "E", "A", 2);\n    connectAdjacencyMatrix(A, "E", "C", 4);\n    connectAdjacencyMatrix(A, "E", "B", 10);\n    connectAdjacencyMatrix(A, "A", "F", 3);\n    connectAdjacencyMatrix(A, "D", "F", 4);\n    connectAdjacencyMatrix(A, "D", "C", 1);\n    connectAdjacencyMatrix(A, "B", "C", 3);\n    connectAdjacencyMatrix(A, "B", "A", 7);\n\n    DFS(A, 0);\n    putchar(\'\\n\');\n    EdgeSet *eSet = prim(A, 0);\n    \n    printf("\\n\u6700\u5c0f\u751f\u6210\u6811\u7684\u6743\u548c\u662f %d\\n", getWeightSum(A, eSet));\n\n    // \u91ca\u653epass\n}\n\nint main(void)\n{\n    //  - \u6700\u5c0f\u751f\u6210\u6811 - Prim\u7b97\u6cd5 - \u65e0\u5411\u6709\u6743\u56fe\n    // \u5bfb\u627e\u8fde\u901a\u56fe\u7684 \u6743\u548c\u6700\u5c0f \u8fde\u901a\u5b50\u56fe, \u65e0\u73af\n\n    /*\n    *   Prim \u7b97\u6cd5 -- \u8d2a\u5fc3\u7b97\u6cd5\n    * */\n    text();\n    getchar();\n    return 0;\n}\n'})})]})}function A(n={}){const{wrapper:i}={...(0,r.R)(),...n.components};return i?(0,d.jsx)(i,{...n,children:(0,d.jsx)(l,{...n})}):l(n)}},76336:(n,i,e)=>{e.d(i,{A:()=>t});const t=e.p+"assets/images/Clip_2024-02-07_10-11-28-ec254bd66ca8e269082f77143461ba83.png"}}]);