"use strict";(self.webpackChunkhx_loli=self.webpackChunkhx_loli||[]).push([[32103],{28453:(n,i,e)=>{e.d(i,{R:()=>a,x:()=>r});var t=e(96540);const d={},o=t.createContext(d);function a(n){const i=t.useContext(o);return t.useMemo((function(){return"function"==typeof n?n(i):{...i,...n}}),[i,n])}function r(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(d):n.components||d:a(n.components),t.createElement(o.Provider,{value:i},n.children)}},52457:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>c,contentTitle:()=>r,default:()=>_,frontMatter:()=>a,metadata:()=>t,toc:()=>A});const t=JSON.parse('{"id":"\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/\u56fe\u7684\u5b58\u50a8and\u904d\u5386code/index","title":"\u90bb\u63a5\u77e9\u9635","description":"","source":"@site/docs/001-\u8ba1\u4f6c\u5e38\u8b58/001-\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/005-\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/004-\u56fe\u7684\u5b58\u50a8and\u904d\u5386code/index.md","sourceDirName":"001-\u8ba1\u4f6c\u5e38\u8b58/001-\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/005-\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/004-\u56fe\u7684\u5b58\u50a8and\u904d\u5386code","slug":"/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/\u56fe\u7684\u5b58\u50a8and\u904d\u5386code/","permalink":"/HXLoLi/docs/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/\u56fe\u7684\u5b58\u50a8and\u904d\u5386code/","draft":false,"unlisted":false,"editUrl":"https://github.com/HengXin666/HXLoLi/edit/main/docs/001-\u8ba1\u4f6c\u5e38\u8b58/001-\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/005-\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/004-\u56fe\u7684\u5b58\u50a8and\u904d\u5386code/index.md","tags":[],"version":"current","lastUpdatedBy":"Heng_Xin_666","lastUpdatedAt":1745851959000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"\u56fe\u7684\u904d\u5386","permalink":"/HXLoLi/docs/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/\u56fe\u7684\u904d\u5386/"},"next":{"title":"\u6700\u5c0f\u751f\u6210\u6811\u603b\u89c8","permalink":"/HXLoLi/docs/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/\u6700\u5c0f\u751f\u6210\u6811/\u6700\u5c0f\u751f\u6210\u6811\u603b\u89c8/"}}');var d=e(74848),o=e(28453);const a={},r="\u90bb\u63a5\u77e9\u9635",c={},A=[];function s(n){const i={code:"code",h1:"h1",header:"header",pre:"pre",...(0,o.R)(),...n.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(i.header,{children:(0,d.jsx)(i.h1,{id:"\u90bb\u63a5\u77e9\u9635",children:"\u90bb\u63a5\u77e9\u9635"})}),"\n",(0,d.jsx)(i.pre,{children:(0,d.jsx)(i.code,{className:"language-C",children:'#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct\n{\n    char **show;\n    int **weight;\n    int *tagArray;  // \u7528\u4e8e\u904d\u5386\u65f6\u5019\u7684\u6807\u8bb0\n    int add_index;\n    int number;\n} AdjacencyMatrix;\n\nAdjacencyMatrix *initAdjacencyMatrix(int n);                // \u521d\u59cb\u5316AdjacencyMatrix\nvoid addAdjacencyMatrix(AdjacencyMatrix *A, char *show);    // \u6dfb\u52a0\u5143\u7d20\nvoid connectAdjacencyMatrix(AdjacencyMatrix *A, char *show_1, char *show_2, int weight);    // \u8fde\u63a5\u5143\u7d20\nvoid initTagArray(AdjacencyMatrix *A);                      // \u91cd\u7f6e\u904d\u5386\u7684\u6807\u8bb0\u6570\u7ec4 (-1)\nvoid DFS(AdjacencyMatrix *A, int index);                    // \u6df1\u5ea6\u4f18\u5148\u904d\u5386\nvoid BFS(AdjacencyMatrix *A);                               // \u5e7f\u5ea6\u4f18\u5148\u904d\u5386\nvoid freeAdjacencyMatrix(AdjacencyMatrix *A);               // \u514d\u8d39\n\nAdjacencyMatrix *initAdjacencyMatrix(int n)\n{\n    AdjacencyMatrix *A = (AdjacencyMatrix *)malloc(sizeof(AdjacencyMatrix));\n    if (!A)\n    {\n        MALLOC_ERROR:\n        printf("Malloc ERROR!\\n");\n        return NULL;\n    }\n\n    A->show = (char **)malloc(sizeof(char *) * n);\n    if (!A->show)\n        goto MALLOC_ERROR;\n    \n    A->weight = (int **)malloc(sizeof(int *) * n);\n    if (!A->weight)\n        goto MALLOC_ERROR;\n\n    for (int i = 0; i < n; ++i)\n    {\n        A->weight[i] = (int *)malloc(sizeof(int) * n);\n        if (!A->weight[i])\n            goto MALLOC_ERROR;\n        for (int j = 0; j < n; ++j)\n            A->weight[i][j] = 0;        // \u8fd9\u4e2a\u662f\u6807\u8bb0\u6570_\u53ef\u6539, \u8bb00\u4e3a\u672a\u8fde\u63a5\n    }\n    \n    A->add_index = 0;\n    A->number = n;\n    A->tagArray = (int *)malloc(sizeof(int) * n);\n    if (!A->tagArray)\n        goto MALLOC_ERROR;\n    initTagArray(A);\n    return A;\n}\n\nvoid addAdjacencyMatrix(AdjacencyMatrix *A, char *show)\n{\n    if (A->add_index == A->number)\n        return; // ERROR\n    A->show[A->add_index++] = show;\n}\n\nvoid initTagArray(AdjacencyMatrix *A)\n{\n    for (int i = 0; i < A->number; ++i)\n        A->tagArray[i] = -1;\n}\n\nvoid connectAdjacencyMatrix(AdjacencyMatrix *A, char *show_1, char *show_2, int weight)\n{\n    int s_1 = -1;\n    for (int i = 0; i < A->number; ++i)\n    {\n        if (A->show[i] == show_1)\n            s_1 = i;\n    }\n\n    if (s_1 == -1)\n        return; // \u627e\u4e0d\u5230\n    \n    int s_2 = -1;\n    for (int i = 0; i < A->number; ++i)\n    {\n        if (A->show[i] == show_2)\n            s_2 = i;\n    }\n\n    if (s_2 == -1)\n        return; // \u627e\u4e0d\u5230\n    \n    A->weight[s_1][s_2] = weight;\n    A->weight[s_2][s_1] = weight;\n}\n\n// \u6ce8\u610f\u904d\u5386\u7684\u662f\u8fde\u901a\u56fe\nvoid DFS(AdjacencyMatrix *A, int index)\n{\n    printf("%s ", A->show[index]);\n    A->tagArray[index] = 1;\n    for (int i = 0; i < A->add_index; ++i)\n    {\n        if (A->weight[index][i] != 0 && A->tagArray[i] == -1)\n        {\n            DFS(A, i);\n        }\n    }\n}\n\n// \u4f9d\u65e7\u662f\u8fde\u901a\u56fe\n// \u590d\u6742\u8fc7\u5934\u4e86\u5427...\nvoid BFS(AdjacencyMatrix *A)\n{\n    // \u4e34\u65f6\u961f\u5217\n    int queue[A->add_index];\n    int q_h = 0;\n    int q_t = 0;\n    printf("%s ", A->show[0]);\n    A->tagArray[0] = 1;\n    for (int i = 0; i < A->add_index; ++i)\n    {\n        for (int j = 0; j < A->add_index; ++j)\n        {\n            if (A->weight[i][j] != 0 && A->tagArray[j] == -1)\n            {\n                A->tagArray[j] = 1;\n                queue[q_t++] = j;\n                q_t = q_t % A->add_index;\n            }\n        }\n\n        if (q_h != q_t)\n            break;\n    }\n    \n    while (q_h != q_t)\n    {\n        printf("%s ", A->show[queue[q_h]]);\n        for (int i = 0; i < A->add_index; ++i)\n        {\n            if (A->weight[queue[q_h]][i] != 0 && A->tagArray[i] == -1)\n            {\n                A->tagArray[q_t == 0 ? A->add_index - 1 : q_t - 1] = 1;\n                queue[q_t++] = i;\n                q_t = q_t % A->add_index;\n            }\n        }\n        ++q_h;\n        q_h = q_h % A->add_index;\n    }\n}\n\nvoid freeAdjacencyMatrix(AdjacencyMatrix *A)\n{\n    free(A->show);\n    for (int i = 0; i < A->number; ++i)\n    {\n        free(A->weight[i]);\n    }\n    free(A->weight);\n    free(A->tagArray);\n    free(A);\n}\n\nint main(void)\n{\n    // \u90bb\u63a5\u77e9\u9635 - By01 - BFS + DFS\n    AdjacencyMatrix *A = initAdjacencyMatrix(6);\n    addAdjacencyMatrix(A, "v1");\n    addAdjacencyMatrix(A, "v2");\n    addAdjacencyMatrix(A, "v3");\n    addAdjacencyMatrix(A, "v4");\n    addAdjacencyMatrix(A, "v5");\n    addAdjacencyMatrix(A, "v6");\n    connectAdjacencyMatrix(A, "v1", "v2", 1);\n    connectAdjacencyMatrix(A, "v1", "v6", 1);\n    connectAdjacencyMatrix(A, "v1", "v4", 1);\n    connectAdjacencyMatrix(A, "v2", "v3", 1);\n    connectAdjacencyMatrix(A, "v6", "v3", 1);\n    connectAdjacencyMatrix(A, "v6", "v2", 1);\n    connectAdjacencyMatrix(A, "v6", "v4", 1);\n    connectAdjacencyMatrix(A, "v3", "v5", 1);\n    printf("DFS: ");\n    DFS(A, 0);\n    initTagArray(A);\n    printf("\\nBFS: ");\n    BFS(A);\n    freeAdjacencyMatrix(A);\n    getchar();\n    return 0;\n}\n'})}),"\n",(0,d.jsx)(i.h1,{id:"\u90bb\u63a5\u8868",children:"\u90bb\u63a5\u8868"}),"\n",(0,d.jsx)(i.pre,{children:(0,d.jsx)(i.code,{className:"language-C",children:'#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct _AdjacencyListNode\n{\n    int index;\n    struct _AdjacencyListNode *next;    // \u6709\u6743\u4e5f\u53ef\u518d\u52a0\n} AdjacencyListNode;\n\ntypedef struct\n{\n    char **show;                // data \u53ef\u4ee5\u641e\u4e2a\u552f\u4e00\u8bc6\u522b\u7801\n    AdjacencyListNode **list;\n\n    /* \u7528\u4e8e\u5feb\u901f\u63d2\u5165 */\n    int n;\n    int add_index;\n\n    /* \u7528\u4e8e\u904d\u5386 */\n    _Bool *tag_arr;\n} AdjacencyList;\n\nAdjacencyList *initAdjacencyList(int n);                    // \u521d\u59cb\u5316\u90bb\u63a5\u8868\nvoid addAdjacencyListNode(AdjacencyList *A, char *show);    // \u6dfb\u52a0\u5143\u7d20\n_Bool connectAdjacencyListNode(AdjacencyList *A, char *show_1, char *show_2/*, int \u6743*/);   // \u8fde\u63a5\u7ed3\u70b9\nvoid DFS(AdjacencyList *A, int index);                      // \u6df1\u5ea6\u4f18\u5148\u904d\u5386\nvoid BFS(AdjacencyList *A, int index);                      // \u5e7f\u5ea6\u4f18\u5148\u904d\u5386\nvoid initTagArr(AdjacencyList *A);\nvoid freeAdjacencyList(AdjacencyList *A);\n\nvoid initTagArr(AdjacencyList *A)\n{\n    for (int i = 0; i < A->n; ++i)\n    {\n        A->tag_arr[i] = 0;\n    }\n}\n\nAdjacencyList *initAdjacencyList(int n)\n{\n    AdjacencyList* A = (AdjacencyList *)malloc(sizeof(AdjacencyList));\n    if (!A)\n    {\n        MALLOC_ERROR:\n        printf("MALLOC ERROR!\\n");\n        return NULL;\n    }\n    A->show = (char **)malloc(sizeof(char *) * n);\n    if (!A->show)\n        goto MALLOC_ERROR;\n    \n    A->list = (AdjacencyListNode **)malloc(sizeof(AdjacencyListNode *) * n);\n    if (!A->list)\n        goto MALLOC_ERROR;\n    \n    A->tag_arr = (_Bool *)malloc(sizeof(_Bool) * n);\n    if (!A->tag_arr)\n        goto MALLOC_ERROR;\n    A->n = n;\n    initTagArr(A);\n    for (int i = 0; i < n; ++i)\n    {\n        A->list[i] = NULL;\n    }\n    A->add_index = 0;\n    return A;\n}\n\nvoid addAdjacencyListNode(AdjacencyList *A, char *show)\n{\n    if (A->add_index == A->n)\n        return; // \u6ee1\n    \n    A->show[A->add_index++] = show;\n}\n\n// \u5b9a\u4e49\u4e3a show_1 --\x3e show_2 (\u6709\u5411\u56fe)\n_Bool connectAdjacencyListNode(AdjacencyList *A, char *show_1, char *show_2/*, int \u6743*/)\n{\n    int i_1 = -1;\n    for (int i = 0; i < A->add_index; ++i)\n    {\n        if (A->show[i] == show_1)\n        {\n            i_1 = i;\n            break;\n        }\n    }\n\n    if (i_1 == -1)\n        return 0;   // \u6ca1\u627e\u5230\n    \n    int i_2 = -1;\n    for (int i = 0; i < A->add_index; ++i)\n    {\n        if (A->show[i] == show_2)\n        {\n            i_2 = i;\n            break;\n        }\n    }\n\n    if (i_2 == -1)\n        return 0;   // \u6ca1\u627e\u5230\n    \n    AdjacencyListNode *p = (AdjacencyListNode *)malloc(sizeof(AdjacencyListNode));\n    if (!p)\n        return 0; // malloc error!\n    \n    p->index = i_2;\n    p->next = A->list[i_1];\n    A->list[i_1] = p;\n    return 1;\n}\n\nvoid DFS(AdjacencyList *A, int index)\n{\n    printf("%s ", A->show[index]);\n    A->tag_arr[index] = 1;\n    AdjacencyListNode *p = A->list[index];\n    while (p)\n    {\n        if (!A->tag_arr[p->index])\n            DFS(A, p->index);\n        p = p->next;\n    }\n}\n\n// \u53ea\u80fd\u904d\u5386\u8fde\u901a\u56fe, \u4e0d\u8fde\u901a\u9700\u8981\u518d\u52a0\u4e2afor!\nvoid BFS(AdjacencyList *A, int index)\n{\n    // \u4e34\u65f6\u961f\u5217\n    int queue[A->add_index + 1];\n    int q_h = 0, q_t = 0;\n    queue[q_t++] = index;\n    A->tag_arr[index] = 1;\n    while (q_t != q_h)\n    {\n        printf("%s ", A->show[queue[q_h]]);\n        AdjacencyListNode *p = A->list[queue[q_h]];\n        while (p)\n        {\n            if (!A->tag_arr[p->index])\n            {\n                queue[q_t] = p->index;\n                A->tag_arr[p->index] = 1;\n                q_t = (q_t + 1) % (A->add_index + 1);\n            }\n            p = p->next;\n        }\n        q_h = (q_h + 1) % (A->add_index + 1);\n    }\n}\n\nvoid freeAdjacencyList(AdjacencyList *A)\n{\n    for (int i = 0; i < A->add_index; ++i)\n    {\n        AdjacencyListNode *p = A->list[i];\n        AdjacencyListNode *tmp = NULL;\n        while (p)\n        {\n            tmp = p;\n            p = p->next;\n            free(tmp);\n        }\n    }\n\n    free(A->tag_arr);\n    free(A->show);\n    free(A->list);\n    free(A);\n}\n\nint main(void)\n{\n    // \u90bb\u63a5\u8868 - By01 - BFS + DFS\n    AdjacencyList *A = initAdjacencyList(6);\n    addAdjacencyListNode(A, "v1");\n    addAdjacencyListNode(A, "v2");\n    addAdjacencyListNode(A, "v3");\n    addAdjacencyListNode(A, "v4");\n    addAdjacencyListNode(A, "v5");\n    addAdjacencyListNode(A, "v6");\n    connectAdjacencyListNode(A, "v1", "v2");\n    connectAdjacencyListNode(A, "v2", "v6");\n    connectAdjacencyListNode(A, "v2", "v3");\n    connectAdjacencyListNode(A, "v3", "v5");\n    connectAdjacencyListNode(A, "v3", "v1");\n    connectAdjacencyListNode(A, "v3", "v4");\n\n    printf("\\nBFS: ");\n    BFS(A, 0);\n    initTagArr(A);\n\n    printf("\\nDFS: ");\n    DFS(A, 0);\n    initTagArr(A);\n    \n    freeAdjacencyList(A);\n    getchar();\n    return 0;\n}\n'})}),"\n",(0,d.jsx)(i.h1,{id:"\u5341\u5b57\u94fe\u8868",children:"\u5341\u5b57\u94fe\u8868"}),"\n",(0,d.jsx)(i.pre,{children:(0,d.jsx)(i.code,{className:"language-C",children:'#include <stdio.h>\n#include <stdlib.h>\n\n/*\n * \u94fe\u8868\n * \u51fa\u5ea6\u6307\u5411\u7684\u76ee\u6807\u7d22\u5f15 \u51fa\u5ea6\u6307\u5411\u7684\u76ee\u6807*next \u5165\u5ea6\u76ee\u6807\u7d22\u5f15 \u5165\u5ea6*next\n * */\ntypedef struct _G_node\n{\n    /*\u51fa\u5ea6*/\n    int out_index;\n    struct _G_node *out_next;\n    /*\u5165\u5ea6*/\n    int in_index;\n    struct _G_node *in_next;\n} OrthogonalListNode;\n\ntypedef struct\n{\n    const char *show;\n    int no;             // \u7f16\u53f7(\u7406\u89e3\u4e3a\u7d22\u5f15\u4e5f\u53ef\u4ee5, \u7528\u4e8e\u5224\u65ad\u662f\u5426\u662f\u76ee\u6807\u5143\u7d20)\n} OrthogonalListData;\n\ntypedef struct\n{\n    OrthogonalListData *data;\n    OrthogonalListNode **out_list;  // \u51fa\u5ea6\u94fe\u8868\n    OrthogonalListNode **in_list;   // \u5165\u5ea6\u94fe\u8868\n    int len_max;                    // \u6700\u5927\u957f\u5ea6\n    int add_index;                  // \u5f53\u524d\u957f\u5ea6 / \u6dfb\u52a0\u5143\u7d20\u65f6\u5019\u7684\u7d22\u5f15\n} OrthogonalList;\n\nOrthogonalList *initOrthogonalList(int n);                      // \u521d\u59cb\u5316\nvoid addOrthogonalListData(OrthogonalList *G, const char *e);   // \u6dfb\u52a0\u5143\u7d20\nvoid connectGraphNode(OrthogonalList *G, int no_1, int no_2);   // \u8fde\u63a5\u7ed3\u70b9 no_1 --\x3e no_2\n// \u904d\u5386\u7701\u7565\nvoid freeOrthogonalList(OrthogonalList  *G);                    // \u514d\u8d39\u5b83\nint getOutListLen(OrthogonalList *G, int no);                   // \u8fd4\u56de\u5143\u7d20no\u51fa\u5ea6\u7684\u94fe\u8868\u957f\u5ea6\nint getInListLen(OrthogonalList *G, int no);                    // \u8fd4\u56de\u5143\u7d20no\u5165\u5ea6\u7684\u94fe\u8868\u957f\u5ea6\n\nOrthogonalList *initOrthogonalList(int n)\n{\n    OrthogonalList *G = (OrthogonalList *)malloc(sizeof(OrthogonalList));\n    if (!G)\n    {\n        ERROR:\n        printf("MALLOC ERROR!\\n");\n        return NULL;\n    }\n    G->data = (OrthogonalListData *)malloc(sizeof(OrthogonalListData) * n);\n    if (!G->data)\n        goto ERROR;\n    G->out_list = (OrthogonalListNode **)malloc(sizeof(OrthogonalListNode *) * n);\n    if (!G->out_list)\n        goto ERROR;\n    G->in_list = (OrthogonalListNode **)malloc(sizeof(OrthogonalListNode *) * n);\n    if (!G->in_list)\n        goto ERROR;\n    for (int i = 0; i < n; ++i)\n    {\n        G->out_list[i] = NULL;\n        G->in_list[i] = NULL;\n    }\n    G->len_max = n;\n    G->add_index = 0;\n    return G;\n}\n\nvoid addOrthogonalListData(OrthogonalList *G, const char *e)\n{\n    if (G->add_index == G->len_max)\n        return; // error \u6ee1\u4e86\n    G->data[G->add_index].show = e;\n    G->data[G->add_index].no = G->add_index;\n    ++G->add_index;\n}\n\n// \u627e\u6bdbno\u4e0d\u662f\u6709\u5417\n// static int getIndexNode(OrthogonalList *G, int no)  // \u627e\u7ed3\u70b9\n// {\n//     for (int i = 0; i < G->add_index; ++i)\n//     {\n//         if (G->data[i].no == no)\n//             return i;\n//     }\n//     return -1;\n// }\n\nvoid connectGraphNode(OrthogonalList *G, int no_1, int no_2)\n{\n    // \u8fde\u63a5\u7ed3\u70b9 no_1 --\x3e no_2\n    OrthogonalListNode *node = (OrthogonalListNode *)malloc(sizeof(OrthogonalListNode));\n    if (!node)\n        return; // error malloc\n\n    // \u5934\u63d2\u6cd5 \u51fa\u5ea6\n    node->out_index = no_1;\n    node->out_next = G->out_list[no_1];\n    G->out_list[no_1] = node;\n\n    // \u5934\u63d2\u6cd5 \u5165\u5ea6\n    node->in_index = no_2;\n    node->in_next = G->in_list[no_2];\n    G->in_list[no_2] = node;\n}\n\nint getOutListLen(OrthogonalList *G, int no)\n{\n    int res = 0;\n    OrthogonalListNode *p = G->out_list[no];\n    while (p)\n    {\n        ++res;\n        p = p->out_next;\n    }\n    return res;\n}\n\nint getInListLen(OrthogonalList *G, int no)\n{\n    int res = 0;\n    OrthogonalListNode *p = G->in_list[no];\n    while (p)\n    {\n        ++res;\n        p = p->in_next;\n    }\n    return res;\n}\n\n// \u53ea\u8981\u91ca\u653e\u51fa\u5ea6\u6216\u8005\u5165\u5ea6\u5373\u53ef, \u56e0\u4e3anode\u662f\u5171\u7528\u7684!\nvoid freeOrthogonalList(OrthogonalList  *G)\n{\n    for (int i = 0; i < G->add_index; ++i)\n    {\n        OrthogonalListNode *p = G->in_list[i];\n        OrthogonalListNode *tmp = NULL;\n        while(p)\n        {\n            tmp = p;\n            p = p->in_next;\n            free(tmp);\n        }\n    }\n\n    free(G->data);\n    free(G);\n}\n\nint main(void)\n{\n    //  - \u5341\u5b57\u94fe\u8868 - \u6709\u5411\u56fe\n    /*\n    * \u7d22\u5f15 \u5143\u7d20data \u5165\u5ea6 \u51fa\u5ea6\n    * */\n    OrthogonalList *G = initOrthogonalList(4);\n    addOrthogonalListData(G, "v0");\n    addOrthogonalListData(G, "v1");\n    addOrthogonalListData(G, "v2");\n    addOrthogonalListData(G, "v3");\n    connectGraphNode(G, 0, 3);\n    connectGraphNode(G, 0, 1);\n    connectGraphNode(G, 0, 2);\n    connectGraphNode(G, 3, 0);\n    connectGraphNode(G, 3, 1);\n    connectGraphNode(G, 3, 2);\n    connectGraphNode(G, 1, 2);\n    for (int i = 0; i < 4; ++i)\n        printf("v%c \u7684\u51fa\u5ea6: %d, \u5165\u5ea6: %d\\n", \'0\' + i,getOutListLen(G, i), getInListLen(G, i));\n    freeOrthogonalList(G);\n    getchar();\n    return 0;\n}\n'})}),"\n",(0,d.jsx)(i.h1,{id:"\u90bb\u63a5\u591a\u91cd\u8868",children:"\u90bb\u63a5\u591a\u91cd\u8868"}),"\n",(0,d.jsx)(i.pre,{children:(0,d.jsx)(i.code,{className:"language-C",children:'#include <stdio.h>\n#include <stdlib.h>\n\n/*\n *  \u94fe\u8868, \u5b58\u50a8\u7684\u8fb9\u7684\u5173\u7cfb, \u987a\u5e8f\u65e0\u6240\u8c13\n * */\ntypedef struct _G_node\n{\n    int i_index;\n    int j_index;\n    struct _G_node *i_next;\n    struct _G_node *j_next;\n} AMTNode;\n\ntypedef struct\n{\n    const char *show;\n    int no;             // \u7f16\u53f7(\u7406\u89e3\u4e3a\u7d22\u5f15\u4e5f\u53ef\u4ee5, \u7528\u4e8e\u5224\u65ad\u662f\u5426\u662f\u76ee\u6807\u5143\u7d20)\n} AMTData;\n\ntypedef struct\n{\n    AMTData *data;\n    AMTNode **list;\n    int max_len;\n    int add_index;\n} AMT;\n\nAMT *initAMT(int n);                                // init\nvoid addAMTData(AMT *G, const char *e);             // add e\nvoid connectAMTNode(AMT *G, int no_1, int no_2);    // \u8fde\u63a5\nint getNodeNum(AMT *G, int no);                     // \u83b7\u53d6\u5ea6\nvoid delAMTSide(AMT *G, int no, int no_2);          // \u5220\u9664\u8fb9\nvoid freeAMT(AMT *G);                               // \u514d\u8d39\u5b83\n\n\nAMT *initAMT(int n)\n{\n    AMT *G = (AMT *)malloc(sizeof(AMT));\n    if (!G)\n    {\n        ERROR:\n        printf("error malloc!\\n");\n        return NULL;\n    }\n\n    G->data = (AMTData *)malloc(sizeof(AMTData) * n);\n    if (!G->data)\n        goto ERROR;\n    \n    G->list = (AMTNode **)malloc(sizeof(AMTNode *) * n);\n    if (!G->list)\n        goto ERROR;\n    \n    for (int i = 0; i < n; ++i)\n        G->list[i] = NULL;\n    G->add_index = 0;\n    G->max_len = n;\n\n    return G;\n}\n\nvoid addAMTData(AMT *G, const char *e)\n{\n    G->data[G->add_index].show = e;\n    G->data[G->add_index].no = G->add_index;\n    ++G->add_index;\n}\n\nvoid connectAMTNode(AMT *G, int no_1, int no_2)\n{\n    AMTNode *node = (AMTNode *)malloc(sizeof(AMTNode));\n    node->i_index = no_1;\n    node->j_index = no_2;\n    node->i_next = G->list[no_1];\n    G->list[no_1] = node;\n    node->j_next = G->list[no_2];\n    G->list[no_2] = node;\n}\n\nint getNodeNum(AMT *G, int no)\n{\n    AMTNode *p = G->list[no];\n    int res = 0;\n    while (p)\n    {\n        ++res;\n        p = p->i_index == no ? p->i_next : p->j_next;\n    }\n    return res;\n}\n\nvoid delAMTSide(AMT *G, int no_1, int no_2)\n{\n    // \u5148\u51b3\u6761\u4ef6\u662f no_1 and no_2 \u5b58\u5728\u4e14\u6b63\u786e\n    AMTNode *node = G->list[no_1];\n    AMTNode *tmp = NULL;\n    while (node)\n    {\n        if (node->i_index == no_2 || node->j_index == no_2)\n            break;\n        tmp = node;\n        node = node->i_index == no_1 ? node->i_next : node->j_next;\n    }\n\n    if (!node)\n        return; // \u6ca1\u627e\u5230\n\n    if (tmp)\n        if (tmp->i_index == no_1)\n            tmp->i_next = node->i_index == no_1 ? node->i_next : node->j_next;\n        else\n            tmp->j_next = node->i_index == no_1 ? node->i_next : node->j_next;\n    else\n        G->list[no_1] = node->i_index == no_1 ? node->i_next : node->j_next;\n\n    node = G->list[no_2];\n    tmp = NULL;\n    while (node)\n    {\n        if (node->i_index == no_1 || node->j_index == no_1)\n            break;\n        tmp = node;\n        node = node->i_index == no_2 ? node->i_next : node->j_next;\n    }\n\n    if (!node)\n        return; // \u6ca1\u627e\u5230\n\n    if (tmp)\n        if (tmp->i_index == no_2)\n            tmp->i_next = node->i_index == no_2 ? node->i_next : node->j_next;\n        else\n            tmp->j_next = node->i_index == no_2 ? node->i_next : node->j_next;\n    else\n        G->list[no_2] = node->i_index == no_2 ? node->i_next : node->j_next;\n    free(node);\n}\n\nvoid freeAMT(AMT *G)\n{\n    for (int i = 0; i < G->add_index; ++i)\n    {\n        for (int j = i + 1; j < G->add_index; ++j)\n            delAMTSide(G, i, j);\n    }\n    free(G->data);\n    free(G->list);\n    free(G);\n}\n\nint main(void)\n{\n    //  - \u90bb\u63a5\u591a\u91cd\u8868 - \u65e0\u5411\u56fe!\n    AMT *G = initAMT(5);\n    addAMTData(G, "A");\n    addAMTData(G, "B");\n    addAMTData(G, "C");\n    addAMTData(G, "D");\n    addAMTData(G, "E");\n    connectAMTNode(G, 0, 3);\n    connectAMTNode(G, 0, 1);\n    connectAMTNode(G, 0, 2);\n    connectAMTNode(G, 1, 3);\n    connectAMTNode(G, 1, 4);\n    connectAMTNode(G, 1, 2);\n    connectAMTNode(G, 3, 4);\n\n    for (int i = 0; i < G->add_index; ++i)\n        printf("%c \u7684\u5ea6\u4e3a %d\\n", \'A\' + i, getNodeNum(G, i));\n    delAMTSide(G, 2, 1);\n    putchar(\'\\n\');\n    for (int i = 0; i < G->add_index; ++i)\n        printf("%c \u7684\u5ea6\u4e3a %d\\n", \'A\' + i, getNodeNum(G, i));\n    freeAMT(G);\n    getchar();\n    return 0;\n}\n'})})]})}function _(n={}){const{wrapper:i}={...(0,o.R)(),...n.components};return i?(0,d.jsx)(i,{...n,children:(0,d.jsx)(s,{...n})}):s(n)}}}]);