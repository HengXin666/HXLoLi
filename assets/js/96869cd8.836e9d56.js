"use strict";(self.webpackChunkhx_loli=self.webpackChunkhx_loli||[]).push([[81392],{28453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>s});var t=i(96540);const d={},r=t.createContext(d);function a(n){const e=t.useContext(r);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(d):n.components||d:a(n.components),t.createElement(r.Provider,{value:e},n.children)}},78783:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>s,default:()=>x,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/\u6700\u5c0f\u751f\u6210\u6811/Kruskal\u7b97\u6cd5/index","title":"Kruskal\u7b97\u6cd5","description":"\u514b\u9c81\u65af\u5361\u5c14\u7b97\u6cd5(Kruskal) \u662f\u4e00\u79cd\u4f7f\u7528\u8d2a\u5a6a\u65b9\u6cd5\u7684\u6700\u5c0f\u751f\u6210\u6811\u7b97\u6cd5\u3002\u8be5\u7b97\u6cd5\u521d\u59cb\u5c06\u56fe\u89c6\u4e3a\u68ee\u6797\uff0c\u56fe\u4e2d\u7684\u6bcf\u4e00\u4e2a\u9876\u70b9\u89c6\u4e3a\u4e00\u68f5\u5355\u72ec\u7684\u6811\u3002\u4e00\u68f5\u6811\u53ea\u4e0e\u5b83\u7684\u90bb\u63a5\u9876\u70b9\u4e2d\u6743\u503c\u6700\u5c0f\u4e14\u4e0d\u8fdd\u53cd\u6700\u5c0f\u751f\u6210\u6811\u5c5e\u6027\uff08\u4e0d\u6784\u6210\u73af\uff09\u7684\u6811\u4e4b\u95f4\u5efa\u7acb\u8fde\u8fb9\u3002","source":"@site/docs/001-\u8ba1\u4f6c\u5e38\u8b58/001-\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/005-\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/005-\u6700\u5c0f\u751f\u6210\u6811/002-Kruskal\u7b97\u6cd5/index.md","sourceDirName":"001-\u8ba1\u4f6c\u5e38\u8b58/001-\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/005-\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/005-\u6700\u5c0f\u751f\u6210\u6811/002-Kruskal\u7b97\u6cd5","slug":"/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/\u6700\u5c0f\u751f\u6210\u6811/Kruskal\u7b97\u6cd5/","permalink":"/HXLoLi/docs/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/\u6700\u5c0f\u751f\u6210\u6811/Kruskal\u7b97\u6cd5/","draft":false,"unlisted":false,"editUrl":"https://github.com/HengXin666/HXLoLi/edit/main/docs/001-\u8ba1\u4f6c\u5e38\u8b58/001-\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/005-\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/005-\u6700\u5c0f\u751f\u6210\u6811/002-Kruskal\u7b97\u6cd5/index.md","tags":[],"version":"current","lastUpdatedBy":"Heng_Xin_666","lastUpdatedAt":1745851959000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"\u6700\u5c0f\u751f\u6210\u6811\u603b\u89c8","permalink":"/HXLoLi/docs/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/\u6700\u5c0f\u751f\u6210\u6811/\u6700\u5c0f\u751f\u6210\u6811\u603b\u89c8/"},"next":{"title":"Prim\u7b97\u6cd5","permalink":"/HXLoLi/docs/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u56fe/\u6700\u5c0f\u751f\u6210\u6811/Prim\u7b97\u6cd5/"}}');var d=i(74848),r=i(28453);const a={},s="Kruskal\u7b97\u6cd5",o={},c=[{value:"\u4ee3\u7801",id:"\u4ee3\u7801",level:2},{value:"\u8d2a\u5fc3\u7b97\u6cd5\u601d\u60f3",id:"\u8d2a\u5fc3\u7b97\u6cd5\u601d\u60f3",level:2},{value:"\u8d2a\u5fc3\u7b97\u6cd5\u7684\u57fa\u672c\u601d\u8def",id:"\u8d2a\u5fc3\u7b97\u6cd5\u7684\u57fa\u672c\u601d\u8def",level:2}];function l(n){const e={annotation:"annotation",blockquote:"blockquote",code:"code",div:"div",h1:"h1",h2:"h2",header:"header",li:"li",math:"math",mrow:"mrow",mtext:"mtext",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(e.header,{children:(0,d.jsx)(e.h1,{id:"kruskal\u7b97\u6cd5",children:"Kruskal\u7b97\u6cd5"})}),"\n",(0,d.jsxs)(e.p,{children:[(0,d.jsx)(e.strong,{children:"\u514b\u9c81\u65af\u5361\u5c14\u7b97\u6cd5(Kruskal)"})," \u662f\u4e00\u79cd\u4f7f\u7528\u8d2a\u5a6a\u65b9\u6cd5\u7684\u6700\u5c0f\u751f\u6210\u6811\u7b97\u6cd5\u3002\u8be5\u7b97\u6cd5\u521d\u59cb\u5c06\u56fe\u89c6\u4e3a\u68ee\u6797\uff0c\u56fe\u4e2d\u7684\u6bcf\u4e00\u4e2a\u9876\u70b9\u89c6\u4e3a\u4e00\u68f5\u5355\u72ec\u7684\u6811\u3002\u4e00\u68f5\u6811\u53ea\u4e0e\u5b83\u7684\u90bb\u63a5\u9876\u70b9\u4e2d\u6743\u503c\u6700\u5c0f\u4e14\u4e0d\u8fdd\u53cd\u6700\u5c0f\u751f\u6210\u6811\u5c5e\u6027\uff08\u4e0d\u6784\u6210\u73af\uff09\u7684\u6811\u4e4b\u95f4\u5efa\u7acb\u8fde\u8fb9\u3002"]}),"\n",(0,d.jsx)(e.p,{children:"\u4ece\u8fb9\u7684\u89d2\u5ea6\u6c42\u7f51\u7684\u6700\u5c0f\u751f\u6210\u6811\uff0c\u66f4\u9002\u5408\u4e8e\u6c42\u8fb9\u7a00\u758f\u7684\u7f51\u7684\u6700\u5c0f\u751f\u6210\u6811\u3002"}),"\n",(0,d.jsxs)(e.p,{children:[(0,d.jsxs)(e.span,{className:"katex",children:[(0,d.jsx)(e.span,{className:"katex-mathml",children:(0,d.jsx)(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,d.jsxs)(e.semantics,{children:[(0,d.jsx)(e.mrow,{children:(0,d.jsx)(e.mtext,{children:"\u57fa\u672c\u601d\u60f3"})}),(0,d.jsx)(e.annotation,{encoding:"application/x-tex",children:"\u57fa\u672c\u601d\u60f3"})]})})}),(0,d.jsx)(e.span,{className:"katex-html","aria-hidden":"true",children:(0,d.jsxs)(e.span,{className:"base",children:[(0,d.jsx)(e.span,{className:"strut",style:{height:"0.6833em"}}),(0,d.jsx)(e.span,{className:"mord cjk_fallback",children:"\u57fa\u672c\u601d\u60f3"})]})})]}),": ",(0,d.jsx)(e.strong,{children:"\u6309\u7167\u6743\u503c\u4ece\u5c0f\u5230\u5927"}),"\u7684\u987a\u5e8f\u9009\u62e9",(0,d.jsx)(e.code,{children:"n-1"}),"\u6761",(0,d.jsx)(e.strong,{children:"\u8fb9"}),"\uff0c\u5e76\u4fdd\u8bc1\u8fd9",(0,d.jsx)(e.code,{children:"n-1"}),"\u6761\u8fb9",(0,d.jsx)(e.strong,{children:"\u4e0d\u6784\u6210\u56de\u8def"}),"\u3002"]}),"\n",(0,d.jsx)(e.p,{children:"\u5177\u4f53\u505a\u6cd5\uff1a\u9996\u5148\u6784\u9020\u4e00\u4e2a\u53ea\u542bn\u4e2a\u9876\u70b9\u7684\u68ee\u6797\uff0c\u7136\u540e\u4f9d\u6743\u503c\u4ece\u5c0f\u5230\u5927\u4ece\u8fde\u901a\u7f51\u4e2d\u9009\u62e9\u8fb9\u52a0\u5165\u5230\u68ee\u6797\u4e2d\uff0c\u5e76\u4f7f\u68ee\u6797\u4e2d\u4e0d\u4ea7\u751f\u56de\u8def\uff0c\u76f4\u81f3\u68ee\u6797\u53d8\u6210\u4e00\u68f5\u6811\u4e3a\u6b62\u3002"}),"\n",(0,d.jsx)(e.p,{children:"\u4ee3\u7801\u7f16\u5199\u7684\u95ee\u9898\uff1a"}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsx)(e.li,{children:"\u95ee\u9898\u4e00: \u5bf9\u56fe\u7684\u6240\u6709\u8fb9\u6309\u7167\u6743\u503c\u5927\u5c0f\u8fdb\u884c\u6392\u5e8f\u3002"}),"\n",(0,d.jsx)(e.li,{children:"\u95ee\u9898\u4e8c: \u5c06\u8fb9\u6dfb\u52a0\u5230\u6700\u5c0f\u751f\u6210\u6811\u4e2d\u65f6\uff0c\u600e\u4e48\u6837\u5224\u65ad\u662f\u5426\u5f62\u6210\u4e86\u56de\u8def\u3002"}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"\u514b\u9c81\u65af\u5361\u5c14\u7b97\u6cd5\u7684\u5177\u4f53\u601d\u8def\u662f\uff1a"}),"\n",(0,d.jsxs)(e.div,{className:"markdown-alert markdown-alert-tip",children:["\n",(0,d.jsxs)(e.p,{className:"markdown-alert-title",children:[(0,d.jsx)(e.span,{className:"octicon octicon-tip",style:{"--oct-icon":"url(\"data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' class='octicon octicon-light-bulb mr-2' viewBox='0 0 16 16' version='1.1' width='16' height='16' aria-hidden='true'%3E%3Cpath d='M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z'%3E%3C/path%3E%3C/svg%3E\")"}}),"Tip"]}),"\n",(0,d.jsx)(e.p,{children:"\u5c06\u6240\u6709\u8fb9\u6309\u7167\u6743\u503c\u7684\u5927\u5c0f\u8fdb\u884c\u5347\u5e8f\u6392\u5e8f\uff0c\u7136\u540e\u4ece\u5c0f\u5230\u5927\u4e00\u4e00\u5224\u65ad\uff0c\u6761\u4ef6\u4e3a\uff1a"}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsx)(e.p,{children:"\u5982\u679c\u8fd9\u4e2a\u8fb9\u4e0d\u4f1a\u4e0e\u4e4b\u524d\u9009\u62e9\u7684\u6240\u6709\u8fb9\u7ec4\u6210\u56de\u8def\uff0c\u5c31\u53ef\u4ee5\u4f5c\u4e3a\u6700\u5c0f\u751f\u6210\u6811\u7684\u4e00\u90e8\u5206\uff1b\u53cd\u4e4b\uff0c\u820d\u53bb\u3002"}),"\n"]}),"\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsx)(e.p,{children:"\u76f4\u5230\u5177\u6709 n \u4e2a\u9876\u70b9\u7684\u8fde\u901a\u7f51\u7b5b\u9009\u51fa\u6765 n-1 \u6761\u8fb9\u4e3a\u6b62\u3002\u7b5b\u9009\u51fa\u6765\u7684\u8fb9\u548c\u6240\u6709\u7684\u9876\u70b9\u6784\u6210\u6b64\u8fde\u901a\u7f51\u7684\u6700\u5c0f\u751f\u6210\u6811\u3002"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.blockquote,{children:["\n",(0,d.jsx)(e.p,{children:"\u5224\u65ad\u662f\u5426\u4f1a\u4ea7\u751f\u56de\u8def\u7684\u65b9\u6cd5\u4e3a\uff1a\u5728\u521d\u59cb\u72b6\u6001\u4e0b\u7ed9\u6bcf\u4e2a\u9876\u70b9\u8d4b\u4e88\u4e0d\u540c\u7684\u6807\u8bb0\uff0c\u5bf9\u4e8e\u904d\u5386\u8fc7\u7a0b\u7684\u6bcf\u6761\u8fb9\uff0c\u5176\u90fd\u6709\u4e24\u4e2a\u9876\u70b9\uff0c\u5224\u65ad\u8fd9\u4e24\u4e2a\u9876\u70b9\u7684\u6807\u8bb0\u662f\u5426\u4e00\u81f4\uff0c\u5982\u679c\u4e00\u81f4\uff0c\u8bf4\u660e\u5b83\u4eec\u672c\u8eab\u5c31\u5904\u5728\u4e00\u68f5\u6811\u4e2d\uff0c\u5982\u679c\u7ee7\u7eed\u8fde\u63a5\u5c31\u4f1a\u4ea7\u751f\u56de\u8def\uff1b\u5982\u679c\u4e0d\u4e00\u81f4\uff0c\u8bf4\u660e\u5b83\u4eec\u4e4b\u95f4\u8fd8\u6ca1\u6709\u4efb\u4f55\u5173\u7cfb\uff0c\u53ef\u4ee5\u8fde\u63a5\u3002"}),"\n"]}),"\n",(0,d.jsx)(e.h2,{id:"\u4ee3\u7801",children:"\u4ee3\u7801"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-C++",children:'#include <stdio.h>\n#include <stdlib.h>\n\n#define ARR_LEN_MAX 12\ntypedef int Element;\n\n// \u672c\u8d28\u662f\u6811\u7684\u7ebf\u6027\u5b58\u50a8\u7ed3\u6784\ntypedef struct\n{\n    Element *data;      // \u6570\u636e\n    int len;            // \u6700\u5927\u957f\u5ea6\n    int n;              // \u5f53\u524d\u5143\u7d20\u4e2a\u6570 (\u53ef\u4ee5\u7528\u4f5c\u7d22\u5f15)\n    int *father_index;  // \u7236\u7d22\u5f15\n    int *node_size;     // \u4ee5\u5f53\u524d\u7ed3\u70b9\u4e3a\u6839\u7684\u603b\u7684\u7ed3\u70b9\u6570, \u9ed8\u8ba4\u662f 1 (\u72ec\u7acb\u4e2a\u4f53)\n} QU;\n\nQU *initQU(void);                           // \u521d\u59cb\u5316\u5e76\u67e5\u96c6\nvoid addQUNode(QU *Q, Element e);           // \u5728QU\u4e2d\u521b\u5efa\u5b64\u7acb\u7684\u7ed3\u70b9\n_Bool QUUnion(QU *Q, Element a, Element b); // \u5c06\u4e24\u4e2a\u5143\u7d20\u6240\u5728\u96c6\u5408\u5408\u5e76\u5230\u4e00\u4e2a\u96c6\u5408\n_Bool QUFind(QU *Q, Element a, Element b);  // \u67e5\u8be2 a\u4e0eb \u5143\u7d20\u662f\u4e0d\u662f\u5728\u540c\u4e00\u4e2a\u96c6\u5408\n\nQU *initQU(void)\n{\n    QU *Q = (QU *)malloc(sizeof(QU));\n    if (Q == NULL)\n    {\n        printf("ERROR - malloc - QU\\n");\n        return NULL;\n    }\n\n    Q->len = ARR_LEN_MAX;\n    Q->n = 0;\n\n    Q->data = (Element *)malloc(sizeof(Element) * ARR_LEN_MAX);\n    if (Q->data == NULL)\n    {\n        printf("ERROR - malloc - data\\n");\n        return NULL;\n    }\n\n    Q->father_index = (int *)malloc(sizeof(int) * ARR_LEN_MAX);\n    if (Q->father_index == NULL)\n    {\n        printf("ERROR - malloc - f_i\\n");\n        return NULL;\n    }\n\n    Q->node_size = (int *)malloc(sizeof(int) * ARR_LEN_MAX);\n    if (Q->node_size == NULL)\n    {\n        printf("ERROR - malloc - n_s\\n");\n        return NULL;\n    }\n\n    return Q;\n}\n\nstatic _Bool addLenQU(QU *Q)\n{\n    // \u52a0\u957f\u6570\u7ec4\n    Element *data_a = Q->data;\n    int *index_a = Q->father_index;\n    int *size_a = Q->node_size;\n\n    Q->len += ARR_LEN_MAX;  // \u8fd9\u4e2a\u53ef\u4ee5\u81ea\u5df1\u6539 (*2\u4ec0\u4e48\u7684)\n\n    Q->data = (Element *)malloc(sizeof(Element) * Q->len);\n    if (Q->data == NULL)\n    {\n        printf("ERROR - malloc - data\\n");\n        return 1;\n    }\n\n    Q->father_index = (int *)malloc(sizeof(int) * Q->len);\n    if (Q->father_index == NULL)\n    {\n        printf("ERROR - malloc - f_i\\n");\n        return 1;\n    }\n\n    Q->node_size = (int *)malloc(sizeof(int) * Q->len);\n    if (Q->node_size == NULL)\n    {\n        printf("ERROR - malloc - n_s\\n");\n        return 1;\n    }\n\n    for (int i = 0; i < Q->n; ++i)\n    {\n        Q->data[i] = data_a[i];\n        Q->father_index[i] = index_a[i];\n        Q->node_size[i] = size_a[i];\n    }\n\n    free(data_a);\n    free(index_a);\n    free(size_a);\n\n    return 0;\n}\n\nvoid addQUNode(QU *Q, Element e)\n{\n    if (Q->n == Q->len)\n    {\n        // \u957f\u5ea6\u8fc7\u957f, \u9700\u8981\u4fee\u6539\n        if (addLenQU(Q))\n        {\n            printf("ERROR: Add Node\\n");\n            return;\n        }\n    }\n\n    Q->data[Q->n] = e;\n    Q->father_index[Q->n] = Q->n;\n    Q->node_size[Q->n] = 1;\n    ++Q->n;\n}\n\n#define _LujinYaSuo_    // \u5220\u9664\u6216\u8005\u6ce8\u91ca\u8fd9\u91cc\u5c31\u53ef\u4ee5\u4f7f\u7528\u4e0b\u9762 \u666e\u901a\u7b97\u6cd5\n#ifndef _LujinYaSuo_\n// \u666e\u901a\u7b97\u6cd5 (size)\nstatic int getQUNodeIndex(QU *Q, Element e)\n{\n    // \u5bfb\u627e\u7ed3\u70b9e\u7684\u7956\u5148\u7ed3\u70b9\u7684\u7d22\u5f15, \u5982\u679c\u627e\u4e0d\u5230\u5219\u8fd4\u56de-1\n    for (int i = 0; i < Q->n; ++i)\n    {\n        if (Q->data[i] == e)\n        {\n            while (Q->father_index[i] != i)\n            {\n                i = Q->father_index[i];\n            }\n\n            return i;\n        }\n    }\n    return -1;\n}\n#else\n// \u8def\u5f84\u538b\u7f29: \u4f7f\u5f97\u6811\u7684\u9ad8\u5ea6\u53d8\u5c0f, \u5982\u679c\u5728\u5408\u5e76\u96c6\u5408\u7684\u65f6\u5019, \u5355\u72ec\u6765\u8fdb\u884c\u538b\u7f29, \u663e\u7136\u4e5f\u662f\u4f1a\u6d6a\u8d39\u4e00\u4e9b\u65f6\u95f4\u7684\n// \u4f46\u5982\u679c\u5728\u67e5\u627e\u7956\u5148\u7ed3\u70b9\u7684\u8def\u4e0a, \u987a\u4fbf\u628a\u7ed3\u70b9\u7ed9\u5b58\u50a8\u8d77\u6765, \u7b49\u627e\u5230\u4e86\u7956\u5148\u7ed3\u70b9,, \u518d\u4f9d\u6b21\u5c06\u4ed6\u4eec\u7684\u7236\u7ed3\u70b9\u6539\u4e3a\u7956\u5148\u7ed3\u70b9\u4e0d\u5c31\u5b8c\u7f8e\u4e86\u5417\n// \u90a3\u4e48\u4e0b\u6b21\u5c31\u53ef\u4ee5\u751f\u6548\u4e86!\n// \u5f53\u7136, \u8def\u4e0a\u9047\u5230\u7684\u7ed3\u70b9\u4e5f\u662f\u9700\u8981\u5b58\u50a8\u8d77\u6765\u7684, \u6bd5\u7adf\u627e\u7956\u5148\u7684\u8def\u300c\u4e00\u65b9\u901a\u884c\u300d\n// \u6240\u4ee5, \u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a\u4e1c\u897f\u5b58\u50a8, \u56e0\u4e3a\u5bf9\u987a\u5e8f\u6ca1\u6709\u4ec0\u4e48\u8981\u6c42, \u6240\u4ee5\u7406\u8bba\u4e0a\u4efb\u4f55\u4e1c\u897f\u90fd\u53ef\u4ee5\u62ff\u6765\u5b58\u50a8, \u6808/\u961f\u5217...\n// \u8fd9\u91cc\u4f7f\u7528\u6808\u6765\u8fdb\u884c\u6f14\u793a\n\n// \u56e0\u4e3a\u8fd9\u4e2a\u6808\u662f\u4e13\u95e8\u4e3a\u4e86\u8fd9\u4e2a\u51fd\u6570\u5b9a\u5236\u7684, \u6240\u4ee5\u53ef\u4ee5\u4e0d\u7528\u90a3\u4e48\u6807\u51c6(?), \u8fd9\u4e2a\u5c31\u662f\u4e34\u65f6\u6808\n// (\u7531\u4e8e\u8def\u4e0a\u4f1a\u9047\u5230\u591a\u5c11\u4e2a\u7ed3\u70b9\u6211\u4eec\u4e0d\u77e5\u9053, \u6240\u4ee5\u4f7f\u7528\u94fe\u5f0f\u7ed3\u6784\u5b58\u50a8)\n\ntypedef struct _QU_stack_node\n{\n    int data_index;         // \u8bb0\u5f55\u7ed3\u70b9\u7684\u7d22\u5f15\u5c31\u53ef\u4ee5\u4e86 (\u6211\u7684\u610f\u601d\u662f, \u5f53\u524d\u7684i, \u7136\u540e\u662f\u7236\u4eb2\u7ed3\u70b9i...)\n    struct _QU_stack_node *next;\n} _QU_stack_node;\n\ntypedef struct\n{\n    _QU_stack_node *top;    // NULL \u5c31\u662fok\u4e86\u561b\n} _QU_stack;\n\nstatic _Bool _pushQUS(_QU_stack *S, int index)\n{\n    _QU_stack_node *node = (_QU_stack_node *)malloc(sizeof(_QU_stack_node));\n    if (!node)\n    {\n        printf("ERROR - malloc - Snode\\n");\n        return 0;\n    }\n    node->data_index = index;\n    node->next = S->top;\n    S->top = node;\n    return 1;\n}\n\nstatic _Bool _popQUS(_QU_stack *S, int *index)\n{\n    if (S->top == NULL)\n        return 0;\n    _QU_stack_node *tmp = S->top;\n    *index = tmp->data_index;\n    S->top = tmp->next;\n    free(tmp);\n    return 1;\n}\n\nstatic int getQUNodeIndex(QU *Q, Element e)\n{\n    // \u521b\u5efa\u4e00\u4e2a\u4e34\u65f6\u6808\u7528\u4e8e\u8def\u5f84\u538b\u7f29\n    _QU_stack *S = (_QU_stack *)malloc(sizeof(_QU_stack));\n    if (S == NULL)\n    {\n        printf("ERROR - malloc - S\\n");\n        return -1;\n    }\n    S->top = NULL;\n\n    // \u5bfb\u627e\u7ed3\u70b9e\u7684\u7956\u5148\u7ed3\u70b9\u7684\u7d22\u5f15, \u5982\u679c\u627e\u4e0d\u5230\u5219\u8fd4\u56de-1\n    for (int i = 0; i < Q->n; ++i)\n    {\n        if (Q->data[i] == e)\n        {\n            while (Q->father_index[i] != i)\n            {\n                _pushQUS(S, i);\n                i = Q->father_index[i];\n            }\n\n            int index;\n            while (_popQUS(S, &index))\n            {\n                Q->father_index[index] = i;\n            }\n\n            return i;\n        }\n    }\n    return -1;\n}\n\n#endif\n\n_Bool QUFind(QU *Q, Element a, Element b)\n{\n    int aRoot_index = getQUNodeIndex(Q, a);\n    if (aRoot_index == -1)\n    {\n        printf("\u6ca1\u6709\u627e\u5230\u5143\u7d20 %c \u4e8e\u5e76\u67e5\u96c6\u4e2d!\\n", a);\n        return 0;\n    }\n\n    int bRoot_index = getQUNodeIndex(Q, b);\n    if (bRoot_index == -1)\n    {\n        printf("\u6ca1\u6709\u627e\u5230\u5143\u7d20 %c \u4e8e\u5e76\u67e5\u96c6\u4e2d!\\n", b);\n        return 0;\n    }\n\n    return aRoot_index == bRoot_index;\n}\n\n_Bool QUUnion(QU *Q, Element a, Element b)\n{\n    // \u8fd4\u56de\u503c\u4e3a 0 \u662f\u6267\u884c\u5931\u8d25, \u53cd\u4e4b\u6210\u529f (1)\n    // \u5408\u5e76\u5143\u7d20: \u9009\u62e9\u5c06 a, b \u4e2d \u7ed3\u70b9\u6570(node_size)\u6700\u5c0f\u7684\u5408\u5e76\u5230\u7ed3\u70b9\u6570\u5927\u7684\u53bb, \u5982\u679c\u7ed3\u70b9\u6570\u76f8\u540c\u5219 a--\x3eb (a\u5408\u5e76\u5230b\u53bb)\n    // 1. \u627e\u5230a, b\u7684\u7d22\u5f15\n    int aRoot_index = getQUNodeIndex(Q, a);\n    if (aRoot_index == -1)\n    {\n        printf("\u6ca1\u6709\u627e\u5230\u5143\u7d20 %c \u4e8e\u5e76\u67e5\u96c6\u4e2d!\\n", a);\n        return 0;\n    }\n\n    int bRoot_index = getQUNodeIndex(Q, b);\n    if (bRoot_index == -1)\n    {\n        printf("\u6ca1\u6709\u627e\u5230\u5143\u7d20 %c \u4e8e\u5e76\u67e5\u96c6\u4e2d!\\n", b);\n        return 0;\n    }\n\n    if (aRoot_index == bRoot_index)\n    {\n        printf("\u4e0d\u80fd\u5408\u5e76\u4e00\u4e2a\u76f8\u540c\u7684\u5143\u7d20!\\n");\n        return 0;\n    }\n\n    if (Q->node_size[aRoot_index] > Q->father_index[bRoot_index])\n    {\n        // B --\x3e A\n        Q->father_index[bRoot_index] = aRoot_index;\n        Q->node_size[aRoot_index] += Q->node_size[bRoot_index];\n    }\n    else\n    {\n        // A --\x3e B\n        Q->father_index[aRoot_index] = bRoot_index;\n        Q->node_size[bRoot_index] += Q->node_size[aRoot_index];\n    }\n    return 1;\n}\n\ntypedef struct\n{\n    char **show;\n    int **weight;\n    int *tagArray;  // \u7528\u4e8e\u904d\u5386\u65f6\u5019\u7684\u6807\u8bb0\n    int side_num;   // \u8fb9\u7684\u4e2a\u6570\n    int add_index;\n    int number;\n} AdjacencyMatrix;\n\nAdjacencyMatrix *initAdjacencyMatrix(int n);                // \u521d\u59cb\u5316AdjacencyMatrix\nvoid addAdjacencyMatrix(AdjacencyMatrix *A, char *show);    // \u6dfb\u52a0\u5143\u7d20\nvoid connectAdjacencyMatrix(AdjacencyMatrix *A, char *show_1, char *show_2, int weight);    // \u8fde\u63a5\u5143\u7d20\nvoid initTagArray(AdjacencyMatrix *A);                      // \u91cd\u7f6e\u904d\u5386\u7684\u6807\u8bb0\u6570\u7ec4 (-1)\nvoid DFS(AdjacencyMatrix *A, int index);                    // \u6df1\u5ea6\u4f18\u5148\u904d\u5386\nvoid BFS(AdjacencyMatrix *A);                               // \u5e7f\u5ea6\u4f18\u5148\u904d\u5386\nvoid freeAdjacencyMatrix(AdjacencyMatrix *A);               // \u514d\u8d39\n\nAdjacencyMatrix *initAdjacencyMatrix(int n)\n{\n    AdjacencyMatrix *A = (AdjacencyMatrix *)malloc(sizeof(AdjacencyMatrix));\n    if (!A)\n    {\n        MALLOC_ERROR:\n        printf("Malloc ERROR!\\n");\n        return NULL;\n    }\n\n    A->show = (char **)malloc(sizeof(char *) * n);\n    if (!A->show)\n        goto MALLOC_ERROR;\n    \n    A->weight = (int **)malloc(sizeof(int *) * n);\n    if (!A->weight)\n        goto MALLOC_ERROR;\n\n    for (int i = 0; i < n; ++i)\n    {\n        A->weight[i] = (int *)malloc(sizeof(int) * n);\n        if (!A->weight[i])\n            goto MALLOC_ERROR;\n        for (int j = 0; j < n; ++j)\n            A->weight[i][j] = 0;        // \u8fd9\u4e2a\u662f\u6807\u8bb0\u6570_\u53ef\u6539, \u8bb00\u4e3a\u672a\u8fde\u63a5\n    }\n    \n    A->side_num = 0;\n    A->add_index = 0;\n    A->number = n;\n    A->tagArray = (int *)malloc(sizeof(int) * n);\n    if (!A->tagArray)\n        goto MALLOC_ERROR;\n    initTagArray(A);\n    return A;\n}\n\nvoid addAdjacencyMatrix(AdjacencyMatrix *A, char *show)\n{\n    if (A->add_index == A->number)\n        return; // ERROR\n    A->show[A->add_index++] = show;\n}\n\nvoid initTagArray(AdjacencyMatrix *A)\n{\n    for (int i = 0; i < A->number; ++i)\n        A->tagArray[i] = -1;\n}\n\nvoid connectAdjacencyMatrix(AdjacencyMatrix *A, char *show_1, char *show_2, int weight)\n{\n    int s_1 = -1;\n    for (int i = 0; i < A->number; ++i)\n    {\n        if (A->show[i] == show_1)\n            s_1 = i;\n    }\n\n    if (s_1 == -1)\n        return; // \u627e\u4e0d\u5230\n    \n    int s_2 = -1;\n    for (int i = 0; i < A->number; ++i)\n    {\n        if (A->show[i] == show_2)\n            s_2 = i;\n    }\n\n    if (s_2 == -1)\n        return; // \u627e\u4e0d\u5230\n    \n    A->weight[s_1][s_2] = weight;\n    A->weight[s_2][s_1] = weight;\n    ++A->side_num;\n}\n\n// \u6ce8\u610f\u904d\u5386\u7684\u662f\u8fde\u901a\u56fe\nvoid DFS(AdjacencyMatrix *A, int index)\n{\n    printf("%s ", A->show[index]);\n    A->tagArray[index] = 1;\n    for (int i = 0; i < A->add_index; ++i)\n    {\n        if (A->weight[index][i] != 0 && A->tagArray[i] == -1)\n        {\n            DFS(A, i);\n        }\n    }\n}\n\n// \u4f9d\u65e7\u662f\u8fde\u901a\u56fe\n// \u590d\u6742\u8fc7\u5934\u4e86\u5427...\nvoid BFS(AdjacencyMatrix *A)\n{\n    // \u4e34\u65f6\u961f\u5217\n    int queue[A->add_index];\n    int q_h = 0;\n    int q_t = 0;\n    printf("%s ", A->show[0]);\n    A->tagArray[0] = 1;\n    for (int i = 0; i < A->add_index; ++i)\n    {\n        for (int j = 0; j < A->add_index; ++j)\n        {\n            if (A->weight[i][j] != 0 && A->tagArray[j] == -1)\n            {\n                A->tagArray[j] = 1;\n                queue[q_t++] = j;\n                q_t = q_t % A->add_index;\n            }\n        }\n\n        if (q_h != q_t)\n            break;\n    }\n    \n    while (q_h != q_t)\n    {\n        printf("%s ", A->show[queue[q_h]]);\n        for (int i = 0; i < A->add_index; ++i)\n        {\n            if (A->weight[queue[q_h]][i] != 0 && A->tagArray[i] == -1)\n            {\n                A->tagArray[q_t == 0 ? A->add_index - 1 : q_t - 1] = 1;\n                queue[q_t++] = i;\n                q_t = q_t % A->add_index;\n            }\n        }\n        ++q_h;\n        q_h = q_h % A->add_index;\n    }\n}\n\nvoid freeAdjacencyMatrix(AdjacencyMatrix *A)\n{\n    free(A->show);\n    for (int i = 0; i < A->number; ++i)\n    {\n        free(A->weight[i]);\n    }\n    free(A->weight);\n    free(A->tagArray);\n    free(A);\n}\n\ntypedef struct\n{\n    int begin;  // \u5f00\u59cb\u7aef\u70b9\n    int end;    // \u7ed3\u675f\u7aef\u70b9\n    int weight; // \u6743\n} Edge;\n\ntypedef struct\n{\n    int *vertex;    // \u9876\u70b9\u96c6 (G\u7684\u7d22\u5f15)\n    Edge *side;     // \u8fb9\u96c6\n    int side_len;   // \u8fb9\u96c6\u957f\u5ea6\n    int vertex_len; // \u9876\u70b9\u96c6\u957f\u5ea6\n} EdgeSet;      // \u8fb9\u96c6\u6570\u7ec4\n\n// \u8f6c\u5316\u4e3a\u8fb9\u96c6\u6570\u7ec4\nEdgeSet *adjacencyMatrix_to_edgeSet(AdjacencyMatrix *G);\n\n// Kruskal\nEdgeSet *kruskal(AdjacencyMatrix *G);   // \u7ed9\u5165\u4e00\u4e2a \u90bb\u63a5\u77e9\u9635, \u8fd4\u56de\u4e00\u4e2a\u6700\u5c0f\u751f\u6210\u6811\n\n// \u83b7\u53d6\u6743\u548c\nint getWeightSum(const AdjacencyMatrix *G,const EdgeSet *E)\n{\n    int res = 0;\n    printf("\u6700\u5c0f\u751f\u6210\u6811\u8fb9\u4e3a %d\\n", E->side_len);\n    for (int i = 0; i < E->side_len; ++i)\n    {\n        // printf("%d--%d--%d\\n", E->side[i].begin, E->side[i].weight, E->side[i].end);\n        printf("%s--%d--%s\\n", G->show[E->side[i].begin], E->side[i].weight, G->show[E->side[i].end]);\n        res += E->side[i].weight;\n    }\n    return res;\n}\n\n// \u4ea4\u6362\nstatic void _exchange(int *a, int *b)\n{\n    *a = *a ^ *b;\n    *b = *a ^ *b;\n    *a = *a ^ *b;\n}\n\n// \u5192\u6ce1\u6392\u5e8f\nstatic void _bubble_sort(EdgeSet *eSet)\n{\n    _Bool tag = 1;\n    for (int i = 0; i < eSet->side_len; ++i)\n    {\n        tag = 1;\n        for (int j = i + 1; j < eSet->side_len; ++j)\n        {\n            if (eSet->side[i].weight > eSet->side[j].weight)\n            {\n                _exchange(&eSet->side[i].begin, &eSet->side[j].begin);\n                _exchange(&eSet->side[i].end, &eSet->side[j].end);\n                _exchange(&eSet->side[i].weight, &eSet->side[j].weight);\n                tag = 0;\n            }\n        }\n\n        if (tag)\n            return;\n    }\n}\n\nEdgeSet *kruskal(AdjacencyMatrix *G)\n{\n    // \u8f6c\u5316\u4e3a\u8fb9\u96c6\u6570\u7ec4\n    EdgeSet *eSet = adjacencyMatrix_to_edgeSet(G);\n\n    // \u5bf9\u8fb9\u96c6\u6570\u7ec4 \u6309\u6743\u8fdb\u884c\u6392\u5e8f\n    _bubble_sort(eSet);\n\n    // getWeightSum(G, eSet);\n\n    // ---\u5f00\u59cbkruskal\u7b97\u6cd5---\n\n    // \u6709 BUG ! \u4e0d\u80fd\u53ea\u521b\u5efa\u4e00\u4e2a, \u56e0\u4e3a\u4e00\u5f00\u59cb\u4ed6\u4eec\u8fb9\u4e0d\u662f\u76f8\u901a\u7684\u53ef\u80fd\u51fa\u73b0 A B \u5728 unionFind[] \u91cc\u9762, \u4f46\u662f A-C B-D \u8fde\u63a5\u9020\u6210\u7684, \u5b9e\u9645\u4e0a B-C\u6ca1\u6709\u8fde\u63a5\n    // \u521b\u5efa \u4e34\u65f6\u5e76\u67e5\u96c6, \u53ea\u9700\u8981\u521b\u5efa\u4e00\u4e2a, \u5176\u4ed6\u7684\u53ea\u8981\u5224\u65ad\u662f\u5426\u5728\u8fd9\u4e2a\u91cc\u9762\u5373\u53ef\n        // \u5728\u5219\u5df2\u8fde\u901a(\u4e0d\u53ef\u6dfb\u52a0), \u4e0d\u5728\u5219\u6dfb\u52a0\n    // int *unionFind = (int *)malloc(sizeof(int) * eSet->vertex_len);\n    // int index_UF = 0;\n    // \u56e0\u4e3a\u5b58\u7684\u662f\u7ed3\u70b9, \u90a3\u4e48\u6700\u5927\u6570\u91cf\u662f\u7ed3\u70b9\u6570\n\n    // \u5e76\u67e5\u96c6\n    QU* uf = initQU();\n    for (int i = 0; i < eSet->vertex_len; ++i)\n        addQUNode(uf, eSet->vertex[i]);\n\n    // \u521b\u5efa \u8fd4\u56de\u7684\u8fb9\u96c6\u6570\u7ec4\n    EdgeSet *resES = (EdgeSet *)malloc(sizeof(EdgeSet));\n    if (!resES)\n    {\n        ERROR:\n        printf("malloc error!\\n");\n        return NULL;\n    }\n\n    resES->side = (Edge *)malloc(sizeof(Edge) * (eSet->vertex_len - 1));\n    if (!resES->side)\n        goto ERROR;\n\n    // resES->vertex = (int *)malloc(sizeof(int) * eSet->side_len);\n    // if (!resES->vertex)\n    //     goto ERROR;\n\n    resES->vertex = eSet->vertex;\n    resES->side_len = eSet->vertex_len - 1; // dddd\n    resES->vertex_len = eSet->vertex_len;\n\n    // \u6b63\u5f0f\u5f00\u59cb\n    int side_index = 0;\n    for (int i = 0; i < eSet->side_len; ++i)\n    {\n        // int j = 0;\n        // int k = 0;\n        // int noAdd = -1;\n        // for (; j < index_UF && k < 2; ++j)\n        // {\n        //     if (unionFind[j] == eSet->side[i].begin)\n        //     {\n        //         ++k;\n        //         noAdd = eSet->side[i].begin;\n        //     }\n        //     else if (unionFind[j] == eSet->side[i].end)\n        //     {\n        //         ++k;\n        //         noAdd = eSet->side[i].end;\n        //     }\n        // }\n\n        if (!QUFind(uf, eSet->side[i].begin, eSet->side[i].end))\n        {\n            resES->side[side_index].begin = eSet->side[i].begin;\n            resES->side[side_index].end = eSet->side[i].end;\n            resES->side[side_index].weight = eSet->side[i].weight;\n            // printf("\\n%d == %d\\n",  resES->side[side_index].weight, eSet->side[i].weight);\n            ++side_index;\n\n            // if (noAdd == -1)\n            // {\n                // unionFind[index_UF++] = eSet->side[i].begin;\n                // unionFind[index_UF++] = eSet->side[i].end;\n            QUUnion(uf, eSet->side[i].begin, eSet->side[i].end);\n            // }\n            // else\n            // {\n            //     // unionFind[index_UF++] = noAdd != eSet->side[i].begin ? eSet->side[i].begin : eSet->side[i].end;\n\n            // }\n        }\n        // getWeightSum(G, resES);\n    }\n    \n    // free(unionFind);\n    free(eSet->side);\n    free(eSet);\n    \n    return resES;\n}\n\nEdgeSet *adjacencyMatrix_to_edgeSet(AdjacencyMatrix *G)\n{\n    EdgeSet *resES = (EdgeSet *)malloc(sizeof(EdgeSet));\n    if (!resES)\n        return NULL;\n\n    resES->side = (Edge *)malloc(sizeof(Edge) * G->side_num);\n    if (!resES->vertex)\n        return NULL;\n\n    resES->vertex = (int *)malloc(sizeof(int) * G->add_index);\n    if (!resES->vertex)\n        return NULL;\n\n    resES->side_len = G->side_num;\n    resES->vertex_len = G->add_index;\n\n    // \u6784\u5efa\n    for (int i = 0, k = 0; i < G->add_index; ++i)\n    {\n        resES->vertex[i] = i;\n        for (int j = i + 1; j < G->add_index; ++j)\n        {\n            if (G->weight[i][j] != 0)   // \u5b9a\u4e49\u4e86 0\u662f\u65e0\u6548\u503c\n            {\n                resES->side[k].begin = i;\n                resES->side[k].end = j;\n                resES->side[k].weight = G->weight[i][j];\n                // printf("%s--%d--%s\\n", G->show[i], G->weight[i][j], G->show[j]);\n                ++k;\n            }\n        }\n    }\n    // printf("--END--\\n");\n    return resES;\n}\n\n\n\nvoid text(void)\n{\n    AdjacencyMatrix *A = initAdjacencyMatrix(6);\n    addAdjacencyMatrix(A, "A");\n    addAdjacencyMatrix(A, "B");\n    addAdjacencyMatrix(A, "C");\n    addAdjacencyMatrix(A, "D");\n    addAdjacencyMatrix(A, "E");\n    addAdjacencyMatrix(A, "F");\n    connectAdjacencyMatrix(A, "E", "F", 5);\n    connectAdjacencyMatrix(A, "E", "A", 2);\n    connectAdjacencyMatrix(A, "E", "C", 4);\n    connectAdjacencyMatrix(A, "E", "B", 10);\n    connectAdjacencyMatrix(A, "A", "F", 3);\n    connectAdjacencyMatrix(A, "D", "F", 4);\n    connectAdjacencyMatrix(A, "D", "C", 1);\n    connectAdjacencyMatrix(A, "B", "C", 3);\n    connectAdjacencyMatrix(A, "B", "A", 7);\n\n    DFS(A, 0);\n    putchar(\'\\n\');\n    EdgeSet *eSet = kruskal(A);\n    \n    printf("\\n\u6700\u5c0f\u751f\u6210\u6811\u7684\u6743\u548c\u662f %d\\n", getWeightSum(A, eSet));\n\n    // \u91ca\u653epass\n}\n\nint main(void)\n{\n    //  - \u6700\u5c0f\u751f\u6210\u6811 - Kruskal\u7b97\u6cd5 - \u65e0\u5411\u6709\u6743\u56fe\n    // \u5bfb\u627e\u8fde\u901a\u56fe\u7684 \u6743\u548c\u6700\u5c0f \u8fde\u901a\u5b50\u56fe, \u65e0\u73af\n\n    /*\n    *   Kruskal\u7b97\u6cd5\n    *   \u4f7f\u7528\u8d2a\u5a6a\u7684\u601d\u60f3: \u6743\u548c\u6700\u5c0f --\x3e  \u5c06\u53d8\u6309\u6743\u7531\u5c0f\u5230\u5927\u6392\u5e8f, \u4f9d\u6b21\u9009\u62e9\u6700\u5c0f.\u6b21\u5c0f.\u5373\u53ef\n    *                               \u4f46\u662f\u8fd9\u6837\u76f2\u76ee\u9009\u62e9, \u4f1a\u5bfc\u81f4\u6210\u73af, \u6545\u6709:\n    *   \n    *   Kruskal\u7b97\u6cd5:    \u5c06\u53d8\u6309\u6743\u7531\u5c0f\u5230\u5927\u6392\u5e8f, \u5728\u4fdd\u8bc1\u4e0d\u4f1a\u6210\u73af\u7684\u60c5\u51b5\u4e0b, \u4f9d\u6b21\u9009\u62e9\u6700\u5c0f.\u6b21\u5c0f.\n    * \n    *   \u53ef\u884c\u6027\u5206\u6790:\n    *       1. \u5982\u4f55\u5224\u65ad\u662f\u5426\u6210\u73af?\n    *           \u5e76\u67e5\u96c6\n    *               \u4f8b:\n    *                   \u9009\u62e9\u5230\u8fb9L, \u5224\u65ad\u8be5\u8fb9\u7684\u7aef\u70b9 A,B,\n    *                   \u5982\u679c A\u7684\u7956\u5148 == B\u7684\u7956\u5148, \u90a3\u4e48 A\u4e0eB\u5df2\u7ecf\u76f8\u901a, \u518d\u6dfb\u52a0\u8fb9L\u5c31\u4f1a\u6210\u73af, \u6240\u4ee5Pass\n    *                   \u53cd\u4e4b\u6ca1\u95ee\u9898\n    *                   // (\u5168\u90e8\u7ed3\u70b9\u6700\u521d\u65f6\u662f\u4ee5\u81ea\u5df1\u4e3a\u7956\u5148\u7ed3\u70b9(\u5747\u4e0d\u76f8\u8fde))\n    * \n    *       2. \u65e2\u7136\u7b97\u6cd5\u662f\u901a\u8fc7\u8fb9\u6765\u5224\u65ad, \u90a3\u4e48\u5982\u4f55\u5feb\u901f\u901a\u8fc7\u8fb9\u6765\u627e\u5230\u9876\u70b9?\n    *           \u4f7f\u7528 \u8fb9\u96c6\u6570\u7ec4\n    *               \u6ce8: \u5728\u56fe\u91cc\u9762, \u5e7f\u6cdb\u4f7f\u7528\u7684\u6570\u636e\u7ed3\u6784\u662f \u90bb\u63a5\u77e9\u9635 \u4e0e \u90bb\u63a5\u8868\n    *                   \u56e0\u6b64, \u6700\u597d\u53ef\u4ee5\u5728\u7b97\u6cd5\u5185\u90e8\u5b9e\u73b0\u8f6c\u5316, \u4ee5\u517c\u5bb9\n    * */\n    text();\n    getchar();\n    return 0;\n}\n'})}),"\n",(0,d.jsx)(e.h1,{id:"\u8d2a\u5a6a\u7b97\u6cd5",children:"\u8d2a\u5a6a\u7b97\u6cd5"}),"\n",(0,d.jsx)(e.h2,{id:"\u8d2a\u5fc3\u7b97\u6cd5\u601d\u60f3",children:"\u8d2a\u5fc3\u7b97\u6cd5\u601d\u60f3"}),"\n",(0,d.jsxs)(e.p,{children:[(0,d.jsx)(e.strong,{children:"\u8d2a\u5fc3\u7b97\u6cd5\u603b\u662f\u4f5c\u51fa\u5728\u5f53\u524d\u770b\u6765\u6700\u597d\u7684\u9009\u62e9"}),"\u3002\u4e5f\u5c31\u662f\u8bf4\u8d2a\u5fc3\u7b97\u6cd5\u5e76",(0,d.jsx)(e.strong,{children:"\u4e0d\u4ece\u6574\u4f53\u6700\u4f18\u8003\u8651"}),"\uff0c\u5b83\u6240\u4f5c\u51fa\u7684\u9009\u62e9\u53ea\u662f\u5728\u67d0\u79cd\u610f\u4e49\u4e0a\u7684",(0,d.jsx)(e.strong,{children:"\u5c40\u90e8\u6700\u4f18\u9009\u62e9"}),"\u3002\u5f53\u7136\uff0c\u5e0c\u671b\u8d2a\u5fc3\u7b97\u6cd5\u5f97\u5230\u7684\u6700\u7ec8\u7ed3\u679c\u4e5f\u662f\u6574\u4f53\u6700\u4f18\u7684\u3002\u867d\u7136\u8d2a\u5fc3\u7b97\u6cd5\u4e0d\u80fd\u5bf9\u6240\u6709\u95ee\u9898\u90fd\u5f97\u5230\u6574\u4f53\u6700\u4f18\u89e3\uff0c\u4f46\u5bf9\u8bb8\u591a\u95ee\u9898\u5b83\u80fd\u4ea7\u751f\u6574\u4f53\u6700\u4f18\u89e3\u3002\u5982\u5355\u6e90\u6700\u77ed\u8def\u7ecf\u95ee\u9898\uff0c\u6700\u5c0f\u751f\u6210\u6811\u95ee\u9898\u7b49\u3002\u5728\u4e00\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5373\u4f7f\u8d2a\u5fc3\u7b97\u6cd5\u4e0d\u80fd\u5f97\u5230\u6574\u4f53\u6700\u4f18\u89e3\uff0c\u5176\u6700\u7ec8\u7ed3\u679c\u5374\u662f\u6700\u4f18\u89e3\u7684\u5f88\u597d\u8fd1\u4f3c\u3002"]}),"\n",(0,d.jsx)(e.p,{children:"\u8d2a\u5fc3\u7b97\u6cd5\u7684\u57fa\u672c\u8981\u7d20\uff1a"}),"\n",(0,d.jsxs)(e.ol,{children:["\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsx)(e.p,{children:"\u8d2a\u5fc3\u9009\u62e9\u6027\u8d28\u3002\u6240\u8c13\u8d2a\u5fc3\u9009\u62e9\u6027\u8d28\u662f\u6307\u6240\u6c42\u95ee\u9898\u7684\u6574\u4f53\u6700\u4f18\u89e3\u53ef\u4ee5\u901a\u8fc7\u4e00\u7cfb\u5217\u5c40\u90e8\u6700\u4f18\u7684\u9009\u62e9\uff0c\u5373\u8d2a\u5fc3\u9009\u62e9\u6765\u8fbe\u5230\u3002\u8fd9\u662f\u8d2a\u5fc3\u7b97\u6cd5\u53ef\u884c\u7684\u7b2c\u4e00\u4e2a\u57fa\u672c\u8981\u7d20\uff0c\u4e5f\u662f\u8d2a\u5fc3\u7b97\u6cd5\u4e0e\u52a8\u6001\u89c4\u5212\u7b97\u6cd5\u7684\u4e3b\u8981\u533a\u522b\u3002"}),"\n",(0,d.jsx)(e.p,{children:"\u52a8\u6001\u89c4\u5212\u7b97\u6cd5\u901a\u5e38\u4ee5\u81ea\u5e95\u5411\u4e0a\u7684\u65b9\u5f0f\u89e3\u5404\u5b50\u95ee\u9898\uff08\u540e\u9762\u4f1a\u8bb2\uff09\uff0c\u800c\u8d2a\u5fc3\u7b97\u6cd5\u5219\u901a\u5e38\u4ee5\u81ea\u9876\u5411\u4e0b\u7684\u65b9\u5f0f\u8fdb\u884c\uff0c\u4ee5\u8fed\u4ee3\u7684\u65b9\u5f0f\u4f5c\u51fa\u76f8\u7ee7\u7684\u8d2a\u5fc3\u9009\u62e9\uff0c\u6bcf\u4f5c\u4e00\u6b21\u8d2a\u5fc3\u9009\u62e9\u5c31\u5c06\u6240\u6c42\u95ee\u9898\u7b80\u5316\u4e3a\u89c4\u6a21\u66f4\u5c0f\u7684\u5b50\u95ee\u9898\u3002"}),"\n",(0,d.jsx)(e.p,{children:"\u5bf9\u4e8e\u4e00\u4e2a\u5177\u4f53\u95ee\u9898\uff0c\u8981\u786e\u5b9a\u5b83\u662f\u5426\u5177\u6709\u8d2a\u5fc3\u9009\u62e9\u6027\u8d28\uff0c\u5fc5\u987b\u8bc1\u660e\u6bcf\u4e00\u6b65\u6240\u4f5c\u7684\u8d2a\u5fc3\u9009\u62e9\u6700\u7ec8\u5bfc\u81f4\u95ee\u9898\u7684\u6574\u4f53\u6700\u4f18\u89e3\u3002"}),"\n"]}),"\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsx)(e.p,{children:"\u5f53\u4e00\u4e2a\u95ee\u9898\u7684\u6700\u4f18\u89e3\u5305\u542b\u5176\u5b50\u95ee\u9898\u7684\u6700\u4f18\u89e3\u65f6\uff0c\u79f0\u6b64\u95ee\u9898\u5177\u6709\u6700\u4f18\u5b50\u7ed3\u6784\u6027\u8d28\u3002\u95ee\u9898\u7684\u6700\u4f18\u5b50\u7ed3\u6784\u6027\u8d28\u662f\u8be5\u95ee\u9898\u53ef\u7528\u52a8\u6001\u89c4\u5212\u7b97\u6cd5\u6216\u8d2a\u5fc3\u7b97\u6cd5\u6c42\u89e3\u7684\u5173\u952e\u7279\u5f81\u3002"}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(e.h2,{id:"\u8d2a\u5fc3\u7b97\u6cd5\u7684\u57fa\u672c\u601d\u8def",children:"\u8d2a\u5fc3\u7b97\u6cd5\u7684\u57fa\u672c\u601d\u8def"}),"\n",(0,d.jsx)(e.p,{children:"\u4ece\u95ee\u9898\u7684\u67d0\u4e00\u4e2a\u521d\u59cb\u89e3\u51fa\u53d1\u9010\u6b65\u903c\u8fd1\u7ed9\u5b9a\u7684\u76ee\u6807\uff0c\u4ee5\u5c3d\u53ef\u80fd\u5feb\u7684\u5730\u6c42\u5f97\u66f4\u597d\u7684\u89e3\u3002\u5f53\u8fbe\u5230\u7b97\u6cd5\u4e2d\u7684\u67d0\u4e00\u6b65\u4e0d\u80fd\u518d\u7ee7\u7eed\u524d\u8fdb\u65f6\uff0c\u7b97\u6cd5\u505c\u6b62\u3002"}),"\n",(0,d.jsx)(e.p,{children:"\u8be5\u7b97\u6cd5\u5b58\u5728\u95ee\u9898\uff1a"}),"\n",(0,d.jsxs)(e.ol,{children:["\n",(0,d.jsx)(e.li,{children:"\u4e0d\u80fd\u4fdd\u8bc1\u6c42\u5f97\u7684\u6700\u540e\u89e3\u662f\u6700\u4f73\u7684\uff1b"}),"\n",(0,d.jsx)(e.li,{children:"\u4e0d\u80fd\u7528\u6765\u6c42\u6700\u5927\u6216\u6700\u5c0f\u89e3\u95ee\u9898;"}),"\n",(0,d.jsx)(e.li,{children:"\u53ea\u80fd\u6c42\u6ee1\u8db3\u67d0\u4e9b\u7ea6\u675f\u6761\u4ef6\u7684\u53ef\u884c\u89e3\u7684\u8303\u56f4\u3002"}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"\u5b9e\u73b0\u8be5\u7b97\u6cd5\u7684\u8fc7\u7a0b\uff1a"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-C",metastring:"\u4f2a\u4ee3\u7801",children:"\u4ece\u95ee\u9898\u7684\u67d0\u4e00\u521d\u59cb\u89e3\u51fa\u53d1\uff1b\n\nwhile \u80fd\u671d\u7ed9\u5b9a\u603b\u76ee\u6807\u524d\u8fdb\u4e00\u6b65 do\n    \u6c42\u51fa\u53ef\u884c\u89e3\u7684\u4e00\u4e2a\u89e3\u5143\u7d20\uff1b\n\n\u7531\u6240\u6709\u89e3\u5143\u7d20\u7ec4\u5408\u6210\u95ee\u9898\u7684\u4e00\u4e2a\u53ef\u884c\u89e3\u3002\n"})})]})}function x(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,d.jsx)(e,{...n,children:(0,d.jsx)(l,{...n})}):l(n)}}}]);