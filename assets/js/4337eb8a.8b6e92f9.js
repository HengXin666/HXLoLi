"use strict";(self.webpackChunkhx_loli=self.webpackChunkhx_loli||[]).push([[71246],{28453:(n,e,i)=>{i.d(e,{R:()=>r,x:()=>a});var t=i(96540);const L={},c=t.createContext(L);function r(n){const e=t.useContext(c);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(L):n.components||L:r(n.components),t.createElement(c.Provider,{value:e},n.children)}},99402:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>s,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u7ebf\u6027\u8868/\u7ebf\u6027\u8868\u4e36\u8bfe\u540e\u4e60\u9898code/index","title":"\u7ebf\u6027\u8868-\u8bfe\u540e\u4e60\u9898","description":"\u7ea6\u745f\u592b\u95ee\u9898","source":"@site/docs/001-\u8ba1\u4f6c\u5e38\u8b58/001-\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/003-\u3010\u6570\u636e\u7ed3\u6784\u3011\u7ebf\u6027\u8868/008-\u7ebf\u6027\u8868\u4e36\u8bfe\u540e\u4e60\u9898code/index.md","sourceDirName":"001-\u8ba1\u4f6c\u5e38\u8b58/001-\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/003-\u3010\u6570\u636e\u7ed3\u6784\u3011\u7ebf\u6027\u8868/008-\u7ebf\u6027\u8868\u4e36\u8bfe\u540e\u4e60\u9898code","slug":"/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u7ebf\u6027\u8868/\u7ebf\u6027\u8868\u4e36\u8bfe\u540e\u4e60\u9898code/","permalink":"/HXLoLi/docs/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u7ebf\u6027\u8868/\u7ebf\u6027\u8868\u4e36\u8bfe\u540e\u4e60\u9898code/","draft":false,"unlisted":false,"editUrl":"https://github.com/HengXin666/HXLoLi/edit/main/docs/001-\u8ba1\u4f6c\u5e38\u8b58/001-\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/003-\u3010\u6570\u636e\u7ed3\u6784\u3011\u7ebf\u6027\u8868/008-\u7ebf\u6027\u8868\u4e36\u8bfe\u540e\u4e60\u9898code/index.md","tags":[],"version":"current","lastUpdatedBy":"Heng_Xin_666","lastUpdatedAt":1745851959000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"\u94fe\u5f0f\u5b58\u50a8\u7ed3\u6784\u4e36\u53cc\u5411\u5faa\u73af\u94fe\u8868","permalink":"/HXLoLi/docs/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u7ebf\u6027\u8868/\u94fe\u5f0f\u5b58\u50a8\u7ed3\u6784\u4e36\u53cc\u5411\u5faa\u73af\u94fe\u8868/"},"next":{"title":"\u6808","permalink":"/HXLoLi/docs/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u7ebf\u6027\u8868/\u6808/"}}');var L=i(74848),c=i(28453);const r={},a="\u7ebf\u6027\u8868-\u8bfe\u540e\u4e60\u9898",s={},l=[{value:"\u7ea6\u745f\u592b\u95ee\u9898",id:"\u7ea6\u745f\u592b\u95ee\u9898",level:2},{value:"\u9b54\u672f\u5e08\u53d1\u724c",id:"\u9b54\u672f\u5e08\u53d1\u724c",level:2},{value:"\u62c9\u4e01\u65b9\u9635",id:"\u62c9\u4e01\u65b9\u9635",level:2},{value:"\u7ef4\u5409\u5c3c\u4e9a\u52a0\u5bc6",id:"\u7ef4\u5409\u5c3c\u4e9a\u52a0\u5bc6",level:2},{value:"\u8bfe\u5802\u7ec3\u4e60",id:"\u8bfe\u5802\u7ec3\u4e60",level:3},{value:"\u8bfe\u540e\u7ec3\u4e60",id:"\u8bfe\u540e\u7ec3\u4e60",level:3}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",pre:"pre",...(0,c.R)(),...n.components};return(0,L.jsxs)(L.Fragment,{children:[(0,L.jsx)(e.header,{children:(0,L.jsx)(e.h1,{id:"\u7ebf\u6027\u8868-\u8bfe\u540e\u4e60\u9898",children:"\u7ebf\u6027\u8868-\u8bfe\u540e\u4e60\u9898"})}),"\n",(0,L.jsx)(e.h2,{id:"\u7ea6\u745f\u592b\u95ee\u9898",children:"\u7ea6\u745f\u592b\u95ee\u9898"}),"\n",(0,L.jsx)(e.pre,{children:(0,L.jsx)(e.code,{className:"language-C",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define MAXPOOL 1024\n#define OK 1    // \u7a0b\u5e8f\u6b63\u5e38\u8fd0\u884c\n#define ERROR 0 // \u7a0b\u5e8f\u8fd0\u884c\u62a5\u9519\n#define TRUE 1  //\n#define FALSE 0 //\n\n// --- \u7ebf\u6027\u8868 \u5c01\u88c5 --- <\u94fe\u8868>\ntypedef int ElemType;\n\ntypedef struct Nobe{\n    ElemType data;// \u5bc6\u7801\n    int number;   // \u7f16\u53f7\n    struct Nobe* next;\n} Nobe;\ntypedef Nobe* LinkList;\n\nint getElem(LinkList L, int i, int *e);         // \u5c06\u7ebf\u6027\u8868L\u7b2ci\u4e2a\u5143\u7d20\u8fd4\u56de\u7ed9e\nint listEmpty(LinkList L);                      // \u5224\u65ad\u662f\u5426\u4e3a\u7a7a\u8868 1\u662f0\u5426\nvoid clearList(LinkList *L);                    // \u5c06\u7ebf\u6027\u8868\u6e05\u7a7a\nint locateElem(LinkList L, int e);              // \u67e5\u627e\u7ebf\u6027\u8868L\u4e2d\u662f\u5426\u6709\u503c\u4e3ae\u7684\u5143\u7d20, \u6709\u5219\u8fd4\u56de\u5176\u5728\u8868\u4e2d\u7684\u5e8f\u53f7, \u54260\nint listInsert(LinkList *L, int i, int e);      // \u5728\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u63d2\u5165\u65b0\u5143\u7d20e\nint listDelete(LinkList *L, int i, int *e);     // \u5220\u9664\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u7684\u5143\u7d20, \u5e76\u8fd4\u56de\u5176\u503c\u7ed9e\n\nint listHAdd(LinkList *L, int e);               // \u5934\u63d2\u5143\u7d20\nint listAdd(LinkList *L, int e);                // \u5728\u7ebf\u6027\u8868\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20\nint listPrint(LinkList L);                      // \u6253\u5370\u5355\u94fe\u8868\nint listLength(LinkList L);                     // \u8fd4\u56de\u7ebf\u6027\u8868\u7684\u957f\u5ea6\n\nvoid listJosephusProblem(LinkList *L, int interval, int len, int remaining);    // \u7ea6\u745f\u592b\u95ee\u9898\nvoid listJosephusProblemAssignment(LinkList *L, int len, int remaining);        // \u7ea6\u745f\u592b\u95ee\u9898\u7684\u8bfe\u540e\u4f5c\u4e1a\nint listJPAHAdd(LinkList *L, int e, int number);// \u7ea6\u745f\u592b\u95ee\u9898\u8bfe\u540e\u4f5c\u4e1a\u4e13\u7528\u51fd\u6570(\u5934\u63d2\u6cd5)\n\nint listJPAHAdd(LinkList *L, int e, int number)\n{\n    // \u5934\u63d2\u6cd5\n    LinkList p;\n    p = (LinkList)malloc(sizeof(Nobe));\n    if (p == NULL)\n    {\n        printf("\u5185\u5b58\u7533\u8bf7\u5931\u8d25!\\n");\n        return ERROR;\n    }\n\n    p->data = e;\n    p->number = number;\n    if (*L == NULL)\n    {\n        *L = p;\n        p->next = p;\n    }\n    else\n    {\n        LinkList cache = (*L)->next;\n        while (cache->next != *L)\n        {\n            cache = cache->next;\n        }\n        \n        p->next = *L;\n        *L = p;\n        cache->next = p; \n    }\n    return OK;\n}\n\nint listHAdd(LinkList *L, int e)\n{\n    // \u5934\u63d2\u6cd5\n    LinkList p;\n    p = (LinkList)malloc(sizeof(Nobe));\n    if (p == NULL)\n    {\n        printf("\u5185\u5b58\u7533\u8bf7\u5931\u8d25!\\n");\n        return ERROR;\n    }\n\n    p->data = e;\n    if (*L == NULL)\n    {\n        *L = p;\n        p->next = p;\n    }\n    else\n    {\n        LinkList cache = (*L)->next;\n        while (cache->next != *L)\n        {\n            cache = cache->next;\n        }\n        \n        p->next = *L;\n        *L = p;\n        cache->next = p; \n    }\n    return OK;\n}\n\nint listPrint(LinkList L)\n{\n    // \u6253\u5370\u5355\u94fe\u8868\n    LinkList cache = L;\n    if (L != NULL)\n    {\n        printf("%d ", cache->data);\n        while (cache->next != L)\n        {\n            cache = cache->next;\n            printf("%d ", cache->data);\n        }\n    }\n    putchar(\'\\n\');\n    return OK;\n}\n\nint listJPAPrint(LinkList L)\n{\n    // \u6253\u5370\u5355\u94fe\u8868 (\u8bfe\u540e\u4f5c\u4e1a\u5b9a\u5236)\n    LinkList cache = L;\n    if (L != NULL)\n    {\n        printf("[%d] {%d}\\n", cache->number, cache->data);\n        while (cache->next != L)\n        {\n            cache = cache->next;\n            printf("[%d] {%d}\\n", cache->number, cache->data);\n        }\n    }\n    putchar(\'\\n\');\n    return OK;\n}\n\nint listInsert(LinkList *L, int i, int e)\n{\n    // \u5728\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u63d2\u5165\u65b0\u5143\u7d20e\n    if (i < 0)\n    {\n        return ERROR;\n    }\n\n    LinkList p;\n    p = (LinkList)malloc(sizeof(Nobe));\n    if (p == NULL)\n    {\n        printf("\u5185\u5b58\u7533\u8bf7\u5931\u8d25!\\n");\n        return ERROR;\n    }\n\n    p->data = e;\n    if (i == 1)\n    {\n        LinkList cache = (*L)->next;\n        while (cache->next != *L)\n        {\n            cache = cache->next;\n        }\n        \n        p->next = *L;\n        *L = p;\n        cache->next = p; \n    }\n    else\n    {\n        LinkList cache = *L;\n        for (int j = 2; j < i && cache->next != *L; j++)\n        {\n            cache = cache->next;\n        }// \u524d\u4e00\u4e2a\n\n        p->next = cache->next;\n        cache->next = p;\n    }\n\n    return OK;\n}\n\nint listDelete(LinkList *L, int i, int *e)\n{\n    // \u5220\u9664\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u7684\u5143\u7d20, \u5e76\u8fd4\u56de\u5176\u503c\u7ed9e\n    if (i < 1)\n    {\n        return ERROR;\n    }\n\n    LinkList cache = NULL;\n    LinkList free_nobe = NULL;\n    if (i == 1)\n    {\n        free_nobe = *L;\n        cache = free_nobe->next;\n        *e = free_nobe->data;\n        if (cache == *L)\n        {\n            *L = NULL;\n        }\n        else\n        {\n            while (cache->next != free_nobe)\n            {\n                cache = cache->next;\n            }\n            cache->next = free_nobe->next;\n            *L = free_nobe->next;\n        }\n        free(free_nobe);\n    }\n    else\n    {\n        cache = *L;\n        int j = 2;\n        for (; j < i && cache->next != *L; j++)\n        {\n            cache = cache->next;\n        }// \u524d\u4e00\u4e2a\n\n        if (cache->next != *L)\n        {\n            *e = cache->next->data;\n            free_nobe = cache->next;\n            cache->next = cache->next->next;\n            free(free_nobe);\n        }\n       else\n       {\n            return ERROR;\n       }\n    }\n    return OK;\n}\n\nvoid listJosephusProblem(LinkList *L, int interval, int len, int remaining)\n{\n    /*\n    \u529f\u80fd: \u7ea6\u745f\u592b\u95ee\u9898\n    \u53c2\u6570:   \u5faa\u73af\u94fe\u8868\u7684\u4e8c\u7ea7\u6307\u9488 - L\n            \u8de8\u5ea6 - interval (\u95f4\u9694\u591a\u5c11\u6740\u4e00\u4e2a)\n            \u957f\u5ea6 - len\n            \u4f59\u4e0b - remaining\n    */\n    int i = len, j;\n    LinkList p_mae = NULL;\n    LinkList p_free = NULL;\n    do\n    {\n        listHAdd(L, i);\n    }while (i --\x3e 1);// \u751f\u6210\u94fe\u8868\n    \n    LinkList p = *L;\n    i = len;\n    interval--;\n    do// \u6dd8\u6c70\u8d5b\n    {\n        for (j = interval; j > 0; --j)\n        {\n            p_mae = p;\n            p = p->next;\n        }\n\n        p_free = p;\n        p = p->next;\n        p_mae->next = p;\n        if (p_free == *L)\n        {\n            *L = p;\n        }\n        printf("\u5220\u9664\u4e86 %d\\n", p_free->data);\n        free(p_free);\n    }while (--i > remaining);\n}\n\nvoid listJosephusProblemAssignment(LinkList *L, int len, int remaining)\n{\n    /*\n    \u8be6\u60c5: \u63d0\u9ad8\u6311\u6218\u96be\u5ea6:\u7f16\u53f7\u4e3a1\uff5eN\u7684N\u4e2a\u4eba\u6309\u987a\u65f6\u9488\u65b9\u5411\u56f4\u5750\u4e00\u5708\uff0c\n    \u6bcf\u4eba\u6301\u6709\u4e00\u4e2a\u5bc6\u7801\uff08\u6b63\u6574\u6570\uff0c\u53ef\u4ee5\u81ea\u7531\u8f93\u5165\uff09\uff0c\n    \u5f00\u59cb\u4eba\u9009\u4e00\u4e2a\u6b63\u6574\u6570\u4f5c\u4e3a\u62a5\u6570\u4e0a\u9650\u503cM\uff0c\u4ece\u7b2c\u4e00\u4e2a\u4eba\u6309\u987a\u65f6\u9488\u65b9\u5411\u81ea1\u5f00\u59cb\u987a\u5e8f\u62a5\u6570\uff0c\u62a5\u9053M\u65f6\u505c\u6b62\u62a5\u6570\u3002\n    \u62a5M\u7684\u4eba\u51fa\u5217\uff0c\u5c06\u4ed6\u7684\u5bc6\u7801\u4f5c\u4e3a\u65b0\u7684M\u503c\uff0c\u4ece\u4ed6\u987a\u65f6\u9488\u65b9\u5411\u4e0a\u7684\u4e0b\u4e00\u4e2a\u4eba\u5f00\u59cb\u4ece1\u62a5\u6570,\u5982\u6b64\u4e0b\u53bb\uff0c\u76f4\u81f3\u6240\u6709\u4eba\u5168\u90e8\u51fa\u5217\u4e3a\u6b62\u3002\n\n    \u529f\u80fd: \u7ea6\u745f\u592b\u95ee\u9898\u7684\u8bfe\u540e\u4f5c\u4e1a\n    \u53c2\u6570:   \u5faa\u73af\u94fe\u8868\u7684\u4e8c\u7ea7\u6307\u9488 - L\n            \u957f\u5ea6 - len\n            \u4f59\u4e0b\u4eba\u6570 - remaining\n    */\n    int i = len, j;\n    LinkList p_mae = NULL;\n    LinkList p_free = NULL;\n    time_t t;\n    srand((unsigned)time(&t));// \u4f7f\u7528\u5f53\u524d\u65f6\u95f4\u503c\u521d\u59cb\u5316\u4f2a\u968f\u673a\u6570\u79cd\u5b50\u5e8f\u5217\n    do\n    {\n        listJPAHAdd(L, rand() % len * 2 + 1, i);// \u6bcf\u4eba\u6301\u6709\u4e00\u4e2a\u5bc6\u7801\uff08\u6b63\u6574\u6570\uff0c\u53ef\u4ee5\u81ea\u7531\u8f93\u5165\uff09\n    }while (i --\x3e 1);// \u751f\u6210\u94fe\u8868\n\n     LinkList p = *L;\n    i = len;\n    int interval = p->data;\n    printf("\u7b2c\u4e00\u4e2a\u4eba\u7684\u5bc6\u7801\u662f{%d} | \u5f53\u524dlen = %d\\n", interval, i);\n    do// \u6dd8\u6c70\u8d5b\n    {\n        interval = interval % i;\n        for (j = interval; j > 0; --j)\n        {\n            p_mae = p;\n            p = p->next;\n        }\n\n        p_free = p;\n        p = p->next;\n        p_mae->next = p;\n        if (p_free == *L)\n        {\n            *L = p;\n        }\n        printf("\u4f4d\u7f6e += %d \u306e %d, \u624b\u4e0a\u7684\u5bc6\u7801\u662f %d | \u5f53\u524dlen = %d\\n", interval, p_free->number ,p_free->data, --i);\n        interval = p_free->data;\n        free(p_free);\n    }while (i > remaining);\n}\n\nint main(void)\n{\n    // \u5faa\u73af(\u5355)\u94fe\u8868 (\u65e0\u5934\u7ed3\u70b9\u7248) + \u7ea6\u745f\u592b\u95ee\u9898 + \u7ea6\u745f\u592b\u95ee\u9898\u7684\u8bfe\u540e\u4f5c\u4e1a\n    LinkList head = NULL;\n\n    // listJosephusProblem(&head, 3, 41, 2);\n    listJosephusProblemAssignment(&head, 41, 2);\n    listJPAPrint(head);\n\n    return 0;\n}\n'})}),"\n",(0,L.jsx)(e.h2,{id:"\u9b54\u672f\u5e08\u53d1\u724c",children:"\u9b54\u672f\u5e08\u53d1\u724c"}),"\n",(0,L.jsx)(e.pre,{children:(0,L.jsx)(e.code,{className:"language-C",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define MAXPOOL 1024\n#define OK 1    // \u7a0b\u5e8f\u6b63\u5e38\u8fd0\u884c\n#define ERROR 0 // \u7a0b\u5e8f\u8fd0\u884c\u62a5\u9519\n#define TRUE 1  //\n#define FALSE 0 //\n\n// --- \u7ebf\u6027\u8868 \u5c01\u88c5 --- <\u94fe\u8868>\ntypedef int ElemType;\n\ntypedef struct Nobe{\n    ElemType data;\n    struct Nobe* next;\n} Nobe;\ntypedef Nobe* LinkList;\n\nint getElem(LinkList L, int i, int *e);         // \u5c06\u7ebf\u6027\u8868L\u7b2ci\u4e2a\u5143\u7d20\u8fd4\u56de\u7ed9e\nint listEmpty(LinkList L);                      // \u5224\u65ad\u662f\u5426\u4e3a\u7a7a\u8868 1\u662f0\u5426\nvoid clearList(LinkList *L);                    // \u5c06\u7ebf\u6027\u8868\u6e05\u7a7a\nint locateElem(LinkList L, int e);              // \u67e5\u627e\u7ebf\u6027\u8868L\u4e2d\u662f\u5426\u6709\u503c\u4e3ae\u7684\u5143\u7d20, \u6709\u5219\u8fd4\u56de\u5176\u5728\u8868\u4e2d\u7684\u5e8f\u53f7, \u54260\nint listInsert(LinkList *L, int i, int e);      // \u5728\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u63d2\u5165\u65b0\u5143\u7d20e\nint listDelete(LinkList *L, int i, int *e);     // \u5220\u9664\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u7684\u5143\u7d20, \u5e76\u8fd4\u56de\u5176\u503c\u7ed9e\n\nint listHAdd(LinkList *L, int e);               // \u5934\u63d2\u5143\u7d20\nint listAdd(LinkList *L, int e);                // \u5728\u7ebf\u6027\u8868\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20\nint listPrint(LinkList L);                      // \u6253\u5370\u5355\u94fe\u8868\nint listLength(LinkList L);                     // \u8fd4\u56de\u7ebf\u6027\u8868\u7684\u957f\u5ea6\n\nvoid magicDealingProblem(LinkList *L);          // \u9b54\u672f\u5e08\u53d1\u724c\u95ee\u9898\n\nint listHAdd(LinkList *L, int e)\n{\n    // \u5934\u63d2\u6cd5\n    LinkList p;\n    p = (LinkList)malloc(sizeof(Nobe));\n    if (p == NULL)\n    {\n        printf("\u5185\u5b58\u7533\u8bf7\u5931\u8d25!\\n");\n        return ERROR;\n    }\n\n    p->data = e;\n    if (*L == NULL)\n    {\n        *L = p;\n        p->next = p;\n    }\n    else\n    {\n        LinkList cache = (*L)->next;\n        while (cache->next != *L)\n        {\n            cache = cache->next;\n        }\n        \n        p->next = *L;\n        *L = p;\n        cache->next = p; \n    }\n    return OK;\n}\n\nint listPrint(LinkList L)\n{\n    // \u6253\u5370\u5355\u94fe\u8868\n    LinkList cache = L;\n    if (L != NULL)\n    {\n        printf("%d ", cache->data);\n        while (cache->next != L)\n        {\n            cache = cache->next;\n            printf("%d ", cache->data);\n        }\n    }\n    putchar(\'\\n\');\n    return OK;\n}\n\n\nint listInsert(LinkList *L, int i, int e)\n{\n    // \u5728\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u63d2\u5165\u65b0\u5143\u7d20e\n    if (i < 0)\n    {\n        return ERROR;\n    }\n\n    LinkList p;\n    p = (LinkList)malloc(sizeof(Nobe));\n    if (p == NULL)\n    {\n        printf("\u5185\u5b58\u7533\u8bf7\u5931\u8d25!\\n");\n        return ERROR;\n    }\n\n    p->data = e;\n    if (i == 1)\n    {\n        LinkList cache = (*L)->next;\n        while (cache->next != *L)\n        {\n            cache = cache->next;\n        }\n        \n        p->next = *L;\n        *L = p;\n        cache->next = p; \n    }\n    else\n    {\n        LinkList cache = *L;\n        for (int j = 2; j < i && cache->next != *L; j++)\n        {\n            cache = cache->next;\n        }// \u524d\u4e00\u4e2a\n\n        p->next = cache->next;\n        cache->next = p;\n    }\n\n    return OK;\n}\n\nint listDelete(LinkList *L, int i, int *e)\n{\n    // \u5220\u9664\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u7684\u5143\u7d20, \u5e76\u8fd4\u56de\u5176\u503c\u7ed9e\n    if (i < 1)\n    {\n        return ERROR;\n    }\n\n    LinkList cache = NULL;\n    LinkList free_nobe = NULL;\n    if (i == 1)\n    {\n        free_nobe = *L;\n        cache = free_nobe->next;\n        *e = free_nobe->data;\n        if (cache == *L)\n        {\n            *L = NULL;\n        }\n        else\n        {\n            while (cache->next != free_nobe)\n            {\n                cache = cache->next;\n            }\n            cache->next = free_nobe->next;\n            *L = free_nobe->next;\n        }\n        free(free_nobe);\n    }\n    else\n    {\n        cache = *L;\n        int j = 2;\n        for (; j < i && cache->next != *L; j++)\n        {\n            cache = cache->next;\n        }// \u524d\u4e00\u4e2a\n\n        if (cache->next != *L)\n        {\n            *e = cache->next->data;\n            free_nobe = cache->next;\n            cache->next = cache->next->next;\n            free(free_nobe);\n        }\n       else\n       {\n            return ERROR;\n       }\n    }\n    return OK;\n}\n\nvoid magicDealingProblem(LinkList *L)\n{\n    // \u9b54\u672f\u5e08\u53d1\u724c\u95ee\u9898\n    int i = 13, j;\n    do\n    {\n        listHAdd(L, 0);\n    }while (i --\x3e 1);// \u751f\u6210\u94fe\u8868\n    LinkList p = *L;\n\n    i = 1;\n    A:\n    j = i;\n    while (j > 0)\n    {\n        if (j == 1 && p->data == 0)\n        {\n            p->data = i++;\n            --j;\n        }\n        else if (p->data != 0)\n        {\n\n        }\n        else\n        {\n            --j;\n        }\n        p = p->next;\n    }\n\n    if (i < 14)\n    {\n        goto A;\n    }\n}\n\nint main(void)\n{\n    // \u5faa\u73af(\u5355)\u94fe\u8868 (\u65e0\u5934\u7ed3\u70b9\u7248) + \u9b54\u672f\u5e08\u53d1\u724c\u95ee\u9898\n    LinkList head = NULL;\n\n    magicDealingProblem(&head);\n    listPrint(head);\n\n    getchar();\n    return 0;\n}\n'})}),"\n",(0,L.jsx)(e.h2,{id:"\u62c9\u4e01\u65b9\u9635",children:"\u62c9\u4e01\u65b9\u9635"}),"\n",(0,L.jsx)(e.pre,{children:(0,L.jsx)(e.code,{className:"language-C",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define MAXPOOL 1024\n#define OK 1    // \u7a0b\u5e8f\u6b63\u5e38\u8fd0\u884c\n#define ERROR 0 // \u7a0b\u5e8f\u8fd0\u884c\u62a5\u9519\n#define TRUE 1  //\n#define FALSE 0 //\n\n// --- \u7ebf\u6027\u8868 \u5c01\u88c5 --- <\u94fe\u8868>\ntypedef int ElemType;\n\ntypedef struct Nobe{\n    ElemType data;\n    struct Nobe* next;\n} Nobe;\ntypedef Nobe* LinkList;\n\nint getElem(LinkList L, int i, int *e);         // \u5c06\u7ebf\u6027\u8868L\u7b2ci\u4e2a\u5143\u7d20\u8fd4\u56de\u7ed9e\nint listEmpty(LinkList L);                      // \u5224\u65ad\u662f\u5426\u4e3a\u7a7a\u8868 1\u662f0\u5426\nvoid clearList(LinkList *L);                    // \u5c06\u7ebf\u6027\u8868\u6e05\u7a7a\nint locateElem(LinkList L, int e);              // \u67e5\u627e\u7ebf\u6027\u8868L\u4e2d\u662f\u5426\u6709\u503c\u4e3ae\u7684\u5143\u7d20, \u6709\u5219\u8fd4\u56de\u5176\u5728\u8868\u4e2d\u7684\u5e8f\u53f7, \u54260\nint listInsert(LinkList *L, int i, int e);      // \u5728\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u63d2\u5165\u65b0\u5143\u7d20e\nint listDelete(LinkList *L, int i, int *e);     // \u5220\u9664\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u7684\u5143\u7d20, \u5e76\u8fd4\u56de\u5176\u503c\u7ed9e\n\nint listHAdd(LinkList *L, int e);               // \u5934\u63d2\u5143\u7d20\nint listAdd(LinkList *L, int e);                // \u5728\u7ebf\u6027\u8868\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20\nint listPrint(LinkList L);                      // \u6253\u5370\u5355\u94fe\u8868\nint listLength(LinkList L);                     // \u8fd4\u56de\u7ebf\u6027\u8868\u7684\u957f\u5ea6\n\nint listFree(LinkList *L);                      // \u91ca\u653e\u7ebf\u6027\u8868\nvoid latinSquare(LinkList *L, int n);           // \u62c9\u4e01\u65b9\u9635\u95ee\u9898\n\nint listHAdd(LinkList *L, int e)\n{\n    // \u5934\u63d2\u6cd5\n    LinkList p;\n    p = (LinkList)malloc(sizeof(Nobe));\n    if (p == NULL)\n    {\n        printf("\u5185\u5b58\u7533\u8bf7\u5931\u8d25!\\n");\n        return ERROR;\n    }\n\n    p->data = e;\n    if (*L == NULL)\n    {\n        *L = p;\n        p->next = p;\n    }\n    else\n    {\n        LinkList cache = (*L)->next;\n        while (cache->next != *L)\n        {\n            cache = cache->next;\n        }\n        \n        p->next = *L;\n        *L = p;\n        cache->next = p; \n    }\n    return OK;\n}\n\nint listPrint(LinkList L)\n{\n    // \u6253\u5370\u5355\u94fe\u8868\n    LinkList cache = L;\n    if (L != NULL)\n    {\n        printf("%d ", cache->data);\n        while (cache->next != L)\n        {\n            cache = cache->next;\n            printf("%d ", cache->data);\n        }\n    }\n    putchar(\'\\n\');\n    return OK;\n}\n\n\nint listInsert(LinkList *L, int i, int e)\n{\n    // \u5728\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u63d2\u5165\u65b0\u5143\u7d20e\n    if (i < 0)\n    {\n        return ERROR;\n    }\n\n    LinkList p;\n    p = (LinkList)malloc(sizeof(Nobe));\n    if (p == NULL)\n    {\n        printf("\u5185\u5b58\u7533\u8bf7\u5931\u8d25!\\n");\n        return ERROR;\n    }\n\n    p->data = e;\n    if (i == 1)\n    {\n        LinkList cache = (*L)->next;\n        while (cache->next != *L)\n        {\n            cache = cache->next;\n        }\n        \n        p->next = *L;\n        *L = p;\n        cache->next = p; \n    }\n    else\n    {\n        LinkList cache = *L;\n        for (int j = 2; j < i && cache->next != *L; j++)\n        {\n            cache = cache->next;\n        }// \u524d\u4e00\u4e2a\n\n        p->next = cache->next;\n        cache->next = p;\n    }\n\n    return OK;\n}\n\nint listDelete(LinkList *L, int i, int *e)\n{\n    // \u5220\u9664\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u7684\u5143\u7d20, \u5e76\u8fd4\u56de\u5176\u503c\u7ed9e\n    if (i < 1)\n    {\n        return ERROR;\n    }\n\n    LinkList cache = NULL;\n    LinkList free_nobe = NULL;\n    if (i == 1)\n    {\n        free_nobe = *L;\n        cache = free_nobe->next;\n        *e = free_nobe->data;\n        if (cache == *L)\n        {\n            *L = NULL;\n        }\n        else\n        {\n            while (cache->next != free_nobe)\n            {\n                cache = cache->next;\n            }\n            cache->next = free_nobe->next;\n            *L = free_nobe->next;\n        }\n        free(free_nobe);\n    }\n    else\n    {\n        cache = *L;\n        int j = 2;\n        for (; j < i && cache->next != *L; j++)\n        {\n            cache = cache->next;\n        }// \u524d\u4e00\u4e2a\n\n        if (cache->next != *L)\n        {\n            *e = cache->next->data;\n            free_nobe = cache->next;\n            cache->next = cache->next->next;\n            free(free_nobe);\n        }\n       else\n       {\n            return ERROR;\n       }\n    }\n    return OK;\n}\n\nvoid latinSquare(LinkList *L, int n)\n{\n    int i, j, k;\n    for (i = 1; i <= n; i++)\n    {\n        listHAdd(L, i);\n    }\n    LinkList p = *L;\n    for (i = 1; i <= n; i++)\n    {\n        for (k = 0; k < i; k++)\n        {\n            p = p->next;\n        }\n\n        for (j = 0; j < n; j++)\n        {\n            printf("%d ", p->data);\n            p = p->next;\n        }\n        p = *L;\n        putchar(\'\\n\');\n    }\n}\n\nint listFree(LinkList *L)\n{\n    // \u91ca\u653e\u7ebf\u6027\u8868\n    if (*L == NULL)\n    {\n        return ERROR;\n    }\n\n    LinkList p = *L;\n    LinkList p_free = NULL;\n\n    do\n    {\n        p_free = p;\n        p = p->next;\n        free(p_free);\n    }while (p != *L);\n\n    *L = NULL;\n    return OK;\n}\n\nint main(void)\n{\n    // \u5faa\u73af(\u5355)\u94fe\u8868 (\u65e0\u5934\u7ed3\u70b9\u7248) + \u62c9\u4e01\u65b9\u9635\u95ee\u9898 + \u91ca\u653e\u7ebf\u6027\u8868\n    LinkList head = NULL;\n\n    int n = 0;\n    printf("\u8bf7\u8f93\u5165\u62c9\u4e01\u65b9\u9635\u7684\u8fb9\u957f:");\n    scanf("%d", &n);\n    getchar();\n    latinSquare(&head, n);\n    listFree(&head);\n\n    return 0;\n}\n'})}),"\n",(0,L.jsx)(e.h2,{id:"\u7ef4\u5409\u5c3c\u4e9a\u52a0\u5bc6",children:"\u7ef4\u5409\u5c3c\u4e9a\u52a0\u5bc6"}),"\n",(0,L.jsx)(e.h3,{id:"\u8bfe\u5802\u7ec3\u4e60",children:"\u8bfe\u5802\u7ec3\u4e60"}),"\n",(0,L.jsx)(e.pre,{children:(0,L.jsx)(e.code,{className:"language-C",children:"#include <stdio.h>\n#include <stdlib.h>\n\n#define OK 1    // \u7a0b\u5e8f\u6b63\u5e38\u8fd0\u884c\n#define ERROR 0 // \u7a0b\u5e8f\u8fd0\u884c\u62a5\u9519\n#define TRUE 1  //\n#define FALSE 0 //\n\ntypedef char ElemType;\ntypedef struct DualNobe\n{\n    ElemType data;\n    struct DualNobe *prior; // \u524d\u9a71\u7ed3\u70b9\n    struct DualNobe *next;  // \u540e\u7ee7\u7ed3\u70b9\n} DualNobe, *DuLinkList;\n\nint initList(DuLinkList *L);                      // \u521d\u59cb\u5316\u64cd\u4f5c, \u5efa\u7acb\u4e00\u4e2a\u7a7a\u7684\u7ebf\u6027\u8868 \u548c \u5934\u8282\u70b9\nint listInsert(DuLinkList *L, int i, int e);      // \u5728\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u63d2\u5165\u65b0\u5143\u7d20e\nint listDelete(DuLinkList *L, int i, int *e);     // \u5220\u9664\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u7684\u5143\u7d20, \u5e76\u8fd4\u56de\u5176\u503c\u7ed9e\n\nint listFree(DuLinkList *L);                      // \u91ca\u653e\u7ebf\u6027\u8868\nint listAdd(DuLinkList *L, int e);                // \u5728\u7ebf\u6027\u8868\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20\nint listPrintE(DuLinkList L, int e);              // \u6309\u7167\u504f\u79fb\u91cfe\u6253\u5370\u5355\u94fe\u8868\n\nint initList(DuLinkList *L)\n{\n    // \u521d\u59cb\u5316\u7a7a\u7ed3\u6784\u4f53\u6307\u9488\u4e3a\u53ea\u6709\u5934\u8282\u70b9\u7684\u53cc\u5411\u5faa\u73af\u94fe\u8868\n    if (!*L)\n    {\n        DuLinkList p;\n        p = (DuLinkList)malloc(sizeof(DualNobe));\n        if (!p)\n        {\n            return ERROR;\n        }\n        *L = p;\n        p->next = p;\n        p->prior = p;\n        return OK;\n    }\n    else\n    {\n        return ERROR;\n    }\n}\n\nint listAdd(DuLinkList *L, int e)\n{\n    // \u5c3e\u63d2\u6cd5 \u63d2\u5165\n    if (!*L)\n    {\n        return ERROR;\n    }\n\n    DuLinkList p, cecha = (*L)->prior;\n    p = (DuLinkList)malloc(sizeof(DualNobe));\n    if (!p)\n    {\n        return ERROR;\n    }\n    p->data = e;\n\n    cecha->next = p;\n    p->next = *L;\n    (*L)->prior = p;\n    p->prior = cecha;\n}\n\nint listPrintE(DuLinkList L, int e)\n{\n    // \u6253\u5370\u5355\u94fe\u8868\n    e = e % 26;\n\n    DuLinkList p = L;\n\n    if (e >= 0)\n    {\n        while (e--)\n        {\n            p = p->prior;\n        }   \n    }\n    else\n    {\n        --e;\n        while (e++)\n        {\n            p = p->next;\n        } \n    }\n\n    L = p;\n\n    do\n    {\n        if (p->data == '\\r')\n        {\n            p = p->next;\n            continue;\n        }\n        printf(\"%c \", p->data);\n        p = p->next;\n    }while (p != L);\n    putchar('\\n');\n    return OK;\n}\n\nint listInsert(DuLinkList *L, int i, int e)\n{\n    // \u5728\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u63d2\u5165\u65b0\u5143\u7d20e, \u5982\u679ci\u5927\u4e8e\u94fe\u8868\u957f\u5ea6,\u5219\u53ea\u5728\u6700\u540e\u7684\u4f4d\u7f6e\u63d2\u5165\n    if (i < 1)\n    {\n        return ERROR;\n    }\n\n    DuLinkList p, cecha = *L;\n    p = (DuLinkList)malloc(sizeof(DualNobe));\n    if (!p)\n    {\n        return ERROR;\n    }\n\n    p->data = e;\n    int j = 1;\n    while (cecha->next != *L && j < i)\n    {\n        cecha = cecha->next;\n        ++j;\n    }// \u5bfb\u627e\u63d2\u5165\u4f4d\u7f6e\u7684\u524d\u9a71\n\n    cecha->next->prior = p;\n    p->next = cecha->next;\n    cecha->next = p;\n    p->prior = cecha;\n    \n    return OK;\n}\n\nint listDelete(DuLinkList *L, int i, int *e)\n{\n    // \u5220\u9664\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u7684\u5143\u7d20, \u5e76\u8fd4\u56de\u5176\u503c\u7ed9e\n    if (i < 1)\n    {\n        return ERROR;\n    }\n\n    DuLinkList cecha = *L, p_free = NULL;\n\n    int j = 1;\n    while (cecha->next != *L && j < i)\n    {\n        cecha = cecha->next;\n        ++j;\n    }// \u5bfb\u627e\u5220\u9664\u4f4d\u7f6e\u7684\u524d\u9a71\n\n    if (cecha->next == *L)\n    {\n        return ERROR;\n    }\n\n    *e = cecha->next->data;\n    p_free = cecha->next;\n    cecha->next = cecha->next->next;\n    cecha->next->next->prior = cecha;\n    free(p_free);\n\n    return OK;\n}\n\nint listFree(DuLinkList *L)\n{\n    // \u91ca\u653e\u7ebf\u6027\u8868\n    DuLinkList cecha = (*L)->next, p_free = NULL;\n\n    while (cecha != *L)\n    {\n        p_free = cecha;\n        cecha = cecha->next;\n        free(p_free);\n    }\n    \n    p_free = cecha;\n    *L = NULL;\n    free(p_free);\n\n    return OK;\n}\n\nint main(void)\n{\n    // \u53cc\u5411\u5faa\u73af\u94fe\u8868 + \u5e26\u5934\u8282\u70b9 + \u8bfe\u5802\u7ec3\u4e60\n    DuLinkList head = NULL;\n    int e;\n    initList(&head);\n    for (int i = 'A'; i <= 'Z'; i++)\n    {\n        listAdd(&head, i);\n    }\n    printf(\"\u8bf7\u8f93\u5165\u4e00\u4e2a\u504f\u79fb\u91cf:\");\n    scanf(\"%d\", &e);\n    getchar();\n\n    listPrintE(head, e);\n    listFree(&head);\n    getchar();\n    return 0;\n}\n"})}),"\n",(0,L.jsx)(e.h3,{id:"\u8bfe\u540e\u7ec3\u4e60",children:"\u8bfe\u540e\u7ec3\u4e60"}),"\n",(0,L.jsx)(e.pre,{children:(0,L.jsx)(e.code,{className:"language-C",children:"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define OK 1    // \u7a0b\u5e8f\u6b63\u5e38\u8fd0\u884c\n#define ERROR 0 // \u7a0b\u5e8f\u8fd0\u884c\u62a5\u9519\n#define TRUE 1  //\n#define FALSE 0 //\n\nclock_t t;\n\ntypedef char ElemType;\ntypedef struct DualNobe\n{\n    ElemType data;\n    struct DualNobe *prior; // \u524d\u9a71\u7ed3\u70b9\n    struct DualNobe *next;  // \u540e\u7ee7\u7ed3\u70b9\n} DualNobe, *DuLinkList;\n\nint initList(DuLinkList *L);                      // \u521d\u59cb\u5316\u64cd\u4f5c, \u5efa\u7acb\u4e00\u4e2a\u7a7a\u7684\u7ebf\u6027\u8868 \u548c \u5934\u8282\u70b9\nint listInsert(DuLinkList *L, int i, int e);      // \u5728\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u63d2\u5165\u65b0\u5143\u7d20e\nint listDelete(DuLinkList *L, int i, int *e);     // \u5220\u9664\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u7684\u5143\u7d20, \u5e76\u8fd4\u56de\u5176\u503c\u7ed9e\n\nint listFree(DuLinkList *L);                      // \u91ca\u653e\u7ebf\u6027\u8868\nint listAdd(DuLinkList *L, int e);                // \u5728\u7ebf\u6027\u8868\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20\nint listPrintV(DuLinkList L, char d);              // \u6309\u7167\u504f\u79fb\u91cfe\u6253\u5370\u5355\u94fe\u8868\n\nint initList(DuLinkList *L)\n{\n    // \u521d\u59cb\u5316\u7a7a\u7ed3\u6784\u4f53\u6307\u9488\u4e3a\u53ea\u6709\u5934\u8282\u70b9\u7684\u53cc\u5411\u5faa\u73af\u94fe\u8868\n    if (!*L)\n    {\n        DuLinkList p;\n        p = (DuLinkList)malloc(sizeof(DualNobe));\n        if (!p)\n        {\n            return ERROR;\n        }\n        *L = p;\n        p->next = p;\n        p->prior = p;\n        return OK;\n    }\n    else\n    {\n        return ERROR;\n    }\n}\n\nint listAdd(DuLinkList *L, int e)\n{\n    // \u5c3e\u63d2\u6cd5 \u63d2\u5165\n    if (!*L)\n    {\n        return ERROR;\n    }\n\n    DuLinkList p, cecha = (*L)->prior;\n    p = (DuLinkList)malloc(sizeof(DualNobe));\n    if (!p)\n    {\n        return ERROR;\n    }\n    p->data = e;\n\n    cecha->next = p;\n    p->next = *L;\n    (*L)->prior = p;\n    p->prior = cecha;\n}\n\nint listPrintV(DuLinkList L, char d)\n{\n    // \u6253\u5370\u5355\u94fe\u8868\n    DuLinkList p = L;\n    for (int x = d - 'A'; x; --x)\n    {\n        p = p->next;\n    }\n\n    t = clock();\n    while (1)\n    {\n        if (clock() - t > 100)\n        {\n            t = clock();\n            break;\n        }\n        continue;\n    }\n    srand((unsigned)t);\n    int e = rand() % 100;\n    printf(\"%c\\t%d\\t\", d, e);\n    e = e % 26;\n    \n    if (e >= 0)\n    {\n        while (e--)\n        {\n            p = p->prior;\n        }   \n    }\n    else\n    {\n        --e;\n        while (e++)\n        {\n            p = p->next;\n        } \n    }\n\n    L = p;\n\n    do\n    {\n        if (p->data == '\\r')\n        {\n            p = p->next;\n            continue;\n        }\n        putchar(p->data);\n        p = p->next;\n        break;\n    }while (p != L);\n    putchar('\\n');\n    return OK;\n}\n\nint listInsert(DuLinkList *L, int i, int e)\n{\n    // \u5728\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u63d2\u5165\u65b0\u5143\u7d20e, \u5982\u679ci\u5927\u4e8e\u94fe\u8868\u957f\u5ea6,\u5219\u53ea\u5728\u6700\u540e\u7684\u4f4d\u7f6e\u63d2\u5165\n    if (i < 1)\n    {\n        return ERROR;\n    }\n\n    DuLinkList p, cecha = *L;\n    p = (DuLinkList)malloc(sizeof(DualNobe));\n    if (!p)\n    {\n        return ERROR;\n    }\n\n    p->data = e;\n    int j = 1;\n    while (cecha->next != *L && j < i)\n    {\n        cecha = cecha->next;\n        ++j;\n    }// \u5bfb\u627e\u63d2\u5165\u4f4d\u7f6e\u7684\u524d\u9a71\n\n    cecha->next->prior = p;\n    p->next = cecha->next;\n    cecha->next = p;\n    p->prior = cecha;\n    \n    return OK;\n}\n\nint listDelete(DuLinkList *L, int i, int *e)\n{\n    // \u5220\u9664\u7ebf\u6027\u8868L\u4e2d\u7b2ci\u4e2a\u4f4d\u7f6e\u7684\u5143\u7d20, \u5e76\u8fd4\u56de\u5176\u503c\u7ed9e\n    if (i < 1)\n    {\n        return ERROR;\n    }\n\n    DuLinkList cecha = *L, p_free = NULL;\n\n    int j = 1;\n    while (cecha->next != *L && j < i)\n    {\n        cecha = cecha->next;\n        ++j;\n    }// \u5bfb\u627e\u5220\u9664\u4f4d\u7f6e\u7684\u524d\u9a71\n\n    if (cecha->next == *L)\n    {\n        return ERROR;\n    }\n\n    *e = cecha->next->data;\n    p_free = cecha->next;\n    cecha->next = cecha->next->next;\n    cecha->next->next->prior = cecha;\n    free(p_free);\n\n    return OK;\n}\n\nint listFree(DuLinkList *L)\n{\n    // \u91ca\u653e\u7ebf\u6027\u8868\n    DuLinkList cecha = (*L)->next, p_free = NULL;\n\n    while (cecha != *L)\n    {\n        p_free = cecha;\n        cecha = cecha->next;\n        free(p_free);\n    }\n    \n    p_free = cecha;\n    *L = NULL;\n    free(p_free);\n\n    return OK;\n}\n\nint main(void)\n{\n    // \u53cc\u5411\u5faa\u73af\u94fe\u8868 + \u5e26\u5934\u8282\u70b9 + \u8bfe\u540e\u7ec3\u4e60 \u7ef4\u5409\u5c3c\u4e9a\u52a0\u5bc6\n    DuLinkList head = NULL;\n    char str[32];\n    int e = 0;\n    initList(&head);\n    for (int i = 'A'; i <= 'Z'; i++)// \u751f\u6210\n    {\n        listAdd(&head, i);\n    }\n    printf(\"\u8bf7\u8f93\u5165\u9700\u8981\u52a0\u5bc6\u7684\u5185\u5bb9(A-Z):\");\n    scanf(\"%s\", str);\n    getchar();\n    \n    printf(\"\u539f\\t\u4f4d\u79fb\\t\u52a0\u5bc6\u7ed3\u679c\\n\");\n    while (str[e] != '\\0')\n    {\n        listPrintV(head, str[e++]);\n    }\n    listFree(&head);\n\n    return 0;\n}\n"})})]})}function h(n={}){const{wrapper:e}={...(0,c.R)(),...n.components};return e?(0,L.jsx)(e,{...n,children:(0,L.jsx)(p,{...n})}):p(n)}}}]);