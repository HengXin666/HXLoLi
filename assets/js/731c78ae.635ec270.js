"use strict";(self.webpackChunkhx_loli=self.webpackChunkhx_loli||[]).push([[97882],{768:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>S,contentTitle:()=>d,default:()=>T,frontMatter:()=>c,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u6811/\u4e8c\u53c9\u6811\u7684\u524d\u4e2d\u540e\u5c42\u904d\u5386code/index","title":"\u4ee3\u7801\u5b9e\u73b0","description":"\u524d\u5e8f\u904d\u5386","source":"@site/docs/001-\u8ba1\u4f6c\u5e38\u8b58/001-\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/004-\u3010\u6570\u636e\u7ed3\u6784\u3011\u6811/003-\u4e8c\u53c9\u6811\u7684\u524d\u4e2d\u540e\u5c42\u904d\u5386code/index.md","sourceDirName":"001-\u8ba1\u4f6c\u5e38\u8b58/001-\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/004-\u3010\u6570\u636e\u7ed3\u6784\u3011\u6811/003-\u4e8c\u53c9\u6811\u7684\u524d\u4e2d\u540e\u5c42\u904d\u5386code","slug":"/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u6811/\u4e8c\u53c9\u6811\u7684\u524d\u4e2d\u540e\u5c42\u904d\u5386code/","permalink":"/HXLoLi/docs/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u6811/\u4e8c\u53c9\u6811\u7684\u524d\u4e2d\u540e\u5c42\u904d\u5386code/","draft":false,"unlisted":false,"editUrl":"https://github.com/HengXin666/HXLoLi/edit/main/docs/001-\u8ba1\u4f6c\u5e38\u8b58/001-\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/004-\u3010\u6570\u636e\u7ed3\u6784\u3011\u6811/003-\u4e8c\u53c9\u6811\u7684\u524d\u4e2d\u540e\u5c42\u904d\u5386code/index.md","tags":[],"version":"current","lastUpdatedBy":"Heng_Xin_666","lastUpdatedAt":1745851959000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"\u4e8c\u53c9\u6811","permalink":"/HXLoLi/docs/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u6811/\u4e8c\u53c9\u6811/"},"next":{"title":"\u7ebf\u7d22\u4e8c\u53c9\u6811","permalink":"/HXLoLi/docs/\u8ba1\u4f6c\u5e38\u8b58/\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5/\u3010\u6570\u636e\u7ed3\u6784\u3011\u6811/\u7ebf\u7d22\u4e8c\u53c9\u6811/"}}');var r=t(74848),a=t(28453);const c={},d="\u4ee3\u7801\u5b9e\u73b0",S={},o=[{value:"\u524d\u5e8f\u904d\u5386",id:"\u524d\u5e8f\u904d\u5386",level:2},{value:"\u9012\u5f52",id:"\u9012\u5f52",level:3},{value:"\u975e\u9012\u5f52",id:"\u975e\u9012\u5f52",level:3},{value:"\u4e2d\u5e8f\u904d\u5386",id:"\u4e2d\u5e8f\u904d\u5386",level:2},{value:"\u9012\u5f52",id:"\u9012\u5f52-1",level:3},{value:"\u975e\u9012\u5f52",id:"\u975e\u9012\u5f52-1",level:3},{value:"\u540e\u5e8f\u904d\u5386",id:"\u540e\u5e8f\u904d\u5386",level:2},{value:"\u9012\u5f52",id:"\u9012\u5f52-2",level:3},{value:"\u975e\u9012\u5f52",id:"\u975e\u9012\u5f52-2",level:3},{value:"\u5e7f\u5ea6\u4f18\u5148 / \u5c42\u5e8f\u904d\u5386",id:"\u5e7f\u5ea6\u4f18\u5148--\u5c42\u5e8f\u904d\u5386",level:2}];function u(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",pre:"pre",...(0,a.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"\u4ee3\u7801\u5b9e\u73b0",children:"\u4ee3\u7801\u5b9e\u73b0"})}),"\n",(0,r.jsx)(e.h2,{id:"\u524d\u5e8f\u904d\u5386",children:"\u524d\u5e8f\u904d\u5386"}),"\n",(0,r.jsx)(e.h3,{id:"\u9012\u5f52",children:"\u9012\u5f52"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-C",children:'void \u524d\u5e8f\u904d\u5386(BTree *root, BTNode *node) {\n    if (!node) {\n        return;\n    }\n\n    // \u9700\u8981\u505a\u7684\u4e8b\u60c5\n    printf("%d ", node->data);\n    \u524d\u5e8f\u904d\u5386(root, node->left);\n    \u524d\u5e8f\u904d\u5386(root, node->right);\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\u975e\u9012\u5f52",children:"\u975e\u9012\u5f52"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-C",children:'#include <stdio.h>\n#include <stdlib.h>\n\n#define OK 1    // \u7a0b\u5e8f\u6b63\u5e38\u8fd0\u884c\n#define ERROR 0 // \u7a0b\u5e8f\u8fd0\u884c\u62a5\u9519\n#define TRUE 1  //\n#define FALSE 0 //\n\n#define MAXSIZE 16      // \u6808\u7684\u5927\u5c0f\n\ntypedef int State;      // \u72b6\u6001 OK or ERROR\ntypedef char ElemType;\n\ntypedef struct BiTNobe\n{\n    ElemType data;\n    struct BiTNobe *lchild, *rchild;// \u5de6\u5b69\u5b50, \u53f3\u5b69\u5b50\n} BiTNobe, *BiTree;\n\ntypedef struct SqStack\n{\n    BiTNobe *data[MAXSIZE];\n    int top;// \u7528\u4e8e\u6808\u9876\u7684\u6307\u9488\n}SqStack;\n\nSqStack *initStack(void);               // \u521d\u59cb\u5316\u64cd\u4f5c, \u5efa\u7acb\u4e00\u4e2a\u7a7a\u6808\u7684S\nState destroyStack(SqStack **S);        // \u9500\u6bc1\u6808S\n\nState pushStack(SqStack **S, BiTNobe * e);   // \u82e5\u6808S\u5b58\u5728, \u63d2\u5165\u65b0\u5143\u7d20e\u5230\u6808\u4e2d\u5e76\u4e14\u6210\u4e3a\u65b0\u7684\u6808\u9876\u5143\u7d20\nState popStack(SqStack **S, BiTNobe **e);    // \u5220\u9664\u6808\u9876\u5143\u7d20, \u5e76\u7528e\u8fd4\u56de\u5176\u503c \n\n\nvoid PreOrderTraveres(BiTree T);            // \u524d\u5e8f\u904d\u5386\nState initTree(BiTree *T);                  // \u521d\u59cb\u5316\u6811\nState createBiTree(BiTree *T);              // \u521b\u5efa\u4e00\u9897\u4e8c\u53c9\u6811\nState printStack(SqStack *S);               // \u5148\u51fa\u5148\u6253\u5370\n\n// ----------------------- \u524d\u5e8f\u904d\u5386 - \u9700\u8981\u638c\u63e1 -----------------------\n/* \u975e\u9012\u5f52\u7684\u5148\u5e8f\u904d\u5386\uff0c\u5f15\u5165\u6808\n * 1. \u5148\u538b\u5165\u6839\u8282\u70b9\u5230\u6808\n * 2. \u51fa\u6808\u51fa\u4efb\u52a1\n * 3. \u6253\u5370\u4efb\u52a1\uff0c\u5206\u914d\u4efb\u52a1\u7684\u673a\u5236\uff0c\u6709\u53f3\u5148\u538b\u53f3\uff0c\u6709\u5de6\u518d\u538b\u5de6<\u5148\u53f3\u540e\u5de6>\n * 4. \u53d6\u4efb\u52a1\uff0c\u56de\u52302\n * 5. \u9000\u51fa\u6761\u4ef6\uff1a\u6808\u7a7a\n * */\nvoid PreOrderTraveres(BiTree T)\n{\n    // \u524d\u5e8f\u904d\u5386 - \u975e\u9012\u5f52\n    SqStack *stack = initStack();\n    BiTNobe *node = T;\n    pushStack(&stack, T);\n    while (popStack(&stack, &node))\n    {\n        if (node->rchild)\n        {\n            pushStack(&stack, node->rchild);\n        }\n\n        if (node->lchild)\n        {\n            pushStack(&stack, node->lchild);\n        }\n    }\n    destroyStack(&stack);\n}\n\nState initTree(BiTree *T)\n{\n    *T = NULL;\n    return OK;\n}\n\nState createBiTree(BiTree *T)\n{\n    char c;// \u95ee\u9898\u7684\u6ca1\u6709, \u662f\u8f93\u5165\u683c\u5f0f\u548c0\u7684\u4e0d\u4e00\u6837\n    // \u7ed3\u70b9\u4e3a\u53f6\u7ed3\u70b9\u52192\u7a7a\u683c\n    scanf("%c", &c);\n    if (c == \' \')\n    {\n        *T = NULL;// \u4e0d\u7528\u91ca\u653e\u662f\u56e0\u4e3a\u538b\u6839\u5c31\u6ca1\u6709\u5206\u914d\n    }\n    else\n    {\n        *T = (BiTree)malloc(sizeof(BiTNobe));\n        (*T)->data = c;\n        createBiTree(&(*T)->lchild);\n        createBiTree(&(*T)->rchild);\n    }\n    return OK;\n}\n\n\n\nSqStack *initStack(void)\n{\n    // \u521d\u59cb\u5316\u64cd\u4f5c, \u5efa\u7acb\u4e00\u4e2a\u7a7a\u6808\u7684S\n    SqStack *S = (SqStack *)malloc(sizeof(SqStack));\n    S->top = -1;\n    return S;\n}\n\nState pushStack(SqStack **S, BiTNobe *e)\n{\n    // \u82e5\u6808S\u5b58\u5728, \u63d2\u5165\u65b0\u5143\u7d20e\u5230\u6808\u4e2d\u5e76\u4e14\u6210\u4e3a\u65b0\u7684\u6808\u9876\u5143\u7d20\n    if ((*S)->top == MAXSIZE - 1)\n    {\n        return ERROR;\n    }\n\n    (*S)->data[++((*S)->top)] = e;\n    return OK;\n}\n\nState popStack(SqStack **S, BiTNobe **e)\n{\n    // \u5220\u9664\u6808\u9876\u5143\u7d20, \u5e76\u7528e\u8fd4\u56de\u5176\u503c \n    if ((*S)->top == -1)\n    {\n        return ERROR;\n    }\n    *e = (*S)->data[((*S)->top)--];\n    \n    /* \u6267\u884c\u7684\u64cd\u4f5c */\n    printf("%c ", (*e)->data);\n    return OK;\n}\n\nState printStack(SqStack *S)\n{\n    // \u5148\u51fa\u5148\u6253\u5370\n\n    for (int i = S->top; i > -1; i--)\n    {\n        printf("%d ", S->data[i]);\n    }\n\n    return OK;\n}\n\nState destroyStack(SqStack **S)\n{\n    free(*S);\n    *S = NULL;\n    return OK;\n}\n\nint main(void)\n{\n    // \u6808 \u7684 \u6570\u7ec4(\u987a\u5e8f\u5b58\u50a8\u7ed3\u6784)\u8868\u793a\n    // \u4e8c\u53c9\u6811\u7684\u975e\u9012\u5f52\u524d\u5e8f\u904d\u5386\n    BiTree bitree;\n    initTree(&bitree);\n    printf("\u8bf7\u8f93\u5165:");\n    createBiTree(&bitree);\n    printf("\u5df2\u63a5\u53d7!\\n");\n    PreOrderTraveres(bitree);\n\n    getchar();\n    getchar();\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"\u4e2d\u5e8f\u904d\u5386",children:"\u4e2d\u5e8f\u904d\u5386"}),"\n",(0,r.jsx)(e.h3,{id:"\u9012\u5f52-1",children:"\u9012\u5f52"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-C",children:'void \u4e2d\u5e8f\u904d\u5386(BTree *root, BTNode *node) {\n    if (!node) {\n        return;\n    }\n\n    \u4e2d\u5e8f\u904d\u5386(root, node->left);\n    // \u9700\u8981\u505a\u7684\u4e8b\u60c5\n    printf("%d ", node->data);\n    \u4e2d\u5e8f\u904d\u5386(root, node->right);\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\u975e\u9012\u5f52-1",children:"\u975e\u9012\u5f52"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-C",children:'#include <stdio.h>\n#include <stdlib.h>\n\n#define OK 1    // \u7a0b\u5e8f\u6b63\u5e38\u8fd0\u884c\n#define ERROR 0 // \u7a0b\u5e8f\u8fd0\u884c\u62a5\u9519\n#define TRUE 1  //\n#define FALSE 0 //\n\n#define MAXSIZE 16      // \u6808\u7684\u5927\u5c0f\n\ntypedef int State;      // \u72b6\u6001 OK or ERROR\ntypedef char ElemType;\n\ntypedef struct BiTNobe\n{\n    ElemType data;\n    struct BiTNobe *lchild, *rchild;// \u5de6\u5b69\u5b50, \u53f3\u5b69\u5b50\n} BiTNobe, *BiTree;\n\ntypedef struct SqStack\n{\n    BiTNobe *data[MAXSIZE];\n    int top;// \u7528\u4e8e\u6808\u9876\u7684\u6307\u9488\n}SqStack;\n\nSqStack *initStack(void);            // \u521d\u59cb\u5316\u64cd\u4f5c, \u5efa\u7acb\u4e00\u4e2a\u7a7a\u6808\u7684S\nState destroyStack(SqStack **S);     // \u9500\u6bc1\u6808S\n\nState pushStack(SqStack **S, BiTNobe * e);   // \u82e5\u6808S\u5b58\u5728, \u63d2\u5165\u65b0\u5143\u7d20e\u5230\u6808\u4e2d\u5e76\u4e14\u6210\u4e3a\u65b0\u7684\u6808\u9876\u5143\u7d20\nState popStack(SqStack **S, BiTNobe **e);    // \u5220\u9664\u6808\u9876\u5143\u7d20, \u5e76\u7528e\u8fd4\u56de\u5176\u503c\nState ifStackSky(SqStack *S);                // \u5224\u65ad\u6808\u662f\u5426\u6709\u5185\u5bb9\n\n\nvoid PreOrderTraveres(BiTree T);            // \u4e2d\u5e8f\u904d\u5386\nState initTree(BiTree *T);                  // \u521d\u59cb\u5316\u6811\nState createBiTree(BiTree *T);              // \u521b\u5efa\u4e00\u9897\u4e8c\u53c9\u6811\nState printStack(SqStack *S);               // \u5148\u51fa\u5148\u6253\u5370\n\nState ifStackSky(SqStack *S)\n{\n    if (S->top == -1)\n        return ERROR;\n    return OK;\n}\n\n// ----------------------- \u4e2d\u5e8f\u904d\u5386 - \u9700\u8981\u7406\u89e3 -----------------------\n/* \u975e\u9012\u5f52\u7684\u4e2d\u5e8f\u904d\u5386\n * 1. \u4ee5\u6839\u8282\u70b9\u5f00\u59cb\uff0c\u628a\u6574\u6761\u5de6\u8fb9\u8fdb\u6808\n * 2. \u51fa\u6808\n * 3. \u5904\u7406\u4efb\u52a1\uff0c\u6253\u5370\uff0c\u5224\u65ad\u662f\u5426\u5728\u8fd9\u4e2a\u4efb\u52a1\u4e0a\uff0c\u8fd8\u6709\u65b0\u4efb\u52a1\n * 4. \u4ee5\u8fd9\u4e2a\u4efb\u52a1\u7684\u53f3\u5b69\u5b50\u4e3a\u65b0\u8282\u70b9\uff0c\u518d\u6b21\u6267\u884c1\n * 5. \u9000\u51fa\u6808\u4e3a\u7a7a\n * */\nvoid PreOrderTraveres(BiTree T)\n{\n    // \u4e2d\u5e8f\u904d\u5386 - \u975e\u9012\u5f52\n    SqStack *stack = initStack();\n    BiTNobe *node = T;\n    while (node || ifStackSky(stack))\n    {\n        if (node)\n        {\n            pushStack(&stack, node);\n            node = node->lchild;\n        }\n        else\n        {\n            popStack(&stack, &node);\n            node = node->rchild;\n        }\n    }\n    destroyStack(&stack);\n}\n\nState destroyStack(SqStack **S)\n{\n    free(*S);\n    *S = NULL;\n    return OK;\n}\n\n\nState initTree(BiTree *T)\n{\n    *T = NULL;\n    return OK;\n}\n\nState createBiTree(BiTree *T)\n{\n    char c;// \u95ee\u9898\u7684\u6ca1\u6709, \u662f\u8f93\u5165\u683c\u5f0f\u548c0\u7684\u4e0d\u4e00\u6837\n    // \u7ed3\u70b9\u4e3a\u53f6\u7ed3\u70b9\u52192\u7a7a\u683c\n    scanf("%c", &c);\n    if (c == \' \')\n    {\n        *T = NULL;// \u4e0d\u7528\u91ca\u653e\u662f\u56e0\u4e3a\u538b\u6839\u5c31\u6ca1\u6709\u5206\u914d\n    }\n    else\n    {\n        *T = (BiTree)malloc(sizeof(BiTNobe));\n        (*T)->data = c;\n        createBiTree(&(*T)->lchild);\n        createBiTree(&(*T)->rchild);\n    }\n    return OK;\n}\n\n\n\nSqStack *initStack(void)\n{\n    // \u521d\u59cb\u5316\u64cd\u4f5c, \u5efa\u7acb\u4e00\u4e2a\u7a7a\u6808\u7684S\n    SqStack *S = (SqStack *)malloc(sizeof(SqStack));\n    S->top = -1;\n    return S;\n}\n\nState pushStack(SqStack **S, BiTNobe *e)\n{\n    // \u82e5\u6808S\u5b58\u5728, \u63d2\u5165\u65b0\u5143\u7d20e\u5230\u6808\u4e2d\u5e76\u4e14\u6210\u4e3a\u65b0\u7684\u6808\u9876\u5143\u7d20\n    if ((*S)->top == MAXSIZE - 1)\n    {\n        return ERROR;\n    }\n\n    (*S)->data[++((*S)->top)] = e;\n    return OK;\n}\n\nState popStack(SqStack **S, BiTNobe **e)\n{\n    // \u5220\u9664\u6808\u9876\u5143\u7d20, \u5e76\u7528e\u8fd4\u56de\u5176\u503c \n    if ((*S)->top == -1)\n    {\n        return ERROR;\n    }\n    *e = (*S)->data[((*S)->top)--];\n    \n    /* \u6267\u884c\u7684\u64cd\u4f5c */\n    printf("%c ", (*e)->data);\n    return OK;\n}\n\nState printStack(SqStack *S)\n{\n    // \u5148\u51fa\u5148\u6253\u5370\n\n    for (int i = S->top; i > -1; i--)\n    {\n        printf("%d ", S->data[i]);\n    }\n\n    return OK;\n}\n\nint main(void)\n{\n    // \u6808 \u7684 \u6570\u7ec4(\u987a\u5e8f\u5b58\u50a8\u7ed3\u6784)\u8868\u793a\n    // \u4e8c\u53c9\u6811\u7684\u975e\u9012\u5f52\u4e2d\u5e8f\u904d\u5386\n    BiTree bitree;\n    initTree(&bitree);\n    printf("\u8bf7\u8f93\u5165:");\n    createBiTree(&bitree);\n    printf("\u5df2\u63a5\u53d7!\\n");\n    PreOrderTraveres(bitree);\n\n    getchar();\n    getchar();\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"\u540e\u5e8f\u904d\u5386",children:"\u540e\u5e8f\u904d\u5386"}),"\n",(0,r.jsx)(e.h3,{id:"\u9012\u5f52-2",children:"\u9012\u5f52"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-C",children:'void \u540e\u5e8f\u904d\u5386(BTree *root, BTNode *node) {\n    if (!node) {\n        return;\n    }\n\n    \u540e\u5e8f\u904d\u5386(root, node->left);\n    \u540e\u5e8f\u904d\u5386(root, node->right);\n  \n    // \u9700\u8981\u505a\u7684\u4e8b\u60c5\n    printf("%d ", node->data);\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\u975e\u9012\u5f52-2",children:"\u975e\u9012\u5f52"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-C",children:'#include <stdio.h>\n#include <stdlib.h>\n\n#define OK 1    // \u7a0b\u5e8f\u6b63\u5e38\u8fd0\u884c\n#define ERROR 0 // \u7a0b\u5e8f\u8fd0\u884c\u62a5\u9519\n#define TRUE 1  //\n#define FALSE 0 //\n\n#define MAXSIZE 16      // \u6808\u7684\u5927\u5c0f\n\ntypedef int State;      // \u72b6\u6001 OK or ERROR\ntypedef char ElemType;\n\ntypedef struct BiTNobe\n{\n    ElemType data;\n    struct BiTNobe *lchild, *rchild;// \u5de6\u5b69\u5b50, \u53f3\u5b69\u5b50\n} BiTNobe, *BiTree;\n\ntypedef struct SqStack\n{\n    BiTNobe *data[MAXSIZE];\n    int top;// \u7528\u4e8e\u6808\u9876\u7684\u6307\u9488\n}SqStack;\n\nSqStack *initStack(void);            // \u521d\u59cb\u5316\u64cd\u4f5c, \u5efa\u7acb\u4e00\u4e2a\u7a7a\u6808\u7684S\nState destroyStack(SqStack **S);     // \u9500\u6bc1\u6808S\n\nState pushStack(SqStack **S, BiTNobe * e);   // \u82e5\u6808S\u5b58\u5728, \u63d2\u5165\u65b0\u5143\u7d20e\u5230\u6808\u4e2d\u5e76\u4e14\u6210\u4e3a\u65b0\u7684\u6808\u9876\u5143\u7d20\nState popStack(SqStack **S, BiTNobe **e);    // \u5220\u9664\u6808\u9876\u5143\u7d20, \u5e76\u7528e\u8fd4\u56de\u5176\u503c\nState ifStackSky(SqStack *S);                // \u5224\u65ad\u6808\u662f\u5426\u6709\u5185\u5bb9\n\n\nvoid PreOrderTraveres(BiTree T);            // \u540e\u5e8f\u904d\u5386\nState initTree(BiTree *T);                  // \u521d\u59cb\u5316\u6811\nState createBiTree(BiTree *T);              // \u521b\u5efa\u4e00\u9897\u4e8c\u53c9\u6811\nState printStack(SqStack *S);               // \u5148\u51fa\u5148\u6253\u5370\n\nState ifStackSky(SqStack *S)\n{\n    if (S->top == -1)\n        return ERROR;\n    return OK;\n}\n\n// ----------------------- \u540e\u5e8f\u904d\u5386 - \u77e5\u9053\u5373\u53ef -----------------------\n/* \u975e\u9012\u5f52\u540e\u5e8f\u904d\u5386\uff0c\u9700\u8981\u4e24\u4e2a\u6808\uff0c\u7b2c\u4e00\u4e2a\u6808\u4e3a\u8f85\u52a9\u6808\uff0c\u7b2c\u4e8c\u4e2a\u6808\u624d\u662f\u8f93\u51fa\u6808\n * \u7b2c\u4e00\u4e2a\u6808\u521d\u59cb\u5316\u5934\u7ed3\u70b9\uff0c\u5f39\u51fa\u5230\u7b2c\u4e8c\u4e2a\u6808\uff0c\u6839\u8282\u70b9\u5c31\u6700\u540e\u51fa\u4e86\n * \u8f85\u52a9\u6808\u8981\u5148\u5de6\u540e\u53f3\u538b\uff0c\u5f39\u51fa\u8f85\u52a9\u6808\u7684\u4e00\u4e2a\u5143\u7d20\uff0c\u653e\u5165\u7b2c\u4e8c\u4e2a\u6808\n * \u653e\u5165\u7b2c\u4e8c\u4e2a\u6808\u7684\u8282\u70b9 \u5148\u5de6\u540e\u53f3\u653e\u5165\u8f85\u52a9\u6808\n * \u76f4\u5230\u8f85\u52a9\u6808\u4e3a\u7a7a\n * */\nvoid PreOrderTraveres(BiTree T)\n{\n    // \u540e\u5e8f\u904d\u5386 - \u975e\u9012\u5f52\n    SqStack *stack_fuzu = initStack();  // \u8f85\u52a9\u6808\n    SqStack *stack_put = initStack();   // \u8f93\u51fa\u6808\n    BiTNobe *node = T;\n    pushStack(&stack_fuzu, node);\n    while (ifStackSky(stack_fuzu))\n    {\n        popStack(&stack_fuzu, &node);\n        pushStack(&stack_put, node);\n        if (node->lchild)\n            pushStack(&stack_fuzu, node->lchild);\n        if (node->rchild)\n            pushStack(&stack_fuzu, node->rchild);\n    }\n\n    while (ifStackSky(stack_put))\n    {\n        popStack(&stack_put, &node);\n        printf("%c ", node->data);\n    }\n    destroyStack(&stack_fuzu);\n    destroyStack(&stack_put);\n}\n\nState destroyStack(SqStack **S)\n{\n    free(*S);\n    *S = NULL;\n    return OK;\n}\n\nState initTree(BiTree *T)\n{\n    *T = NULL;\n    return OK;\n}\n\nState createBiTree(BiTree *T)\n{\n    char c;// \u95ee\u9898\u7684\u6ca1\u6709, \u662f\u8f93\u5165\u683c\u5f0f\u548c0\u7684\u4e0d\u4e00\u6837\n    // \u7ed3\u70b9\u4e3a\u53f6\u7ed3\u70b9\u52192\u7a7a\u683c\n    scanf("%c", &c);\n    if (c == \' \')\n    {\n        *T = NULL;// \u4e0d\u7528\u91ca\u653e\u662f\u56e0\u4e3a\u538b\u6839\u5c31\u6ca1\u6709\u5206\u914d\n    }\n    else\n    {\n        *T = (BiTree)malloc(sizeof(BiTNobe));\n        (*T)->data = c;\n        createBiTree(&(*T)->lchild);\n        createBiTree(&(*T)->rchild);\n    }\n    return OK;\n}\n\n\n\nSqStack *initStack(void)\n{\n    // \u521d\u59cb\u5316\u64cd\u4f5c, \u5efa\u7acb\u4e00\u4e2a\u7a7a\u6808\u7684S\n    SqStack *S = (SqStack *)malloc(sizeof(SqStack));\n    S->top = -1;\n    return S;\n}\n\nState pushStack(SqStack **S, BiTNobe *e)\n{\n    // \u82e5\u6808S\u5b58\u5728, \u63d2\u5165\u65b0\u5143\u7d20e\u5230\u6808\u4e2d\u5e76\u4e14\u6210\u4e3a\u65b0\u7684\u6808\u9876\u5143\u7d20\n    if ((*S)->top == MAXSIZE - 1)\n    {\n        return ERROR;\n    }\n\n    (*S)->data[++((*S)->top)] = e;\n    return OK;\n}\n\nState popStack(SqStack **S, BiTNobe **e)\n{\n    // \u5220\u9664\u6808\u9876\u5143\u7d20, \u5e76\u7528e\u8fd4\u56de\u5176\u503c \n    if ((*S)->top == -1)\n    {\n        return ERROR;\n    }\n    *e = (*S)->data[((*S)->top)--];\n    return OK;\n}\n\nState printStack(SqStack *S)\n{\n    // \u5148\u51fa\u5148\u6253\u5370\n\n    for (int i = S->top; i > -1; i--)\n    {\n        printf("%d ", S->data[i]);\n    }\n\n    return OK;\n}\n\nint main(void)\n{\n    // \u6808 \u7684 \u6570\u7ec4(\u987a\u5e8f\u5b58\u50a8\u7ed3\u6784)\u8868\u793a\n    // \u4e8c\u53c9\u6811\u7684\u975e\u9012\u5f52\u540e\u5e8f\u904d\u5386\n    BiTree bitree;\n    initTree(&bitree);\n    printf("\u8bf7\u8f93\u5165:");\n    createBiTree(&bitree);\n    printf("\u5df2\u63a5\u53d7!\\n");\n    PreOrderTraveres(bitree);\n\n    getchar();\n    getchar();\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"\u5e7f\u5ea6\u4f18\u5148--\u5c42\u5e8f\u904d\u5386",children:"\u5e7f\u5ea6\u4f18\u5148 / \u5c42\u5e8f\u904d\u5386"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-C",children:'#include <stdio.h>\n#include <stdlib.h>\n\n#define OK 1    // \u7a0b\u5e8f\u6b63\u5e38\u8fd0\u884c\n#define ERROR 0 // \u7a0b\u5e8f\u8fd0\u884c\u62a5\u9519\n\ntypedef int State;      // \u72b6\u6001 OK or ERROR\ntypedef char ElemType;\n\ntypedef struct BiTNobe\n{\n    ElemType data;\n    struct BiTNobe *lchild, *rchild;        // \u5de6\u5b69\u5b50, \u53f3\u5b69\u5b50\n} BiTNobe, *BiTree;\n\ntypedef struct QueueBiTNode\n{\n    BiTNobe *treeNode;\n    struct QueueBiTNode *next;\n} QueueBiTNode;\n\ntypedef struct QueueBiT\n{\n    QueueBiTNode *top;  // \u961f\u5934\n    QueueBiTNode *base; // \u961f\u5c3e\n    int node_num;\n} QueueBiT;\n\nvoid DFS(BiTree T);                         // \u5e7f\u5ea6\u4f18\u5148\u904d\u5386\nState initTree(BiTree *T);                  // \u521d\u59cb\u5316\u6811\nState createBiTree(BiTree *T);              // \u521b\u5efa\u4e00\u9897\u4e8c\u53c9\u6811\n\nQueueBiT *initQueueBiT(void);                   // \u7533\u8bf7\u961f\u5217\nState addQueueBiTNode(QueueBiT **Q, BiTree T);  // \u5165\u961f\nState delQueueBiTNode(QueueBiT **Q);            // \u51fa\u961f<\u5b9a\u5236>\n_Bool ifQueueBiTNum(QueueBiT *Q);               // \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a\nvoid freeQueueBiT(QueueBiT **queue);            // \u91ca\u653e\u961f\u5217\n\n_Bool ifQueueBiTNum(QueueBiT *Q)\n{\n    // \u8fd4\u56de 1 \u4e3a\u7a7a\n    // \u8fd4\u56de 0 \u975e\u7a7a\n    if (Q->node_num)\n        return 0;\n    return 1;\n}\n\nState delQueueBiTNode(QueueBiT **Q)\n{\n    // \u51fa\u961f\u5217, \u5e76\u4e14\u5c06\u51fa\u961f\u5217\u7684\u6811\u7684\u5b50\u6811\u6309\u5148\u5de6\u540e\u53f3\u7684\u5f62\u5f0f\u5165\u961f, \u5e76\u4e14\u4fdd\u8bc1\u5165\u961f\u7684\u4e0d\u80fd\u53c8\u51fa\u961f\n    QueueBiTNode *p = (*Q)->top;\n    for (int delNum = (*Q)->node_num; delNum > 0; --delNum)\n    {\n        if (p->treeNode->lchild)\n        {\n            addQueueBiTNode(Q, p->treeNode->lchild);\n        }\n        if (p->treeNode->rchild)\n        {\n            addQueueBiTNode(Q, p->treeNode->rchild);\n        }\n        p = p->next;\n        --(*Q)->node_num;\n    }\n    (*Q)->top = p;\n    return OK;\n}\n\nState addQueueBiTNode(QueueBiT **Q, BiTree T)\n{\n    QueueBiTNode *p = (QueueBiTNode *)malloc(sizeof(QueueBiTNode));\n    if (!p)\n        return ERROR;\n    p->treeNode = T;\n\n    /* \u5728\u8fd9\u91cc\u8fdb\u884c\u64cd\u4f5c */\n    printf("%c ", T->data);\n\n    if (!(*Q)->top)\n    {\n        p->next = NULL;\n        (*Q)->top = p;\n        (*Q)->base = p;\n        ++(*Q)->node_num;\n        return OK;\n    }\n    \n    p->next = (*Q)->base->next;\n    (*Q)->base->next = p;\n    (*Q)->base = p;\n    ++(*Q)->node_num;\n    return OK;\n}\n\nvoid freeQueueBiT(QueueBiT **queue)\n{\n    // \u7591\u95ee\u6ef4\u6709: free(queue) \u5462?\n    free(*queue);\n    *queue = NULL;\n}\n\nQueueBiT *initQueueBiT(void)\n{\n    QueueBiT *queue = (QueueBiT *)malloc(sizeof(QueueBiT));\n    queue->base = NULL;\n    queue->top = NULL;\n    queue->node_num = 0;\n    return queue;\n}\n\nvoid DFS(BiTree T)\n{\n    // \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 / \u5c42\u5e8f\u904d\u5386\n    QueueBiT *queue = initQueueBiT(); // \u7533\u8bf7\u4e00\u4e2a\u8f85\u52a9\u961f\u5217\n    addQueueBiTNode(&queue ,T);\n    while(!ifQueueBiTNum(queue))\n    {\n        delQueueBiTNode(&queue);\n    }\n    freeQueueBiT(&queue);\n}\n\nState initTree(BiTree *T)\n{\n    *T = NULL;\n    return OK;\n}\n\nState createBiTree(BiTree *T)\n{\n    char c;// \u95ee\u9898\u7684\u6ca1\u6709, \u662f\u8f93\u5165\u683c\u5f0f\u548c0\u7684\u4e0d\u4e00\u6837\n    // \u7ed3\u70b9\u4e3a\u53f6\u7ed3\u70b9\u52192\u7a7a\u683c\n    scanf("%c", &c);\n    if (c == \' \')\n    {\n        *T = NULL;// \u4e0d\u7528\u91ca\u653e\u662f\u56e0\u4e3a\u538b\u6839\u5c31\u6ca1\u6709\u5206\u914d\n    }\n    else\n    {\n        *T = (BiTree)malloc(sizeof(BiTNobe));\n        (*T)->data = c;\n        createBiTree(&(*T)->lchild);\n        createBiTree(&(*T)->rchild);\n    }\n    return OK;\n}\n\nint main(void)\n{\n    // \u4e8c\u53c9\u6811 - \u4e8c\u53c9\u94fe\u8868 - BFS\u904d\u5386 - \u81ea\u4e2a\u7684 ()\n\n    // \u7a7a\u683c\u4ee3\u8868\u4e3a\u7a7a\u8282\u70b9\n    BiTree bitree;\n    initTree(&bitree);\n    printf("\u8bf7\u8f93\u5165:");\n    createBiTree(&bitree);\n    BFS(bitree);\n\n    getchar();\n    getchar();\n    return 0;\n}\n'})})]})}function T(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(u,{...n})}):u(n)}},28453:(n,e,t)=>{t.d(e,{R:()=>c,x:()=>d});var i=t(96540);const r={},a=i.createContext(r);function c(n){const e=i.useContext(a);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function d(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:c(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);